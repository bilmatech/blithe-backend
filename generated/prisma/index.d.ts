
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Credential
 * 
 */
export type Credential = $Result.DefaultSelection<Prisma.$CredentialPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model Administrator
 * 
 */
export type Administrator = $Result.DefaultSelection<Prisma.$AdministratorPayload>
/**
 * Model Guardian
 * 
 */
export type Guardian = $Result.DefaultSelection<Prisma.$GuardianPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model School
 * 
 */
export type School = $Result.DefaultSelection<Prisma.$SchoolPayload>
/**
 * Model SchoolDirectorVerification
 * 
 */
export type SchoolDirectorVerification = $Result.DefaultSelection<Prisma.$SchoolDirectorVerificationPayload>
/**
 * Model SchoolOwnershipVerification
 * 
 */
export type SchoolOwnershipVerification = $Result.DefaultSelection<Prisma.$SchoolOwnershipVerificationPayload>
/**
 * Model SchoolVerification
 * 
 */
export type SchoolVerification = $Result.DefaultSelection<Prisma.$SchoolVerificationPayload>
/**
 * Model SchoolPayoutDetail
 * 
 */
export type SchoolPayoutDetail = $Result.DefaultSelection<Prisma.$SchoolPayoutDetailPayload>
/**
 * Model SchoolAndPlatformLegalAgreement
 * 
 */
export type SchoolAndPlatformLegalAgreement = $Result.DefaultSelection<Prisma.$SchoolAndPlatformLegalAgreementPayload>
/**
 * Model KYCVerification
 * 
 */
export type KYCVerification = $Result.DefaultSelection<Prisma.$KYCVerificationPayload>
/**
 * Model Class
 * 
 */
export type Class = $Result.DefaultSelection<Prisma.$ClassPayload>
/**
 * Model AcademicSession
 * 
 */
export type AcademicSession = $Result.DefaultSelection<Prisma.$AcademicSessionPayload>
/**
 * Model Term
 * 
 */
export type Term = $Result.DefaultSelection<Prisma.$TermPayload>
/**
 * Model Fees
 * 
 */
export type Fees = $Result.DefaultSelection<Prisma.$FeesPayload>
/**
 * Model FeeBreakdown
 * 
 */
export type FeeBreakdown = $Result.DefaultSelection<Prisma.$FeeBreakdownPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model LinkedStudentProfile
 * 
 */
export type LinkedStudentProfile = $Result.DefaultSelection<Prisma.$LinkedStudentProfilePayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model TransactionFee
 * 
 */
export type TransactionFee = $Result.DefaultSelection<Prisma.$TransactionFeePayload>
/**
 * Model Payout
 * 
 */
export type Payout = $Result.DefaultSelection<Prisma.$PayoutPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Wallet
 * 
 */
export type Wallet = $Result.DefaultSelection<Prisma.$WalletPayload>
/**
 * Model WalletTransaction
 * 
 */
export type WalletTransaction = $Result.DefaultSelection<Prisma.$WalletTransactionPayload>
/**
 * Model Ledger
 * 
 */
export type Ledger = $Result.DefaultSelection<Prisma.$LedgerPayload>
/**
 * Model FirebaseToken
 * 
 */
export type FirebaseToken = $Result.DefaultSelection<Prisma.$FirebaseTokenPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserType: {
  administrator: 'administrator',
  guardian: 'guardian',
  school: 'school'
};

export type UserType = (typeof UserType)[keyof typeof UserType]


export const AccountStatus: {
  active: 'active',
  inactive: 'inactive',
  suspended: 'suspended',
  blocked: 'blocked',
  deleted: 'deleted'
};

export type AccountStatus = (typeof AccountStatus)[keyof typeof AccountStatus]


export const SchoolStatus: {
  active: 'active',
  inactive: 'inactive'
};

export type SchoolStatus = (typeof SchoolStatus)[keyof typeof SchoolStatus]


export const SchoolType: {
  primary: 'primary',
  secondary: 'secondary'
};

export type SchoolType = (typeof SchoolType)[keyof typeof SchoolType]


export const SchoolOwnership: {
  private: 'private',
  public: 'public',
  missionary: 'missionary'
};

export type SchoolOwnership = (typeof SchoolOwnership)[keyof typeof SchoolOwnership]


export const DirectorIDType: {
  drivers_license: 'drivers_license',
  international_passport: 'international_passport',
  nin: 'nin',
  voters_id: 'voters_id'
};

export type DirectorIDType = (typeof DirectorIDType)[keyof typeof DirectorIDType]


export const InvoiceStatus: {
  pending: 'pending',
  paid: 'paid'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const StudentStatus: {
  active: 'active',
  inactive: 'inactive'
};

export type StudentStatus = (typeof StudentStatus)[keyof typeof StudentStatus]


export const TransactionStatus: {
  pending: 'pending',
  abandoned: 'abandoned',
  failed: 'failed',
  reversed: 'reversed',
  success: 'success'
};

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]


export const PayoutStatus: {
  pending: 'pending',
  sent: 'sent',
  failed: 'failed',
  success: 'success'
};

export type PayoutStatus = (typeof PayoutStatus)[keyof typeof PayoutStatus]


export const NotificationStatus: {
  new: 'new',
  read: 'read'
};

export type NotificationStatus = (typeof NotificationStatus)[keyof typeof NotificationStatus]


export const KYCVerificationStatus: {
  pending: 'pending',
  verified: 'verified',
  rejected: 'rejected'
};

export type KYCVerificationStatus = (typeof KYCVerificationStatus)[keyof typeof KYCVerificationStatus]


export const WalletStatus: {
  Active: 'Active',
  Freezed: 'Freezed',
  Suspended: 'Suspended',
  Blocked: 'Blocked',
  Deleted: 'Deleted'
};

export type WalletStatus = (typeof WalletStatus)[keyof typeof WalletStatus]


export const VerificationType: {
  account_activation: 'account_activation',
  password_reset: 'password_reset',
  pin_code_reset: 'pin_code_reset'
};

export type VerificationType = (typeof VerificationType)[keyof typeof VerificationType]


export const TransactionType: {
  Deposit: 'Deposit',
  Withdrawal: 'Withdrawal',
  Transfer: 'Transfer',
  Refund: 'Refund',
  Reversal: 'Reversal',
  Distribution: 'Distribution'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const TransactionFlow: {
  Inflow: 'Inflow',
  Outflow: 'Outflow'
};

export type TransactionFlow = (typeof TransactionFlow)[keyof typeof TransactionFlow]

}

export type UserType = $Enums.UserType

export const UserType: typeof $Enums.UserType

export type AccountStatus = $Enums.AccountStatus

export const AccountStatus: typeof $Enums.AccountStatus

export type SchoolStatus = $Enums.SchoolStatus

export const SchoolStatus: typeof $Enums.SchoolStatus

export type SchoolType = $Enums.SchoolType

export const SchoolType: typeof $Enums.SchoolType

export type SchoolOwnership = $Enums.SchoolOwnership

export const SchoolOwnership: typeof $Enums.SchoolOwnership

export type DirectorIDType = $Enums.DirectorIDType

export const DirectorIDType: typeof $Enums.DirectorIDType

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type StudentStatus = $Enums.StudentStatus

export const StudentStatus: typeof $Enums.StudentStatus

export type TransactionStatus = $Enums.TransactionStatus

export const TransactionStatus: typeof $Enums.TransactionStatus

export type PayoutStatus = $Enums.PayoutStatus

export const PayoutStatus: typeof $Enums.PayoutStatus

export type NotificationStatus = $Enums.NotificationStatus

export const NotificationStatus: typeof $Enums.NotificationStatus

export type KYCVerificationStatus = $Enums.KYCVerificationStatus

export const KYCVerificationStatus: typeof $Enums.KYCVerificationStatus

export type WalletStatus = $Enums.WalletStatus

export const WalletStatus: typeof $Enums.WalletStatus

export type VerificationType = $Enums.VerificationType

export const VerificationType: typeof $Enums.VerificationType

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type TransactionFlow = $Enums.TransactionFlow

export const TransactionFlow: typeof $Enums.TransactionFlow

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.credential`: Exposes CRUD operations for the **Credential** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Credentials
    * const credentials = await prisma.credential.findMany()
    * ```
    */
  get credential(): Prisma.CredentialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.administrator`: Exposes CRUD operations for the **Administrator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Administrators
    * const administrators = await prisma.administrator.findMany()
    * ```
    */
  get administrator(): Prisma.AdministratorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guardian`: Exposes CRUD operations for the **Guardian** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guardians
    * const guardians = await prisma.guardian.findMany()
    * ```
    */
  get guardian(): Prisma.GuardianDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.school`: Exposes CRUD operations for the **School** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schools
    * const schools = await prisma.school.findMany()
    * ```
    */
  get school(): Prisma.SchoolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schoolDirectorVerification`: Exposes CRUD operations for the **SchoolDirectorVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolDirectorVerifications
    * const schoolDirectorVerifications = await prisma.schoolDirectorVerification.findMany()
    * ```
    */
  get schoolDirectorVerification(): Prisma.SchoolDirectorVerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schoolOwnershipVerification`: Exposes CRUD operations for the **SchoolOwnershipVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolOwnershipVerifications
    * const schoolOwnershipVerifications = await prisma.schoolOwnershipVerification.findMany()
    * ```
    */
  get schoolOwnershipVerification(): Prisma.SchoolOwnershipVerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schoolVerification`: Exposes CRUD operations for the **SchoolVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolVerifications
    * const schoolVerifications = await prisma.schoolVerification.findMany()
    * ```
    */
  get schoolVerification(): Prisma.SchoolVerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schoolPayoutDetail`: Exposes CRUD operations for the **SchoolPayoutDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolPayoutDetails
    * const schoolPayoutDetails = await prisma.schoolPayoutDetail.findMany()
    * ```
    */
  get schoolPayoutDetail(): Prisma.SchoolPayoutDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schoolAndPlatformLegalAgreement`: Exposes CRUD operations for the **SchoolAndPlatformLegalAgreement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolAndPlatformLegalAgreements
    * const schoolAndPlatformLegalAgreements = await prisma.schoolAndPlatformLegalAgreement.findMany()
    * ```
    */
  get schoolAndPlatformLegalAgreement(): Prisma.SchoolAndPlatformLegalAgreementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kYCVerification`: Exposes CRUD operations for the **KYCVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KYCVerifications
    * const kYCVerifications = await prisma.kYCVerification.findMany()
    * ```
    */
  get kYCVerification(): Prisma.KYCVerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.class.findMany()
    * ```
    */
  get class(): Prisma.ClassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.academicSession`: Exposes CRUD operations for the **AcademicSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicSessions
    * const academicSessions = await prisma.academicSession.findMany()
    * ```
    */
  get academicSession(): Prisma.AcademicSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.term`: Exposes CRUD operations for the **Term** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Terms
    * const terms = await prisma.term.findMany()
    * ```
    */
  get term(): Prisma.TermDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fees`: Exposes CRUD operations for the **Fees** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fees
    * const fees = await prisma.fees.findMany()
    * ```
    */
  get fees(): Prisma.FeesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feeBreakdown`: Exposes CRUD operations for the **FeeBreakdown** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeeBreakdowns
    * const feeBreakdowns = await prisma.feeBreakdown.findMany()
    * ```
    */
  get feeBreakdown(): Prisma.FeeBreakdownDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.linkedStudentProfile`: Exposes CRUD operations for the **LinkedStudentProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LinkedStudentProfiles
    * const linkedStudentProfiles = await prisma.linkedStudentProfile.findMany()
    * ```
    */
  get linkedStudentProfile(): Prisma.LinkedStudentProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactionFee`: Exposes CRUD operations for the **TransactionFee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionFees
    * const transactionFees = await prisma.transactionFee.findMany()
    * ```
    */
  get transactionFee(): Prisma.TransactionFeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payout`: Exposes CRUD operations for the **Payout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payouts
    * const payouts = await prisma.payout.findMany()
    * ```
    */
  get payout(): Prisma.PayoutDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wallet`: Exposes CRUD operations for the **Wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallet.findMany()
    * ```
    */
  get wallet(): Prisma.WalletDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.walletTransaction`: Exposes CRUD operations for the **WalletTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WalletTransactions
    * const walletTransactions = await prisma.walletTransaction.findMany()
    * ```
    */
  get walletTransaction(): Prisma.WalletTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ledger`: Exposes CRUD operations for the **Ledger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ledgers
    * const ledgers = await prisma.ledger.findMany()
    * ```
    */
  get ledger(): Prisma.LedgerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.firebaseToken`: Exposes CRUD operations for the **FirebaseToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FirebaseTokens
    * const firebaseTokens = await prisma.firebaseToken.findMany()
    * ```
    */
  get firebaseToken(): Prisma.FirebaseTokenDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.3.0
   * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Credential: 'Credential',
    RefreshToken: 'RefreshToken',
    Administrator: 'Administrator',
    Guardian: 'Guardian',
    Verification: 'Verification',
    School: 'School',
    SchoolDirectorVerification: 'SchoolDirectorVerification',
    SchoolOwnershipVerification: 'SchoolOwnershipVerification',
    SchoolVerification: 'SchoolVerification',
    SchoolPayoutDetail: 'SchoolPayoutDetail',
    SchoolAndPlatformLegalAgreement: 'SchoolAndPlatformLegalAgreement',
    KYCVerification: 'KYCVerification',
    Class: 'Class',
    AcademicSession: 'AcademicSession',
    Term: 'Term',
    Fees: 'Fees',
    FeeBreakdown: 'FeeBreakdown',
    Invoice: 'Invoice',
    Student: 'Student',
    LinkedStudentProfile: 'LinkedStudentProfile',
    Transaction: 'Transaction',
    TransactionFee: 'TransactionFee',
    Payout: 'Payout',
    Notification: 'Notification',
    Wallet: 'Wallet',
    WalletTransaction: 'WalletTransaction',
    Ledger: 'Ledger',
    FirebaseToken: 'FirebaseToken'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "credential" | "refreshToken" | "administrator" | "guardian" | "verification" | "school" | "schoolDirectorVerification" | "schoolOwnershipVerification" | "schoolVerification" | "schoolPayoutDetail" | "schoolAndPlatformLegalAgreement" | "kYCVerification" | "class" | "academicSession" | "term" | "fees" | "feeBreakdown" | "invoice" | "student" | "linkedStudentProfile" | "transaction" | "transactionFee" | "payout" | "notification" | "wallet" | "walletTransaction" | "ledger" | "firebaseToken"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Credential: {
        payload: Prisma.$CredentialPayload<ExtArgs>
        fields: Prisma.CredentialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CredentialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CredentialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          findFirst: {
            args: Prisma.CredentialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CredentialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          findMany: {
            args: Prisma.CredentialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>[]
          }
          create: {
            args: Prisma.CredentialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          createMany: {
            args: Prisma.CredentialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CredentialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>[]
          }
          delete: {
            args: Prisma.CredentialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          update: {
            args: Prisma.CredentialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          deleteMany: {
            args: Prisma.CredentialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CredentialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CredentialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>[]
          }
          upsert: {
            args: Prisma.CredentialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          aggregate: {
            args: Prisma.CredentialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCredential>
          }
          groupBy: {
            args: Prisma.CredentialGroupByArgs<ExtArgs>
            result: $Utils.Optional<CredentialGroupByOutputType>[]
          }
          count: {
            args: Prisma.CredentialCountArgs<ExtArgs>
            result: $Utils.Optional<CredentialCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      Administrator: {
        payload: Prisma.$AdministratorPayload<ExtArgs>
        fields: Prisma.AdministratorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdministratorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministratorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdministratorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministratorPayload>
          }
          findFirst: {
            args: Prisma.AdministratorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministratorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdministratorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministratorPayload>
          }
          findMany: {
            args: Prisma.AdministratorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministratorPayload>[]
          }
          create: {
            args: Prisma.AdministratorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministratorPayload>
          }
          createMany: {
            args: Prisma.AdministratorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdministratorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministratorPayload>[]
          }
          delete: {
            args: Prisma.AdministratorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministratorPayload>
          }
          update: {
            args: Prisma.AdministratorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministratorPayload>
          }
          deleteMany: {
            args: Prisma.AdministratorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdministratorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdministratorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministratorPayload>[]
          }
          upsert: {
            args: Prisma.AdministratorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministratorPayload>
          }
          aggregate: {
            args: Prisma.AdministratorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdministrator>
          }
          groupBy: {
            args: Prisma.AdministratorGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdministratorGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdministratorCountArgs<ExtArgs>
            result: $Utils.Optional<AdministratorCountAggregateOutputType> | number
          }
        }
      }
      Guardian: {
        payload: Prisma.$GuardianPayload<ExtArgs>
        fields: Prisma.GuardianFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuardianFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuardianPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuardianFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuardianPayload>
          }
          findFirst: {
            args: Prisma.GuardianFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuardianPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuardianFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuardianPayload>
          }
          findMany: {
            args: Prisma.GuardianFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuardianPayload>[]
          }
          create: {
            args: Prisma.GuardianCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuardianPayload>
          }
          createMany: {
            args: Prisma.GuardianCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GuardianCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuardianPayload>[]
          }
          delete: {
            args: Prisma.GuardianDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuardianPayload>
          }
          update: {
            args: Prisma.GuardianUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuardianPayload>
          }
          deleteMany: {
            args: Prisma.GuardianDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuardianUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GuardianUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuardianPayload>[]
          }
          upsert: {
            args: Prisma.GuardianUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuardianPayload>
          }
          aggregate: {
            args: Prisma.GuardianAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuardian>
          }
          groupBy: {
            args: Prisma.GuardianGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuardianGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuardianCountArgs<ExtArgs>
            result: $Utils.Optional<GuardianCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      School: {
        payload: Prisma.$SchoolPayload<ExtArgs>
        fields: Prisma.SchoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findFirst: {
            args: Prisma.SchoolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          findMany: {
            args: Prisma.SchoolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          create: {
            args: Prisma.SchoolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          createMany: {
            args: Prisma.SchoolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          delete: {
            args: Prisma.SchoolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          update: {
            args: Prisma.SchoolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          deleteMany: {
            args: Prisma.SchoolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SchoolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>[]
          }
          upsert: {
            args: Prisma.SchoolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayload>
          }
          aggregate: {
            args: Prisma.SchoolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchool>
          }
          groupBy: {
            args: Prisma.SchoolGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolCountAggregateOutputType> | number
          }
        }
      }
      SchoolDirectorVerification: {
        payload: Prisma.$SchoolDirectorVerificationPayload<ExtArgs>
        fields: Prisma.SchoolDirectorVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolDirectorVerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolDirectorVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolDirectorVerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolDirectorVerificationPayload>
          }
          findFirst: {
            args: Prisma.SchoolDirectorVerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolDirectorVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolDirectorVerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolDirectorVerificationPayload>
          }
          findMany: {
            args: Prisma.SchoolDirectorVerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolDirectorVerificationPayload>[]
          }
          create: {
            args: Prisma.SchoolDirectorVerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolDirectorVerificationPayload>
          }
          createMany: {
            args: Prisma.SchoolDirectorVerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolDirectorVerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolDirectorVerificationPayload>[]
          }
          delete: {
            args: Prisma.SchoolDirectorVerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolDirectorVerificationPayload>
          }
          update: {
            args: Prisma.SchoolDirectorVerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolDirectorVerificationPayload>
          }
          deleteMany: {
            args: Prisma.SchoolDirectorVerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolDirectorVerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SchoolDirectorVerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolDirectorVerificationPayload>[]
          }
          upsert: {
            args: Prisma.SchoolDirectorVerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolDirectorVerificationPayload>
          }
          aggregate: {
            args: Prisma.SchoolDirectorVerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchoolDirectorVerification>
          }
          groupBy: {
            args: Prisma.SchoolDirectorVerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolDirectorVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolDirectorVerificationCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolDirectorVerificationCountAggregateOutputType> | number
          }
        }
      }
      SchoolOwnershipVerification: {
        payload: Prisma.$SchoolOwnershipVerificationPayload<ExtArgs>
        fields: Prisma.SchoolOwnershipVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolOwnershipVerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolOwnershipVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolOwnershipVerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolOwnershipVerificationPayload>
          }
          findFirst: {
            args: Prisma.SchoolOwnershipVerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolOwnershipVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolOwnershipVerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolOwnershipVerificationPayload>
          }
          findMany: {
            args: Prisma.SchoolOwnershipVerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolOwnershipVerificationPayload>[]
          }
          create: {
            args: Prisma.SchoolOwnershipVerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolOwnershipVerificationPayload>
          }
          createMany: {
            args: Prisma.SchoolOwnershipVerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolOwnershipVerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolOwnershipVerificationPayload>[]
          }
          delete: {
            args: Prisma.SchoolOwnershipVerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolOwnershipVerificationPayload>
          }
          update: {
            args: Prisma.SchoolOwnershipVerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolOwnershipVerificationPayload>
          }
          deleteMany: {
            args: Prisma.SchoolOwnershipVerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolOwnershipVerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SchoolOwnershipVerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolOwnershipVerificationPayload>[]
          }
          upsert: {
            args: Prisma.SchoolOwnershipVerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolOwnershipVerificationPayload>
          }
          aggregate: {
            args: Prisma.SchoolOwnershipVerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchoolOwnershipVerification>
          }
          groupBy: {
            args: Prisma.SchoolOwnershipVerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolOwnershipVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolOwnershipVerificationCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolOwnershipVerificationCountAggregateOutputType> | number
          }
        }
      }
      SchoolVerification: {
        payload: Prisma.$SchoolVerificationPayload<ExtArgs>
        fields: Prisma.SchoolVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolVerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolVerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolVerificationPayload>
          }
          findFirst: {
            args: Prisma.SchoolVerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolVerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolVerificationPayload>
          }
          findMany: {
            args: Prisma.SchoolVerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolVerificationPayload>[]
          }
          create: {
            args: Prisma.SchoolVerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolVerificationPayload>
          }
          createMany: {
            args: Prisma.SchoolVerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolVerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolVerificationPayload>[]
          }
          delete: {
            args: Prisma.SchoolVerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolVerificationPayload>
          }
          update: {
            args: Prisma.SchoolVerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolVerificationPayload>
          }
          deleteMany: {
            args: Prisma.SchoolVerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolVerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SchoolVerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolVerificationPayload>[]
          }
          upsert: {
            args: Prisma.SchoolVerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolVerificationPayload>
          }
          aggregate: {
            args: Prisma.SchoolVerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchoolVerification>
          }
          groupBy: {
            args: Prisma.SchoolVerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolVerificationCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolVerificationCountAggregateOutputType> | number
          }
        }
      }
      SchoolPayoutDetail: {
        payload: Prisma.$SchoolPayoutDetailPayload<ExtArgs>
        fields: Prisma.SchoolPayoutDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolPayoutDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayoutDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolPayoutDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayoutDetailPayload>
          }
          findFirst: {
            args: Prisma.SchoolPayoutDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayoutDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolPayoutDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayoutDetailPayload>
          }
          findMany: {
            args: Prisma.SchoolPayoutDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayoutDetailPayload>[]
          }
          create: {
            args: Prisma.SchoolPayoutDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayoutDetailPayload>
          }
          createMany: {
            args: Prisma.SchoolPayoutDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolPayoutDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayoutDetailPayload>[]
          }
          delete: {
            args: Prisma.SchoolPayoutDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayoutDetailPayload>
          }
          update: {
            args: Prisma.SchoolPayoutDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayoutDetailPayload>
          }
          deleteMany: {
            args: Prisma.SchoolPayoutDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolPayoutDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SchoolPayoutDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayoutDetailPayload>[]
          }
          upsert: {
            args: Prisma.SchoolPayoutDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolPayoutDetailPayload>
          }
          aggregate: {
            args: Prisma.SchoolPayoutDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchoolPayoutDetail>
          }
          groupBy: {
            args: Prisma.SchoolPayoutDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolPayoutDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolPayoutDetailCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolPayoutDetailCountAggregateOutputType> | number
          }
        }
      }
      SchoolAndPlatformLegalAgreement: {
        payload: Prisma.$SchoolAndPlatformLegalAgreementPayload<ExtArgs>
        fields: Prisma.SchoolAndPlatformLegalAgreementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolAndPlatformLegalAgreementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAndPlatformLegalAgreementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolAndPlatformLegalAgreementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAndPlatformLegalAgreementPayload>
          }
          findFirst: {
            args: Prisma.SchoolAndPlatformLegalAgreementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAndPlatformLegalAgreementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolAndPlatformLegalAgreementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAndPlatformLegalAgreementPayload>
          }
          findMany: {
            args: Prisma.SchoolAndPlatformLegalAgreementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAndPlatformLegalAgreementPayload>[]
          }
          create: {
            args: Prisma.SchoolAndPlatformLegalAgreementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAndPlatformLegalAgreementPayload>
          }
          createMany: {
            args: Prisma.SchoolAndPlatformLegalAgreementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolAndPlatformLegalAgreementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAndPlatformLegalAgreementPayload>[]
          }
          delete: {
            args: Prisma.SchoolAndPlatformLegalAgreementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAndPlatformLegalAgreementPayload>
          }
          update: {
            args: Prisma.SchoolAndPlatformLegalAgreementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAndPlatformLegalAgreementPayload>
          }
          deleteMany: {
            args: Prisma.SchoolAndPlatformLegalAgreementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolAndPlatformLegalAgreementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SchoolAndPlatformLegalAgreementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAndPlatformLegalAgreementPayload>[]
          }
          upsert: {
            args: Prisma.SchoolAndPlatformLegalAgreementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolAndPlatformLegalAgreementPayload>
          }
          aggregate: {
            args: Prisma.SchoolAndPlatformLegalAgreementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchoolAndPlatformLegalAgreement>
          }
          groupBy: {
            args: Prisma.SchoolAndPlatformLegalAgreementGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolAndPlatformLegalAgreementGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolAndPlatformLegalAgreementCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolAndPlatformLegalAgreementCountAggregateOutputType> | number
          }
        }
      }
      KYCVerification: {
        payload: Prisma.$KYCVerificationPayload<ExtArgs>
        fields: Prisma.KYCVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KYCVerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KYCVerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCVerificationPayload>
          }
          findFirst: {
            args: Prisma.KYCVerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KYCVerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCVerificationPayload>
          }
          findMany: {
            args: Prisma.KYCVerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCVerificationPayload>[]
          }
          create: {
            args: Prisma.KYCVerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCVerificationPayload>
          }
          createMany: {
            args: Prisma.KYCVerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KYCVerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCVerificationPayload>[]
          }
          delete: {
            args: Prisma.KYCVerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCVerificationPayload>
          }
          update: {
            args: Prisma.KYCVerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCVerificationPayload>
          }
          deleteMany: {
            args: Prisma.KYCVerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KYCVerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KYCVerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCVerificationPayload>[]
          }
          upsert: {
            args: Prisma.KYCVerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCVerificationPayload>
          }
          aggregate: {
            args: Prisma.KYCVerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKYCVerification>
          }
          groupBy: {
            args: Prisma.KYCVerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<KYCVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.KYCVerificationCountArgs<ExtArgs>
            result: $Utils.Optional<KYCVerificationCountAggregateOutputType> | number
          }
        }
      }
      Class: {
        payload: Prisma.$ClassPayload<ExtArgs>
        fields: Prisma.ClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findFirst: {
            args: Prisma.ClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findMany: {
            args: Prisma.ClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          create: {
            args: Prisma.ClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          createMany: {
            args: Prisma.ClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          delete: {
            args: Prisma.ClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          update: {
            args: Prisma.ClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          deleteMany: {
            args: Prisma.ClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          upsert: {
            args: Prisma.ClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          aggregate: {
            args: Prisma.ClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass>
          }
          groupBy: {
            args: Prisma.ClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassCountArgs<ExtArgs>
            result: $Utils.Optional<ClassCountAggregateOutputType> | number
          }
        }
      }
      AcademicSession: {
        payload: Prisma.$AcademicSessionPayload<ExtArgs>
        fields: Prisma.AcademicSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSessionPayload>
          }
          findFirst: {
            args: Prisma.AcademicSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSessionPayload>
          }
          findMany: {
            args: Prisma.AcademicSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSessionPayload>[]
          }
          create: {
            args: Prisma.AcademicSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSessionPayload>
          }
          createMany: {
            args: Prisma.AcademicSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AcademicSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSessionPayload>[]
          }
          delete: {
            args: Prisma.AcademicSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSessionPayload>
          }
          update: {
            args: Prisma.AcademicSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSessionPayload>
          }
          deleteMany: {
            args: Prisma.AcademicSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AcademicSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSessionPayload>[]
          }
          upsert: {
            args: Prisma.AcademicSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSessionPayload>
          }
          aggregate: {
            args: Prisma.AcademicSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademicSession>
          }
          groupBy: {
            args: Prisma.AcademicSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademicSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicSessionCountArgs<ExtArgs>
            result: $Utils.Optional<AcademicSessionCountAggregateOutputType> | number
          }
        }
      }
      Term: {
        payload: Prisma.$TermPayload<ExtArgs>
        fields: Prisma.TermFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TermFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TermFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermPayload>
          }
          findFirst: {
            args: Prisma.TermFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TermFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermPayload>
          }
          findMany: {
            args: Prisma.TermFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermPayload>[]
          }
          create: {
            args: Prisma.TermCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermPayload>
          }
          createMany: {
            args: Prisma.TermCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TermCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermPayload>[]
          }
          delete: {
            args: Prisma.TermDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermPayload>
          }
          update: {
            args: Prisma.TermUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermPayload>
          }
          deleteMany: {
            args: Prisma.TermDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TermUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TermUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermPayload>[]
          }
          upsert: {
            args: Prisma.TermUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermPayload>
          }
          aggregate: {
            args: Prisma.TermAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTerm>
          }
          groupBy: {
            args: Prisma.TermGroupByArgs<ExtArgs>
            result: $Utils.Optional<TermGroupByOutputType>[]
          }
          count: {
            args: Prisma.TermCountArgs<ExtArgs>
            result: $Utils.Optional<TermCountAggregateOutputType> | number
          }
        }
      }
      Fees: {
        payload: Prisma.$FeesPayload<ExtArgs>
        fields: Prisma.FeesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>
          }
          findFirst: {
            args: Prisma.FeesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>
          }
          findMany: {
            args: Prisma.FeesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>[]
          }
          create: {
            args: Prisma.FeesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>
          }
          createMany: {
            args: Prisma.FeesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>[]
          }
          delete: {
            args: Prisma.FeesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>
          }
          update: {
            args: Prisma.FeesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>
          }
          deleteMany: {
            args: Prisma.FeesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>[]
          }
          upsert: {
            args: Prisma.FeesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeesPayload>
          }
          aggregate: {
            args: Prisma.FeesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFees>
          }
          groupBy: {
            args: Prisma.FeesGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeesGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeesCountArgs<ExtArgs>
            result: $Utils.Optional<FeesCountAggregateOutputType> | number
          }
        }
      }
      FeeBreakdown: {
        payload: Prisma.$FeeBreakdownPayload<ExtArgs>
        fields: Prisma.FeeBreakdownFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeeBreakdownFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeBreakdownPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeeBreakdownFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeBreakdownPayload>
          }
          findFirst: {
            args: Prisma.FeeBreakdownFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeBreakdownPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeeBreakdownFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeBreakdownPayload>
          }
          findMany: {
            args: Prisma.FeeBreakdownFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeBreakdownPayload>[]
          }
          create: {
            args: Prisma.FeeBreakdownCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeBreakdownPayload>
          }
          createMany: {
            args: Prisma.FeeBreakdownCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeeBreakdownCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeBreakdownPayload>[]
          }
          delete: {
            args: Prisma.FeeBreakdownDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeBreakdownPayload>
          }
          update: {
            args: Prisma.FeeBreakdownUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeBreakdownPayload>
          }
          deleteMany: {
            args: Prisma.FeeBreakdownDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeeBreakdownUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeeBreakdownUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeBreakdownPayload>[]
          }
          upsert: {
            args: Prisma.FeeBreakdownUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeBreakdownPayload>
          }
          aggregate: {
            args: Prisma.FeeBreakdownAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeeBreakdown>
          }
          groupBy: {
            args: Prisma.FeeBreakdownGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeeBreakdownGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeeBreakdownCountArgs<ExtArgs>
            result: $Utils.Optional<FeeBreakdownCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      LinkedStudentProfile: {
        payload: Prisma.$LinkedStudentProfilePayload<ExtArgs>
        fields: Prisma.LinkedStudentProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LinkedStudentProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedStudentProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LinkedStudentProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedStudentProfilePayload>
          }
          findFirst: {
            args: Prisma.LinkedStudentProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedStudentProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LinkedStudentProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedStudentProfilePayload>
          }
          findMany: {
            args: Prisma.LinkedStudentProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedStudentProfilePayload>[]
          }
          create: {
            args: Prisma.LinkedStudentProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedStudentProfilePayload>
          }
          createMany: {
            args: Prisma.LinkedStudentProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LinkedStudentProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedStudentProfilePayload>[]
          }
          delete: {
            args: Prisma.LinkedStudentProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedStudentProfilePayload>
          }
          update: {
            args: Prisma.LinkedStudentProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedStudentProfilePayload>
          }
          deleteMany: {
            args: Prisma.LinkedStudentProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LinkedStudentProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LinkedStudentProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedStudentProfilePayload>[]
          }
          upsert: {
            args: Prisma.LinkedStudentProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedStudentProfilePayload>
          }
          aggregate: {
            args: Prisma.LinkedStudentProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLinkedStudentProfile>
          }
          groupBy: {
            args: Prisma.LinkedStudentProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<LinkedStudentProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.LinkedStudentProfileCountArgs<ExtArgs>
            result: $Utils.Optional<LinkedStudentProfileCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      TransactionFee: {
        payload: Prisma.$TransactionFeePayload<ExtArgs>
        fields: Prisma.TransactionFeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFeePayload>
          }
          findFirst: {
            args: Prisma.TransactionFeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFeePayload>
          }
          findMany: {
            args: Prisma.TransactionFeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFeePayload>[]
          }
          create: {
            args: Prisma.TransactionFeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFeePayload>
          }
          createMany: {
            args: Prisma.TransactionFeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionFeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFeePayload>[]
          }
          delete: {
            args: Prisma.TransactionFeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFeePayload>
          }
          update: {
            args: Prisma.TransactionFeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFeePayload>
          }
          deleteMany: {
            args: Prisma.TransactionFeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionFeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionFeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFeePayload>[]
          }
          upsert: {
            args: Prisma.TransactionFeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFeePayload>
          }
          aggregate: {
            args: Prisma.TransactionFeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionFee>
          }
          groupBy: {
            args: Prisma.TransactionFeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionFeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionFeeCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionFeeCountAggregateOutputType> | number
          }
        }
      }
      Payout: {
        payload: Prisma.$PayoutPayload<ExtArgs>
        fields: Prisma.PayoutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayoutFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayoutFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          findFirst: {
            args: Prisma.PayoutFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayoutFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          findMany: {
            args: Prisma.PayoutFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>[]
          }
          create: {
            args: Prisma.PayoutCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          createMany: {
            args: Prisma.PayoutCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayoutCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>[]
          }
          delete: {
            args: Prisma.PayoutDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          update: {
            args: Prisma.PayoutUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          deleteMany: {
            args: Prisma.PayoutDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayoutUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PayoutUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>[]
          }
          upsert: {
            args: Prisma.PayoutUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          aggregate: {
            args: Prisma.PayoutAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayout>
          }
          groupBy: {
            args: Prisma.PayoutGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayoutGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayoutCountArgs<ExtArgs>
            result: $Utils.Optional<PayoutCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Wallet: {
        payload: Prisma.$WalletPayload<ExtArgs>
        fields: Prisma.WalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findFirst: {
            args: Prisma.WalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findMany: {
            args: Prisma.WalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          create: {
            args: Prisma.WalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          createMany: {
            args: Prisma.WalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          delete: {
            args: Prisma.WalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          update: {
            args: Prisma.WalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          deleteMany: {
            args: Prisma.WalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WalletUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          upsert: {
            args: Prisma.WalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          aggregate: {
            args: Prisma.WalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallet>
          }
          groupBy: {
            args: Prisma.WalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletCountArgs<ExtArgs>
            result: $Utils.Optional<WalletCountAggregateOutputType> | number
          }
        }
      }
      WalletTransaction: {
        payload: Prisma.$WalletTransactionPayload<ExtArgs>
        fields: Prisma.WalletTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          findFirst: {
            args: Prisma.WalletTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          findMany: {
            args: Prisma.WalletTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>[]
          }
          create: {
            args: Prisma.WalletTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          createMany: {
            args: Prisma.WalletTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WalletTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>[]
          }
          delete: {
            args: Prisma.WalletTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          update: {
            args: Prisma.WalletTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          deleteMany: {
            args: Prisma.WalletTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WalletTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>[]
          }
          upsert: {
            args: Prisma.WalletTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          aggregate: {
            args: Prisma.WalletTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWalletTransaction>
          }
          groupBy: {
            args: Prisma.WalletTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<WalletTransactionCountAggregateOutputType> | number
          }
        }
      }
      Ledger: {
        payload: Prisma.$LedgerPayload<ExtArgs>
        fields: Prisma.LedgerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LedgerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LedgerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerPayload>
          }
          findFirst: {
            args: Prisma.LedgerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LedgerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerPayload>
          }
          findMany: {
            args: Prisma.LedgerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerPayload>[]
          }
          create: {
            args: Prisma.LedgerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerPayload>
          }
          createMany: {
            args: Prisma.LedgerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LedgerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerPayload>[]
          }
          delete: {
            args: Prisma.LedgerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerPayload>
          }
          update: {
            args: Prisma.LedgerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerPayload>
          }
          deleteMany: {
            args: Prisma.LedgerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LedgerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LedgerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerPayload>[]
          }
          upsert: {
            args: Prisma.LedgerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerPayload>
          }
          aggregate: {
            args: Prisma.LedgerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLedger>
          }
          groupBy: {
            args: Prisma.LedgerGroupByArgs<ExtArgs>
            result: $Utils.Optional<LedgerGroupByOutputType>[]
          }
          count: {
            args: Prisma.LedgerCountArgs<ExtArgs>
            result: $Utils.Optional<LedgerCountAggregateOutputType> | number
          }
        }
      }
      FirebaseToken: {
        payload: Prisma.$FirebaseTokenPayload<ExtArgs>
        fields: Prisma.FirebaseTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FirebaseTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirebaseTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FirebaseTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirebaseTokenPayload>
          }
          findFirst: {
            args: Prisma.FirebaseTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirebaseTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FirebaseTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirebaseTokenPayload>
          }
          findMany: {
            args: Prisma.FirebaseTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirebaseTokenPayload>[]
          }
          create: {
            args: Prisma.FirebaseTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirebaseTokenPayload>
          }
          createMany: {
            args: Prisma.FirebaseTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FirebaseTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirebaseTokenPayload>[]
          }
          delete: {
            args: Prisma.FirebaseTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirebaseTokenPayload>
          }
          update: {
            args: Prisma.FirebaseTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirebaseTokenPayload>
          }
          deleteMany: {
            args: Prisma.FirebaseTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FirebaseTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FirebaseTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirebaseTokenPayload>[]
          }
          upsert: {
            args: Prisma.FirebaseTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FirebaseTokenPayload>
          }
          aggregate: {
            args: Prisma.FirebaseTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFirebaseToken>
          }
          groupBy: {
            args: Prisma.FirebaseTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<FirebaseTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.FirebaseTokenCountArgs<ExtArgs>
            result: $Utils.Optional<FirebaseTokenCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    credential?: CredentialOmit
    refreshToken?: RefreshTokenOmit
    administrator?: AdministratorOmit
    guardian?: GuardianOmit
    verification?: VerificationOmit
    school?: SchoolOmit
    schoolDirectorVerification?: SchoolDirectorVerificationOmit
    schoolOwnershipVerification?: SchoolOwnershipVerificationOmit
    schoolVerification?: SchoolVerificationOmit
    schoolPayoutDetail?: SchoolPayoutDetailOmit
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementOmit
    kYCVerification?: KYCVerificationOmit
    class?: ClassOmit
    academicSession?: AcademicSessionOmit
    term?: TermOmit
    fees?: FeesOmit
    feeBreakdown?: FeeBreakdownOmit
    invoice?: InvoiceOmit
    student?: StudentOmit
    linkedStudentProfile?: LinkedStudentProfileOmit
    transaction?: TransactionOmit
    transactionFee?: TransactionFeeOmit
    payout?: PayoutOmit
    notification?: NotificationOmit
    wallet?: WalletOmit
    walletTransaction?: WalletTransactionOmit
    ledger?: LedgerOmit
    firebaseToken?: FirebaseTokenOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    verifications: number
    notifications: number
    refreshTokens: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verifications?: boolean | UserCountOutputTypeCountVerificationsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVerificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }


  /**
   * Count Type GuardianCountOutputType
   */

  export type GuardianCountOutputType = {
    invoices: number
    students: number
    linkedStudentProfiles: number
    transactions: number
  }

  export type GuardianCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | GuardianCountOutputTypeCountInvoicesArgs
    students?: boolean | GuardianCountOutputTypeCountStudentsArgs
    linkedStudentProfiles?: boolean | GuardianCountOutputTypeCountLinkedStudentProfilesArgs
    transactions?: boolean | GuardianCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * GuardianCountOutputType without action
   */
  export type GuardianCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuardianCountOutputType
     */
    select?: GuardianCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GuardianCountOutputType without action
   */
  export type GuardianCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * GuardianCountOutputType without action
   */
  export type GuardianCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * GuardianCountOutputType without action
   */
  export type GuardianCountOutputTypeCountLinkedStudentProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinkedStudentProfileWhereInput
  }

  /**
   * GuardianCountOutputType without action
   */
  export type GuardianCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type SchoolCountOutputType
   */

  export type SchoolCountOutputType = {
    classes: number
    academicSessions: number
    terms: number
    fees: number
    payouts: number
  }

  export type SchoolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | SchoolCountOutputTypeCountClassesArgs
    academicSessions?: boolean | SchoolCountOutputTypeCountAcademicSessionsArgs
    terms?: boolean | SchoolCountOutputTypeCountTermsArgs
    fees?: boolean | SchoolCountOutputTypeCountFeesArgs
    payouts?: boolean | SchoolCountOutputTypeCountPayoutsArgs
  }

  // Custom InputTypes
  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolCountOutputType
     */
    select?: SchoolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountAcademicSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicSessionWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountTermsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TermWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountFeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeesWhereInput
  }

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountPayoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayoutWhereInput
  }


  /**
   * Count Type ClassCountOutputType
   */

  export type ClassCountOutputType = {
    fees: number
    invoices: number
    students: number
  }

  export type ClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fees?: boolean | ClassCountOutputTypeCountFeesArgs
    invoices?: boolean | ClassCountOutputTypeCountInvoicesArgs
    students?: boolean | ClassCountOutputTypeCountStudentsArgs
  }

  // Custom InputTypes
  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCountOutputType
     */
    select?: ClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountFeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeesWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }


  /**
   * Count Type AcademicSessionCountOutputType
   */

  export type AcademicSessionCountOutputType = {
    fees: number
    invoices: number
  }

  export type AcademicSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fees?: boolean | AcademicSessionCountOutputTypeCountFeesArgs
    invoices?: boolean | AcademicSessionCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * AcademicSessionCountOutputType without action
   */
  export type AcademicSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSessionCountOutputType
     */
    select?: AcademicSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AcademicSessionCountOutputType without action
   */
  export type AcademicSessionCountOutputTypeCountFeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeesWhereInput
  }

  /**
   * AcademicSessionCountOutputType without action
   */
  export type AcademicSessionCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type TermCountOutputType
   */

  export type TermCountOutputType = {
    fees: number
    invoices: number
  }

  export type TermCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fees?: boolean | TermCountOutputTypeCountFeesArgs
    invoices?: boolean | TermCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * TermCountOutputType without action
   */
  export type TermCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermCountOutputType
     */
    select?: TermCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TermCountOutputType without action
   */
  export type TermCountOutputTypeCountFeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeesWhereInput
  }

  /**
   * TermCountOutputType without action
   */
  export type TermCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type FeesCountOutputType
   */

  export type FeesCountOutputType = {
    feeBreakdowns: number
  }

  export type FeesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feeBreakdowns?: boolean | FeesCountOutputTypeCountFeeBreakdownsArgs
  }

  // Custom InputTypes
  /**
   * FeesCountOutputType without action
   */
  export type FeesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeesCountOutputType
     */
    select?: FeesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeesCountOutputType without action
   */
  export type FeesCountOutputTypeCountFeeBreakdownsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeBreakdownWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    transactions: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | InvoiceCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type WalletCountOutputType
   */

  export type WalletCountOutputType = {
    Ledger: number
    Transaction: number
  }

  export type WalletCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Ledger?: boolean | WalletCountOutputTypeCountLedgerArgs
    Transaction?: boolean | WalletCountOutputTypeCountTransactionArgs
  }

  // Custom InputTypes
  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletCountOutputType
     */
    select?: WalletCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeCountLedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerWhereInput
  }

  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletTransactionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    profileImage: string | null
    email: string | null
    type: $Enums.UserType | null
    phone: string | null
    accountStatus: $Enums.AccountStatus | null
    verifiedAt: Date | null
    lastSeenAt: Date | null
    isTermsAccepted: boolean | null
    isPrivacyAccepted: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    profileImage: string | null
    email: string | null
    type: $Enums.UserType | null
    phone: string | null
    accountStatus: $Enums.AccountStatus | null
    verifiedAt: Date | null
    lastSeenAt: Date | null
    isTermsAccepted: boolean | null
    isPrivacyAccepted: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    profileImage: number
    email: number
    type: number
    phone: number
    accountStatus: number
    verifiedAt: number
    lastSeenAt: number
    isTermsAccepted: number
    isPrivacyAccepted: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    profileImage?: true
    email?: true
    type?: true
    phone?: true
    accountStatus?: true
    verifiedAt?: true
    lastSeenAt?: true
    isTermsAccepted?: true
    isPrivacyAccepted?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    profileImage?: true
    email?: true
    type?: true
    phone?: true
    accountStatus?: true
    verifiedAt?: true
    lastSeenAt?: true
    isTermsAccepted?: true
    isPrivacyAccepted?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    profileImage?: true
    email?: true
    type?: true
    phone?: true
    accountStatus?: true
    verifiedAt?: true
    lastSeenAt?: true
    isTermsAccepted?: true
    isPrivacyAccepted?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    profileImage: string | null
    email: string
    type: $Enums.UserType
    phone: string | null
    accountStatus: $Enums.AccountStatus
    verifiedAt: Date | null
    lastSeenAt: Date | null
    isTermsAccepted: boolean
    isPrivacyAccepted: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    profileImage?: boolean
    email?: boolean
    type?: boolean
    phone?: boolean
    accountStatus?: boolean
    verifiedAt?: boolean
    lastSeenAt?: boolean
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    administrator?: boolean | User$administratorArgs<ExtArgs>
    guardian?: boolean | User$guardianArgs<ExtArgs>
    verifications?: boolean | User$verificationsArgs<ExtArgs>
    school?: boolean | User$schoolArgs<ExtArgs>
    schoolAndPlatformLegalAgreement?: boolean | User$schoolAndPlatformLegalAgreementArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    credential?: boolean | User$credentialArgs<ExtArgs>
    wallet?: boolean | User$walletArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    firebaseToken?: boolean | User$firebaseTokenArgs<ExtArgs>
    kycverification?: boolean | User$kycverificationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    profileImage?: boolean
    email?: boolean
    type?: boolean
    phone?: boolean
    accountStatus?: boolean
    verifiedAt?: boolean
    lastSeenAt?: boolean
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    profileImage?: boolean
    email?: boolean
    type?: boolean
    phone?: boolean
    accountStatus?: boolean
    verifiedAt?: boolean
    lastSeenAt?: boolean
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    profileImage?: boolean
    email?: boolean
    type?: boolean
    phone?: boolean
    accountStatus?: boolean
    verifiedAt?: boolean
    lastSeenAt?: boolean
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "profileImage" | "email" | "type" | "phone" | "accountStatus" | "verifiedAt" | "lastSeenAt" | "isTermsAccepted" | "isPrivacyAccepted" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    administrator?: boolean | User$administratorArgs<ExtArgs>
    guardian?: boolean | User$guardianArgs<ExtArgs>
    verifications?: boolean | User$verificationsArgs<ExtArgs>
    school?: boolean | User$schoolArgs<ExtArgs>
    schoolAndPlatformLegalAgreement?: boolean | User$schoolAndPlatformLegalAgreementArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    credential?: boolean | User$credentialArgs<ExtArgs>
    wallet?: boolean | User$walletArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    firebaseToken?: boolean | User$firebaseTokenArgs<ExtArgs>
    kycverification?: boolean | User$kycverificationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      administrator: Prisma.$AdministratorPayload<ExtArgs> | null
      guardian: Prisma.$GuardianPayload<ExtArgs> | null
      verifications: Prisma.$VerificationPayload<ExtArgs>[]
      school: Prisma.$SchoolPayload<ExtArgs> | null
      schoolAndPlatformLegalAgreement: Prisma.$SchoolAndPlatformLegalAgreementPayload<ExtArgs> | null
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      credential: Prisma.$CredentialPayload<ExtArgs> | null
      wallet: Prisma.$WalletPayload<ExtArgs> | null
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      firebaseToken: Prisma.$FirebaseTokenPayload<ExtArgs> | null
      kycverification: Prisma.$KYCVerificationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      profileImage: string | null
      email: string
      type: $Enums.UserType
      phone: string | null
      accountStatus: $Enums.AccountStatus
      verifiedAt: Date | null
      lastSeenAt: Date | null
      isTermsAccepted: boolean
      isPrivacyAccepted: boolean
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    administrator<T extends User$administratorArgs<ExtArgs> = {}>(args?: Subset<T, User$administratorArgs<ExtArgs>>): Prisma__AdministratorClient<$Result.GetResult<Prisma.$AdministratorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    guardian<T extends User$guardianArgs<ExtArgs> = {}>(args?: Subset<T, User$guardianArgs<ExtArgs>>): Prisma__GuardianClient<$Result.GetResult<Prisma.$GuardianPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    verifications<T extends User$verificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$verificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    school<T extends User$schoolArgs<ExtArgs> = {}>(args?: Subset<T, User$schoolArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    schoolAndPlatformLegalAgreement<T extends User$schoolAndPlatformLegalAgreementArgs<ExtArgs> = {}>(args?: Subset<T, User$schoolAndPlatformLegalAgreementArgs<ExtArgs>>): Prisma__SchoolAndPlatformLegalAgreementClient<$Result.GetResult<Prisma.$SchoolAndPlatformLegalAgreementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    credential<T extends User$credentialArgs<ExtArgs> = {}>(args?: Subset<T, User$credentialArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    wallet<T extends User$walletArgs<ExtArgs> = {}>(args?: Subset<T, User$walletArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    firebaseToken<T extends User$firebaseTokenArgs<ExtArgs> = {}>(args?: Subset<T, User$firebaseTokenArgs<ExtArgs>>): Prisma__FirebaseTokenClient<$Result.GetResult<Prisma.$FirebaseTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    kycverification<T extends User$kycverificationArgs<ExtArgs> = {}>(args?: Subset<T, User$kycverificationArgs<ExtArgs>>): Prisma__KYCVerificationClient<$Result.GetResult<Prisma.$KYCVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly profileImage: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly type: FieldRef<"User", 'UserType'>
    readonly phone: FieldRef<"User", 'String'>
    readonly accountStatus: FieldRef<"User", 'AccountStatus'>
    readonly verifiedAt: FieldRef<"User", 'DateTime'>
    readonly lastSeenAt: FieldRef<"User", 'DateTime'>
    readonly isTermsAccepted: FieldRef<"User", 'Boolean'>
    readonly isPrivacyAccepted: FieldRef<"User", 'Boolean'>
    readonly isDeleted: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.administrator
   */
  export type User$administratorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrator
     */
    select?: AdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrator
     */
    omit?: AdministratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministratorInclude<ExtArgs> | null
    where?: AdministratorWhereInput
  }

  /**
   * User.guardian
   */
  export type User$guardianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guardian
     */
    select?: GuardianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guardian
     */
    omit?: GuardianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuardianInclude<ExtArgs> | null
    where?: GuardianWhereInput
  }

  /**
   * User.verifications
   */
  export type User$verificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    cursor?: VerificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * User.school
   */
  export type User$schoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    where?: SchoolWhereInput
  }

  /**
   * User.schoolAndPlatformLegalAgreement
   */
  export type User$schoolAndPlatformLegalAgreementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAndPlatformLegalAgreement
     */
    select?: SchoolAndPlatformLegalAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAndPlatformLegalAgreement
     */
    omit?: SchoolAndPlatformLegalAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAndPlatformLegalAgreementInclude<ExtArgs> | null
    where?: SchoolAndPlatformLegalAgreementWhereInput
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.credential
   */
  export type User$credentialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    where?: CredentialWhereInput
  }

  /**
   * User.wallet
   */
  export type User$walletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    where?: WalletWhereInput
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.firebaseToken
   */
  export type User$firebaseTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirebaseToken
     */
    select?: FirebaseTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirebaseToken
     */
    omit?: FirebaseTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirebaseTokenInclude<ExtArgs> | null
    where?: FirebaseTokenWhereInput
  }

  /**
   * User.kycverification
   */
  export type User$kycverificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCVerification
     */
    select?: KYCVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCVerification
     */
    omit?: KYCVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCVerificationInclude<ExtArgs> | null
    where?: KYCVerificationWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Credential
   */

  export type AggregateCredential = {
    _count: CredentialCountAggregateOutputType | null
    _min: CredentialMinAggregateOutputType | null
    _max: CredentialMaxAggregateOutputType | null
  }

  export type CredentialMinAggregateOutputType = {
    id: string | null
    userId: string | null
    password: string | null
    pinCode: string | null
    lastResetAt: Date | null
    lastUsedAt: Date | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CredentialMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    password: string | null
    pinCode: string | null
    lastResetAt: Date | null
    lastUsedAt: Date | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CredentialCountAggregateOutputType = {
    id: number
    userId: number
    password: number
    pinCode: number
    lastResetAt: number
    lastUsedAt: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CredentialMinAggregateInputType = {
    id?: true
    userId?: true
    password?: true
    pinCode?: true
    lastResetAt?: true
    lastUsedAt?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CredentialMaxAggregateInputType = {
    id?: true
    userId?: true
    password?: true
    pinCode?: true
    lastResetAt?: true
    lastUsedAt?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CredentialCountAggregateInputType = {
    id?: true
    userId?: true
    password?: true
    pinCode?: true
    lastResetAt?: true
    lastUsedAt?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CredentialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Credential to aggregate.
     */
    where?: CredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credentials to fetch.
     */
    orderBy?: CredentialOrderByWithRelationInput | CredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Credentials
    **/
    _count?: true | CredentialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CredentialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CredentialMaxAggregateInputType
  }

  export type GetCredentialAggregateType<T extends CredentialAggregateArgs> = {
        [P in keyof T & keyof AggregateCredential]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCredential[P]>
      : GetScalarType<T[P], AggregateCredential[P]>
  }




  export type CredentialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CredentialWhereInput
    orderBy?: CredentialOrderByWithAggregationInput | CredentialOrderByWithAggregationInput[]
    by: CredentialScalarFieldEnum[] | CredentialScalarFieldEnum
    having?: CredentialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CredentialCountAggregateInputType | true
    _min?: CredentialMinAggregateInputType
    _max?: CredentialMaxAggregateInputType
  }

  export type CredentialGroupByOutputType = {
    id: string
    userId: string
    password: string | null
    pinCode: string | null
    lastResetAt: Date | null
    lastUsedAt: Date | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: CredentialCountAggregateOutputType | null
    _min: CredentialMinAggregateOutputType | null
    _max: CredentialMaxAggregateOutputType | null
  }

  type GetCredentialGroupByPayload<T extends CredentialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CredentialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CredentialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CredentialGroupByOutputType[P]>
            : GetScalarType<T[P], CredentialGroupByOutputType[P]>
        }
      >
    >


  export type CredentialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    password?: boolean
    pinCode?: boolean
    lastResetAt?: boolean
    lastUsedAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["credential"]>

  export type CredentialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    password?: boolean
    pinCode?: boolean
    lastResetAt?: boolean
    lastUsedAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["credential"]>

  export type CredentialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    password?: boolean
    pinCode?: boolean
    lastResetAt?: boolean
    lastUsedAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["credential"]>

  export type CredentialSelectScalar = {
    id?: boolean
    userId?: boolean
    password?: boolean
    pinCode?: boolean
    lastResetAt?: boolean
    lastUsedAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CredentialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "password" | "pinCode" | "lastResetAt" | "lastUsedAt" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["credential"]>
  export type CredentialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CredentialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CredentialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CredentialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Credential"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      password: string | null
      pinCode: string | null
      lastResetAt: Date | null
      lastUsedAt: Date | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["credential"]>
    composites: {}
  }

  type CredentialGetPayload<S extends boolean | null | undefined | CredentialDefaultArgs> = $Result.GetResult<Prisma.$CredentialPayload, S>

  type CredentialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CredentialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CredentialCountAggregateInputType | true
    }

  export interface CredentialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Credential'], meta: { name: 'Credential' } }
    /**
     * Find zero or one Credential that matches the filter.
     * @param {CredentialFindUniqueArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CredentialFindUniqueArgs>(args: SelectSubset<T, CredentialFindUniqueArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Credential that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CredentialFindUniqueOrThrowArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CredentialFindUniqueOrThrowArgs>(args: SelectSubset<T, CredentialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Credential that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialFindFirstArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CredentialFindFirstArgs>(args?: SelectSubset<T, CredentialFindFirstArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Credential that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialFindFirstOrThrowArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CredentialFindFirstOrThrowArgs>(args?: SelectSubset<T, CredentialFindFirstOrThrowArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Credentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Credentials
     * const credentials = await prisma.credential.findMany()
     * 
     * // Get first 10 Credentials
     * const credentials = await prisma.credential.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const credentialWithIdOnly = await prisma.credential.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CredentialFindManyArgs>(args?: SelectSubset<T, CredentialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Credential.
     * @param {CredentialCreateArgs} args - Arguments to create a Credential.
     * @example
     * // Create one Credential
     * const Credential = await prisma.credential.create({
     *   data: {
     *     // ... data to create a Credential
     *   }
     * })
     * 
     */
    create<T extends CredentialCreateArgs>(args: SelectSubset<T, CredentialCreateArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Credentials.
     * @param {CredentialCreateManyArgs} args - Arguments to create many Credentials.
     * @example
     * // Create many Credentials
     * const credential = await prisma.credential.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CredentialCreateManyArgs>(args?: SelectSubset<T, CredentialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Credentials and returns the data saved in the database.
     * @param {CredentialCreateManyAndReturnArgs} args - Arguments to create many Credentials.
     * @example
     * // Create many Credentials
     * const credential = await prisma.credential.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Credentials and only return the `id`
     * const credentialWithIdOnly = await prisma.credential.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CredentialCreateManyAndReturnArgs>(args?: SelectSubset<T, CredentialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Credential.
     * @param {CredentialDeleteArgs} args - Arguments to delete one Credential.
     * @example
     * // Delete one Credential
     * const Credential = await prisma.credential.delete({
     *   where: {
     *     // ... filter to delete one Credential
     *   }
     * })
     * 
     */
    delete<T extends CredentialDeleteArgs>(args: SelectSubset<T, CredentialDeleteArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Credential.
     * @param {CredentialUpdateArgs} args - Arguments to update one Credential.
     * @example
     * // Update one Credential
     * const credential = await prisma.credential.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CredentialUpdateArgs>(args: SelectSubset<T, CredentialUpdateArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Credentials.
     * @param {CredentialDeleteManyArgs} args - Arguments to filter Credentials to delete.
     * @example
     * // Delete a few Credentials
     * const { count } = await prisma.credential.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CredentialDeleteManyArgs>(args?: SelectSubset<T, CredentialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Credentials
     * const credential = await prisma.credential.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CredentialUpdateManyArgs>(args: SelectSubset<T, CredentialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credentials and returns the data updated in the database.
     * @param {CredentialUpdateManyAndReturnArgs} args - Arguments to update many Credentials.
     * @example
     * // Update many Credentials
     * const credential = await prisma.credential.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Credentials and only return the `id`
     * const credentialWithIdOnly = await prisma.credential.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CredentialUpdateManyAndReturnArgs>(args: SelectSubset<T, CredentialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Credential.
     * @param {CredentialUpsertArgs} args - Arguments to update or create a Credential.
     * @example
     * // Update or create a Credential
     * const credential = await prisma.credential.upsert({
     *   create: {
     *     // ... data to create a Credential
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Credential we want to update
     *   }
     * })
     */
    upsert<T extends CredentialUpsertArgs>(args: SelectSubset<T, CredentialUpsertArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Credentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialCountArgs} args - Arguments to filter Credentials to count.
     * @example
     * // Count the number of Credentials
     * const count = await prisma.credential.count({
     *   where: {
     *     // ... the filter for the Credentials we want to count
     *   }
     * })
    **/
    count<T extends CredentialCountArgs>(
      args?: Subset<T, CredentialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CredentialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Credential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CredentialAggregateArgs>(args: Subset<T, CredentialAggregateArgs>): Prisma.PrismaPromise<GetCredentialAggregateType<T>>

    /**
     * Group by Credential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CredentialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CredentialGroupByArgs['orderBy'] }
        : { orderBy?: CredentialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CredentialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCredentialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Credential model
   */
  readonly fields: CredentialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Credential.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CredentialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Credential model
   */
  interface CredentialFieldRefs {
    readonly id: FieldRef<"Credential", 'String'>
    readonly userId: FieldRef<"Credential", 'String'>
    readonly password: FieldRef<"Credential", 'String'>
    readonly pinCode: FieldRef<"Credential", 'String'>
    readonly lastResetAt: FieldRef<"Credential", 'DateTime'>
    readonly lastUsedAt: FieldRef<"Credential", 'DateTime'>
    readonly isDeleted: FieldRef<"Credential", 'Boolean'>
    readonly createdAt: FieldRef<"Credential", 'DateTime'>
    readonly updatedAt: FieldRef<"Credential", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Credential findUnique
   */
  export type CredentialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter, which Credential to fetch.
     */
    where: CredentialWhereUniqueInput
  }

  /**
   * Credential findUniqueOrThrow
   */
  export type CredentialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter, which Credential to fetch.
     */
    where: CredentialWhereUniqueInput
  }

  /**
   * Credential findFirst
   */
  export type CredentialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter, which Credential to fetch.
     */
    where?: CredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credentials to fetch.
     */
    orderBy?: CredentialOrderByWithRelationInput | CredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Credentials.
     */
    cursor?: CredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Credentials.
     */
    distinct?: CredentialScalarFieldEnum | CredentialScalarFieldEnum[]
  }

  /**
   * Credential findFirstOrThrow
   */
  export type CredentialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter, which Credential to fetch.
     */
    where?: CredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credentials to fetch.
     */
    orderBy?: CredentialOrderByWithRelationInput | CredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Credentials.
     */
    cursor?: CredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Credentials.
     */
    distinct?: CredentialScalarFieldEnum | CredentialScalarFieldEnum[]
  }

  /**
   * Credential findMany
   */
  export type CredentialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter, which Credentials to fetch.
     */
    where?: CredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credentials to fetch.
     */
    orderBy?: CredentialOrderByWithRelationInput | CredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Credentials.
     */
    cursor?: CredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credentials.
     */
    skip?: number
    distinct?: CredentialScalarFieldEnum | CredentialScalarFieldEnum[]
  }

  /**
   * Credential create
   */
  export type CredentialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * The data needed to create a Credential.
     */
    data: XOR<CredentialCreateInput, CredentialUncheckedCreateInput>
  }

  /**
   * Credential createMany
   */
  export type CredentialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Credentials.
     */
    data: CredentialCreateManyInput | CredentialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Credential createManyAndReturn
   */
  export type CredentialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * The data used to create many Credentials.
     */
    data: CredentialCreateManyInput | CredentialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Credential update
   */
  export type CredentialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * The data needed to update a Credential.
     */
    data: XOR<CredentialUpdateInput, CredentialUncheckedUpdateInput>
    /**
     * Choose, which Credential to update.
     */
    where: CredentialWhereUniqueInput
  }

  /**
   * Credential updateMany
   */
  export type CredentialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Credentials.
     */
    data: XOR<CredentialUpdateManyMutationInput, CredentialUncheckedUpdateManyInput>
    /**
     * Filter which Credentials to update
     */
    where?: CredentialWhereInput
    /**
     * Limit how many Credentials to update.
     */
    limit?: number
  }

  /**
   * Credential updateManyAndReturn
   */
  export type CredentialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * The data used to update Credentials.
     */
    data: XOR<CredentialUpdateManyMutationInput, CredentialUncheckedUpdateManyInput>
    /**
     * Filter which Credentials to update
     */
    where?: CredentialWhereInput
    /**
     * Limit how many Credentials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Credential upsert
   */
  export type CredentialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * The filter to search for the Credential to update in case it exists.
     */
    where: CredentialWhereUniqueInput
    /**
     * In case the Credential found by the `where` argument doesn't exist, create a new Credential with this data.
     */
    create: XOR<CredentialCreateInput, CredentialUncheckedCreateInput>
    /**
     * In case the Credential was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CredentialUpdateInput, CredentialUncheckedUpdateInput>
  }

  /**
   * Credential delete
   */
  export type CredentialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter which Credential to delete.
     */
    where: CredentialWhereUniqueInput
  }

  /**
   * Credential deleteMany
   */
  export type CredentialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Credentials to delete
     */
    where?: CredentialWhereInput
    /**
     * Limit how many Credentials to delete.
     */
    limit?: number
  }

  /**
   * Credential without action
   */
  export type CredentialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    revoked: boolean | null
    isDeleted: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    revoked: boolean | null
    isDeleted: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    revoked: number
    isDeleted: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    revoked?: true
    isDeleted?: true
    updatedAt?: true
    createdAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    revoked?: true
    isDeleted?: true
    updatedAt?: true
    createdAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    revoked?: true
    isDeleted?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    revoked: boolean
    isDeleted: boolean
    updatedAt: Date
    createdAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    revoked?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    revoked?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    revoked?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    revoked?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "expiresAt" | "revoked" | "isDeleted" | "updatedAt" | "createdAt", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      revoked: boolean
      isDeleted: boolean
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly revoked: FieldRef<"RefreshToken", 'Boolean'>
    readonly isDeleted: FieldRef<"RefreshToken", 'Boolean'>
    readonly updatedAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model Administrator
   */

  export type AggregateAdministrator = {
    _count: AdministratorCountAggregateOutputType | null
    _min: AdministratorMinAggregateOutputType | null
    _max: AdministratorMaxAggregateOutputType | null
  }

  export type AdministratorMinAggregateOutputType = {
    id: string | null
    userId: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdministratorMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdministratorCountAggregateOutputType = {
    id: number
    userId: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdministratorMinAggregateInputType = {
    id?: true
    userId?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdministratorMaxAggregateInputType = {
    id?: true
    userId?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdministratorCountAggregateInputType = {
    id?: true
    userId?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdministratorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Administrator to aggregate.
     */
    where?: AdministratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Administrators to fetch.
     */
    orderBy?: AdministratorOrderByWithRelationInput | AdministratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdministratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Administrators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Administrators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Administrators
    **/
    _count?: true | AdministratorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdministratorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdministratorMaxAggregateInputType
  }

  export type GetAdministratorAggregateType<T extends AdministratorAggregateArgs> = {
        [P in keyof T & keyof AggregateAdministrator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdministrator[P]>
      : GetScalarType<T[P], AggregateAdministrator[P]>
  }




  export type AdministratorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdministratorWhereInput
    orderBy?: AdministratorOrderByWithAggregationInput | AdministratorOrderByWithAggregationInput[]
    by: AdministratorScalarFieldEnum[] | AdministratorScalarFieldEnum
    having?: AdministratorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdministratorCountAggregateInputType | true
    _min?: AdministratorMinAggregateInputType
    _max?: AdministratorMaxAggregateInputType
  }

  export type AdministratorGroupByOutputType = {
    id: string
    userId: string
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: AdministratorCountAggregateOutputType | null
    _min: AdministratorMinAggregateOutputType | null
    _max: AdministratorMaxAggregateOutputType | null
  }

  type GetAdministratorGroupByPayload<T extends AdministratorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdministratorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdministratorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdministratorGroupByOutputType[P]>
            : GetScalarType<T[P], AdministratorGroupByOutputType[P]>
        }
      >
    >


  export type AdministratorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["administrator"]>

  export type AdministratorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["administrator"]>

  export type AdministratorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["administrator"]>

  export type AdministratorSelectScalar = {
    id?: boolean
    userId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdministratorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["administrator"]>
  export type AdministratorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdministratorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdministratorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdministratorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Administrator"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["administrator"]>
    composites: {}
  }

  type AdministratorGetPayload<S extends boolean | null | undefined | AdministratorDefaultArgs> = $Result.GetResult<Prisma.$AdministratorPayload, S>

  type AdministratorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdministratorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdministratorCountAggregateInputType | true
    }

  export interface AdministratorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Administrator'], meta: { name: 'Administrator' } }
    /**
     * Find zero or one Administrator that matches the filter.
     * @param {AdministratorFindUniqueArgs} args - Arguments to find a Administrator
     * @example
     * // Get one Administrator
     * const administrator = await prisma.administrator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdministratorFindUniqueArgs>(args: SelectSubset<T, AdministratorFindUniqueArgs<ExtArgs>>): Prisma__AdministratorClient<$Result.GetResult<Prisma.$AdministratorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Administrator that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdministratorFindUniqueOrThrowArgs} args - Arguments to find a Administrator
     * @example
     * // Get one Administrator
     * const administrator = await prisma.administrator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdministratorFindUniqueOrThrowArgs>(args: SelectSubset<T, AdministratorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdministratorClient<$Result.GetResult<Prisma.$AdministratorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Administrator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministratorFindFirstArgs} args - Arguments to find a Administrator
     * @example
     * // Get one Administrator
     * const administrator = await prisma.administrator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdministratorFindFirstArgs>(args?: SelectSubset<T, AdministratorFindFirstArgs<ExtArgs>>): Prisma__AdministratorClient<$Result.GetResult<Prisma.$AdministratorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Administrator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministratorFindFirstOrThrowArgs} args - Arguments to find a Administrator
     * @example
     * // Get one Administrator
     * const administrator = await prisma.administrator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdministratorFindFirstOrThrowArgs>(args?: SelectSubset<T, AdministratorFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdministratorClient<$Result.GetResult<Prisma.$AdministratorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Administrators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministratorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Administrators
     * const administrators = await prisma.administrator.findMany()
     * 
     * // Get first 10 Administrators
     * const administrators = await prisma.administrator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const administratorWithIdOnly = await prisma.administrator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdministratorFindManyArgs>(args?: SelectSubset<T, AdministratorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdministratorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Administrator.
     * @param {AdministratorCreateArgs} args - Arguments to create a Administrator.
     * @example
     * // Create one Administrator
     * const Administrator = await prisma.administrator.create({
     *   data: {
     *     // ... data to create a Administrator
     *   }
     * })
     * 
     */
    create<T extends AdministratorCreateArgs>(args: SelectSubset<T, AdministratorCreateArgs<ExtArgs>>): Prisma__AdministratorClient<$Result.GetResult<Prisma.$AdministratorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Administrators.
     * @param {AdministratorCreateManyArgs} args - Arguments to create many Administrators.
     * @example
     * // Create many Administrators
     * const administrator = await prisma.administrator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdministratorCreateManyArgs>(args?: SelectSubset<T, AdministratorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Administrators and returns the data saved in the database.
     * @param {AdministratorCreateManyAndReturnArgs} args - Arguments to create many Administrators.
     * @example
     * // Create many Administrators
     * const administrator = await prisma.administrator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Administrators and only return the `id`
     * const administratorWithIdOnly = await prisma.administrator.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdministratorCreateManyAndReturnArgs>(args?: SelectSubset<T, AdministratorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdministratorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Administrator.
     * @param {AdministratorDeleteArgs} args - Arguments to delete one Administrator.
     * @example
     * // Delete one Administrator
     * const Administrator = await prisma.administrator.delete({
     *   where: {
     *     // ... filter to delete one Administrator
     *   }
     * })
     * 
     */
    delete<T extends AdministratorDeleteArgs>(args: SelectSubset<T, AdministratorDeleteArgs<ExtArgs>>): Prisma__AdministratorClient<$Result.GetResult<Prisma.$AdministratorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Administrator.
     * @param {AdministratorUpdateArgs} args - Arguments to update one Administrator.
     * @example
     * // Update one Administrator
     * const administrator = await prisma.administrator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdministratorUpdateArgs>(args: SelectSubset<T, AdministratorUpdateArgs<ExtArgs>>): Prisma__AdministratorClient<$Result.GetResult<Prisma.$AdministratorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Administrators.
     * @param {AdministratorDeleteManyArgs} args - Arguments to filter Administrators to delete.
     * @example
     * // Delete a few Administrators
     * const { count } = await prisma.administrator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdministratorDeleteManyArgs>(args?: SelectSubset<T, AdministratorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Administrators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministratorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Administrators
     * const administrator = await prisma.administrator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdministratorUpdateManyArgs>(args: SelectSubset<T, AdministratorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Administrators and returns the data updated in the database.
     * @param {AdministratorUpdateManyAndReturnArgs} args - Arguments to update many Administrators.
     * @example
     * // Update many Administrators
     * const administrator = await prisma.administrator.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Administrators and only return the `id`
     * const administratorWithIdOnly = await prisma.administrator.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdministratorUpdateManyAndReturnArgs>(args: SelectSubset<T, AdministratorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdministratorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Administrator.
     * @param {AdministratorUpsertArgs} args - Arguments to update or create a Administrator.
     * @example
     * // Update or create a Administrator
     * const administrator = await prisma.administrator.upsert({
     *   create: {
     *     // ... data to create a Administrator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Administrator we want to update
     *   }
     * })
     */
    upsert<T extends AdministratorUpsertArgs>(args: SelectSubset<T, AdministratorUpsertArgs<ExtArgs>>): Prisma__AdministratorClient<$Result.GetResult<Prisma.$AdministratorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Administrators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministratorCountArgs} args - Arguments to filter Administrators to count.
     * @example
     * // Count the number of Administrators
     * const count = await prisma.administrator.count({
     *   where: {
     *     // ... the filter for the Administrators we want to count
     *   }
     * })
    **/
    count<T extends AdministratorCountArgs>(
      args?: Subset<T, AdministratorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdministratorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Administrator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministratorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdministratorAggregateArgs>(args: Subset<T, AdministratorAggregateArgs>): Prisma.PrismaPromise<GetAdministratorAggregateType<T>>

    /**
     * Group by Administrator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministratorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdministratorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdministratorGroupByArgs['orderBy'] }
        : { orderBy?: AdministratorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdministratorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdministratorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Administrator model
   */
  readonly fields: AdministratorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Administrator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdministratorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Administrator model
   */
  interface AdministratorFieldRefs {
    readonly id: FieldRef<"Administrator", 'String'>
    readonly userId: FieldRef<"Administrator", 'String'>
    readonly isDeleted: FieldRef<"Administrator", 'Boolean'>
    readonly createdAt: FieldRef<"Administrator", 'DateTime'>
    readonly updatedAt: FieldRef<"Administrator", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Administrator findUnique
   */
  export type AdministratorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrator
     */
    select?: AdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrator
     */
    omit?: AdministratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministratorInclude<ExtArgs> | null
    /**
     * Filter, which Administrator to fetch.
     */
    where: AdministratorWhereUniqueInput
  }

  /**
   * Administrator findUniqueOrThrow
   */
  export type AdministratorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrator
     */
    select?: AdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrator
     */
    omit?: AdministratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministratorInclude<ExtArgs> | null
    /**
     * Filter, which Administrator to fetch.
     */
    where: AdministratorWhereUniqueInput
  }

  /**
   * Administrator findFirst
   */
  export type AdministratorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrator
     */
    select?: AdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrator
     */
    omit?: AdministratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministratorInclude<ExtArgs> | null
    /**
     * Filter, which Administrator to fetch.
     */
    where?: AdministratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Administrators to fetch.
     */
    orderBy?: AdministratorOrderByWithRelationInput | AdministratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Administrators.
     */
    cursor?: AdministratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Administrators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Administrators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Administrators.
     */
    distinct?: AdministratorScalarFieldEnum | AdministratorScalarFieldEnum[]
  }

  /**
   * Administrator findFirstOrThrow
   */
  export type AdministratorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrator
     */
    select?: AdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrator
     */
    omit?: AdministratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministratorInclude<ExtArgs> | null
    /**
     * Filter, which Administrator to fetch.
     */
    where?: AdministratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Administrators to fetch.
     */
    orderBy?: AdministratorOrderByWithRelationInput | AdministratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Administrators.
     */
    cursor?: AdministratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Administrators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Administrators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Administrators.
     */
    distinct?: AdministratorScalarFieldEnum | AdministratorScalarFieldEnum[]
  }

  /**
   * Administrator findMany
   */
  export type AdministratorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrator
     */
    select?: AdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrator
     */
    omit?: AdministratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministratorInclude<ExtArgs> | null
    /**
     * Filter, which Administrators to fetch.
     */
    where?: AdministratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Administrators to fetch.
     */
    orderBy?: AdministratorOrderByWithRelationInput | AdministratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Administrators.
     */
    cursor?: AdministratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Administrators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Administrators.
     */
    skip?: number
    distinct?: AdministratorScalarFieldEnum | AdministratorScalarFieldEnum[]
  }

  /**
   * Administrator create
   */
  export type AdministratorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrator
     */
    select?: AdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrator
     */
    omit?: AdministratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministratorInclude<ExtArgs> | null
    /**
     * The data needed to create a Administrator.
     */
    data: XOR<AdministratorCreateInput, AdministratorUncheckedCreateInput>
  }

  /**
   * Administrator createMany
   */
  export type AdministratorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Administrators.
     */
    data: AdministratorCreateManyInput | AdministratorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Administrator createManyAndReturn
   */
  export type AdministratorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrator
     */
    select?: AdministratorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Administrator
     */
    omit?: AdministratorOmit<ExtArgs> | null
    /**
     * The data used to create many Administrators.
     */
    data: AdministratorCreateManyInput | AdministratorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministratorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Administrator update
   */
  export type AdministratorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrator
     */
    select?: AdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrator
     */
    omit?: AdministratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministratorInclude<ExtArgs> | null
    /**
     * The data needed to update a Administrator.
     */
    data: XOR<AdministratorUpdateInput, AdministratorUncheckedUpdateInput>
    /**
     * Choose, which Administrator to update.
     */
    where: AdministratorWhereUniqueInput
  }

  /**
   * Administrator updateMany
   */
  export type AdministratorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Administrators.
     */
    data: XOR<AdministratorUpdateManyMutationInput, AdministratorUncheckedUpdateManyInput>
    /**
     * Filter which Administrators to update
     */
    where?: AdministratorWhereInput
    /**
     * Limit how many Administrators to update.
     */
    limit?: number
  }

  /**
   * Administrator updateManyAndReturn
   */
  export type AdministratorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrator
     */
    select?: AdministratorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Administrator
     */
    omit?: AdministratorOmit<ExtArgs> | null
    /**
     * The data used to update Administrators.
     */
    data: XOR<AdministratorUpdateManyMutationInput, AdministratorUncheckedUpdateManyInput>
    /**
     * Filter which Administrators to update
     */
    where?: AdministratorWhereInput
    /**
     * Limit how many Administrators to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministratorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Administrator upsert
   */
  export type AdministratorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrator
     */
    select?: AdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrator
     */
    omit?: AdministratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministratorInclude<ExtArgs> | null
    /**
     * The filter to search for the Administrator to update in case it exists.
     */
    where: AdministratorWhereUniqueInput
    /**
     * In case the Administrator found by the `where` argument doesn't exist, create a new Administrator with this data.
     */
    create: XOR<AdministratorCreateInput, AdministratorUncheckedCreateInput>
    /**
     * In case the Administrator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdministratorUpdateInput, AdministratorUncheckedUpdateInput>
  }

  /**
   * Administrator delete
   */
  export type AdministratorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrator
     */
    select?: AdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrator
     */
    omit?: AdministratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministratorInclude<ExtArgs> | null
    /**
     * Filter which Administrator to delete.
     */
    where: AdministratorWhereUniqueInput
  }

  /**
   * Administrator deleteMany
   */
  export type AdministratorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Administrators to delete
     */
    where?: AdministratorWhereInput
    /**
     * Limit how many Administrators to delete.
     */
    limit?: number
  }

  /**
   * Administrator without action
   */
  export type AdministratorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrator
     */
    select?: AdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrator
     */
    omit?: AdministratorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministratorInclude<ExtArgs> | null
  }


  /**
   * Model Guardian
   */

  export type AggregateGuardian = {
    _count: GuardianCountAggregateOutputType | null
    _min: GuardianMinAggregateOutputType | null
    _max: GuardianMaxAggregateOutputType | null
  }

  export type GuardianMinAggregateOutputType = {
    id: string | null
    userId: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    postalCode: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GuardianMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    postalCode: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GuardianCountAggregateOutputType = {
    id: number
    userId: number
    address: number
    city: number
    state: number
    country: number
    postalCode: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GuardianMinAggregateInputType = {
    id?: true
    userId?: true
    address?: true
    city?: true
    state?: true
    country?: true
    postalCode?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GuardianMaxAggregateInputType = {
    id?: true
    userId?: true
    address?: true
    city?: true
    state?: true
    country?: true
    postalCode?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GuardianCountAggregateInputType = {
    id?: true
    userId?: true
    address?: true
    city?: true
    state?: true
    country?: true
    postalCode?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GuardianAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guardian to aggregate.
     */
    where?: GuardianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guardians to fetch.
     */
    orderBy?: GuardianOrderByWithRelationInput | GuardianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuardianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guardians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guardians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Guardians
    **/
    _count?: true | GuardianCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuardianMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuardianMaxAggregateInputType
  }

  export type GetGuardianAggregateType<T extends GuardianAggregateArgs> = {
        [P in keyof T & keyof AggregateGuardian]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuardian[P]>
      : GetScalarType<T[P], AggregateGuardian[P]>
  }




  export type GuardianGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuardianWhereInput
    orderBy?: GuardianOrderByWithAggregationInput | GuardianOrderByWithAggregationInput[]
    by: GuardianScalarFieldEnum[] | GuardianScalarFieldEnum
    having?: GuardianScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuardianCountAggregateInputType | true
    _min?: GuardianMinAggregateInputType
    _max?: GuardianMaxAggregateInputType
  }

  export type GuardianGroupByOutputType = {
    id: string
    userId: string
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    postalCode: string | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: GuardianCountAggregateOutputType | null
    _min: GuardianMinAggregateOutputType | null
    _max: GuardianMaxAggregateOutputType | null
  }

  type GetGuardianGroupByPayload<T extends GuardianGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuardianGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuardianGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuardianGroupByOutputType[P]>
            : GetScalarType<T[P], GuardianGroupByOutputType[P]>
        }
      >
    >


  export type GuardianSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postalCode?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    invoices?: boolean | Guardian$invoicesArgs<ExtArgs>
    students?: boolean | Guardian$studentsArgs<ExtArgs>
    linkedStudentProfiles?: boolean | Guardian$linkedStudentProfilesArgs<ExtArgs>
    transactions?: boolean | Guardian$transactionsArgs<ExtArgs>
    _count?: boolean | GuardianCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guardian"]>

  export type GuardianSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postalCode?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guardian"]>

  export type GuardianSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postalCode?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guardian"]>

  export type GuardianSelectScalar = {
    id?: boolean
    userId?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postalCode?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GuardianOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "address" | "city" | "state" | "country" | "postalCode" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["guardian"]>
  export type GuardianInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    invoices?: boolean | Guardian$invoicesArgs<ExtArgs>
    students?: boolean | Guardian$studentsArgs<ExtArgs>
    linkedStudentProfiles?: boolean | Guardian$linkedStudentProfilesArgs<ExtArgs>
    transactions?: boolean | Guardian$transactionsArgs<ExtArgs>
    _count?: boolean | GuardianCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GuardianIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GuardianIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GuardianPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Guardian"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs>[]
      linkedStudentProfiles: Prisma.$LinkedStudentProfilePayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      address: string | null
      city: string | null
      state: string | null
      country: string | null
      postalCode: string | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["guardian"]>
    composites: {}
  }

  type GuardianGetPayload<S extends boolean | null | undefined | GuardianDefaultArgs> = $Result.GetResult<Prisma.$GuardianPayload, S>

  type GuardianCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GuardianFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuardianCountAggregateInputType | true
    }

  export interface GuardianDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Guardian'], meta: { name: 'Guardian' } }
    /**
     * Find zero or one Guardian that matches the filter.
     * @param {GuardianFindUniqueArgs} args - Arguments to find a Guardian
     * @example
     * // Get one Guardian
     * const guardian = await prisma.guardian.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuardianFindUniqueArgs>(args: SelectSubset<T, GuardianFindUniqueArgs<ExtArgs>>): Prisma__GuardianClient<$Result.GetResult<Prisma.$GuardianPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Guardian that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GuardianFindUniqueOrThrowArgs} args - Arguments to find a Guardian
     * @example
     * // Get one Guardian
     * const guardian = await prisma.guardian.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuardianFindUniqueOrThrowArgs>(args: SelectSubset<T, GuardianFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuardianClient<$Result.GetResult<Prisma.$GuardianPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Guardian that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuardianFindFirstArgs} args - Arguments to find a Guardian
     * @example
     * // Get one Guardian
     * const guardian = await prisma.guardian.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuardianFindFirstArgs>(args?: SelectSubset<T, GuardianFindFirstArgs<ExtArgs>>): Prisma__GuardianClient<$Result.GetResult<Prisma.$GuardianPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Guardian that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuardianFindFirstOrThrowArgs} args - Arguments to find a Guardian
     * @example
     * // Get one Guardian
     * const guardian = await prisma.guardian.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuardianFindFirstOrThrowArgs>(args?: SelectSubset<T, GuardianFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuardianClient<$Result.GetResult<Prisma.$GuardianPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Guardians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuardianFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guardians
     * const guardians = await prisma.guardian.findMany()
     * 
     * // Get first 10 Guardians
     * const guardians = await prisma.guardian.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guardianWithIdOnly = await prisma.guardian.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuardianFindManyArgs>(args?: SelectSubset<T, GuardianFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuardianPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Guardian.
     * @param {GuardianCreateArgs} args - Arguments to create a Guardian.
     * @example
     * // Create one Guardian
     * const Guardian = await prisma.guardian.create({
     *   data: {
     *     // ... data to create a Guardian
     *   }
     * })
     * 
     */
    create<T extends GuardianCreateArgs>(args: SelectSubset<T, GuardianCreateArgs<ExtArgs>>): Prisma__GuardianClient<$Result.GetResult<Prisma.$GuardianPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Guardians.
     * @param {GuardianCreateManyArgs} args - Arguments to create many Guardians.
     * @example
     * // Create many Guardians
     * const guardian = await prisma.guardian.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuardianCreateManyArgs>(args?: SelectSubset<T, GuardianCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Guardians and returns the data saved in the database.
     * @param {GuardianCreateManyAndReturnArgs} args - Arguments to create many Guardians.
     * @example
     * // Create many Guardians
     * const guardian = await prisma.guardian.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Guardians and only return the `id`
     * const guardianWithIdOnly = await prisma.guardian.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GuardianCreateManyAndReturnArgs>(args?: SelectSubset<T, GuardianCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuardianPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Guardian.
     * @param {GuardianDeleteArgs} args - Arguments to delete one Guardian.
     * @example
     * // Delete one Guardian
     * const Guardian = await prisma.guardian.delete({
     *   where: {
     *     // ... filter to delete one Guardian
     *   }
     * })
     * 
     */
    delete<T extends GuardianDeleteArgs>(args: SelectSubset<T, GuardianDeleteArgs<ExtArgs>>): Prisma__GuardianClient<$Result.GetResult<Prisma.$GuardianPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Guardian.
     * @param {GuardianUpdateArgs} args - Arguments to update one Guardian.
     * @example
     * // Update one Guardian
     * const guardian = await prisma.guardian.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuardianUpdateArgs>(args: SelectSubset<T, GuardianUpdateArgs<ExtArgs>>): Prisma__GuardianClient<$Result.GetResult<Prisma.$GuardianPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Guardians.
     * @param {GuardianDeleteManyArgs} args - Arguments to filter Guardians to delete.
     * @example
     * // Delete a few Guardians
     * const { count } = await prisma.guardian.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuardianDeleteManyArgs>(args?: SelectSubset<T, GuardianDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guardians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuardianUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guardians
     * const guardian = await prisma.guardian.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuardianUpdateManyArgs>(args: SelectSubset<T, GuardianUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guardians and returns the data updated in the database.
     * @param {GuardianUpdateManyAndReturnArgs} args - Arguments to update many Guardians.
     * @example
     * // Update many Guardians
     * const guardian = await prisma.guardian.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Guardians and only return the `id`
     * const guardianWithIdOnly = await prisma.guardian.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GuardianUpdateManyAndReturnArgs>(args: SelectSubset<T, GuardianUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuardianPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Guardian.
     * @param {GuardianUpsertArgs} args - Arguments to update or create a Guardian.
     * @example
     * // Update or create a Guardian
     * const guardian = await prisma.guardian.upsert({
     *   create: {
     *     // ... data to create a Guardian
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guardian we want to update
     *   }
     * })
     */
    upsert<T extends GuardianUpsertArgs>(args: SelectSubset<T, GuardianUpsertArgs<ExtArgs>>): Prisma__GuardianClient<$Result.GetResult<Prisma.$GuardianPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Guardians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuardianCountArgs} args - Arguments to filter Guardians to count.
     * @example
     * // Count the number of Guardians
     * const count = await prisma.guardian.count({
     *   where: {
     *     // ... the filter for the Guardians we want to count
     *   }
     * })
    **/
    count<T extends GuardianCountArgs>(
      args?: Subset<T, GuardianCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuardianCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guardian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuardianAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuardianAggregateArgs>(args: Subset<T, GuardianAggregateArgs>): Prisma.PrismaPromise<GetGuardianAggregateType<T>>

    /**
     * Group by Guardian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuardianGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuardianGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuardianGroupByArgs['orderBy'] }
        : { orderBy?: GuardianGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuardianGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuardianGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Guardian model
   */
  readonly fields: GuardianFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Guardian.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuardianClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoices<T extends Guardian$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Guardian$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    students<T extends Guardian$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Guardian$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    linkedStudentProfiles<T extends Guardian$linkedStudentProfilesArgs<ExtArgs> = {}>(args?: Subset<T, Guardian$linkedStudentProfilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkedStudentProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends Guardian$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Guardian$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Guardian model
   */
  interface GuardianFieldRefs {
    readonly id: FieldRef<"Guardian", 'String'>
    readonly userId: FieldRef<"Guardian", 'String'>
    readonly address: FieldRef<"Guardian", 'String'>
    readonly city: FieldRef<"Guardian", 'String'>
    readonly state: FieldRef<"Guardian", 'String'>
    readonly country: FieldRef<"Guardian", 'String'>
    readonly postalCode: FieldRef<"Guardian", 'String'>
    readonly isDeleted: FieldRef<"Guardian", 'Boolean'>
    readonly createdAt: FieldRef<"Guardian", 'DateTime'>
    readonly updatedAt: FieldRef<"Guardian", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Guardian findUnique
   */
  export type GuardianFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guardian
     */
    select?: GuardianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guardian
     */
    omit?: GuardianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuardianInclude<ExtArgs> | null
    /**
     * Filter, which Guardian to fetch.
     */
    where: GuardianWhereUniqueInput
  }

  /**
   * Guardian findUniqueOrThrow
   */
  export type GuardianFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guardian
     */
    select?: GuardianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guardian
     */
    omit?: GuardianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuardianInclude<ExtArgs> | null
    /**
     * Filter, which Guardian to fetch.
     */
    where: GuardianWhereUniqueInput
  }

  /**
   * Guardian findFirst
   */
  export type GuardianFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guardian
     */
    select?: GuardianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guardian
     */
    omit?: GuardianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuardianInclude<ExtArgs> | null
    /**
     * Filter, which Guardian to fetch.
     */
    where?: GuardianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guardians to fetch.
     */
    orderBy?: GuardianOrderByWithRelationInput | GuardianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guardians.
     */
    cursor?: GuardianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guardians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guardians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guardians.
     */
    distinct?: GuardianScalarFieldEnum | GuardianScalarFieldEnum[]
  }

  /**
   * Guardian findFirstOrThrow
   */
  export type GuardianFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guardian
     */
    select?: GuardianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guardian
     */
    omit?: GuardianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuardianInclude<ExtArgs> | null
    /**
     * Filter, which Guardian to fetch.
     */
    where?: GuardianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guardians to fetch.
     */
    orderBy?: GuardianOrderByWithRelationInput | GuardianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Guardians.
     */
    cursor?: GuardianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guardians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guardians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Guardians.
     */
    distinct?: GuardianScalarFieldEnum | GuardianScalarFieldEnum[]
  }

  /**
   * Guardian findMany
   */
  export type GuardianFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guardian
     */
    select?: GuardianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guardian
     */
    omit?: GuardianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuardianInclude<ExtArgs> | null
    /**
     * Filter, which Guardians to fetch.
     */
    where?: GuardianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Guardians to fetch.
     */
    orderBy?: GuardianOrderByWithRelationInput | GuardianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Guardians.
     */
    cursor?: GuardianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Guardians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Guardians.
     */
    skip?: number
    distinct?: GuardianScalarFieldEnum | GuardianScalarFieldEnum[]
  }

  /**
   * Guardian create
   */
  export type GuardianCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guardian
     */
    select?: GuardianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guardian
     */
    omit?: GuardianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuardianInclude<ExtArgs> | null
    /**
     * The data needed to create a Guardian.
     */
    data: XOR<GuardianCreateInput, GuardianUncheckedCreateInput>
  }

  /**
   * Guardian createMany
   */
  export type GuardianCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Guardians.
     */
    data: GuardianCreateManyInput | GuardianCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Guardian createManyAndReturn
   */
  export type GuardianCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guardian
     */
    select?: GuardianSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Guardian
     */
    omit?: GuardianOmit<ExtArgs> | null
    /**
     * The data used to create many Guardians.
     */
    data: GuardianCreateManyInput | GuardianCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuardianIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Guardian update
   */
  export type GuardianUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guardian
     */
    select?: GuardianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guardian
     */
    omit?: GuardianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuardianInclude<ExtArgs> | null
    /**
     * The data needed to update a Guardian.
     */
    data: XOR<GuardianUpdateInput, GuardianUncheckedUpdateInput>
    /**
     * Choose, which Guardian to update.
     */
    where: GuardianWhereUniqueInput
  }

  /**
   * Guardian updateMany
   */
  export type GuardianUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Guardians.
     */
    data: XOR<GuardianUpdateManyMutationInput, GuardianUncheckedUpdateManyInput>
    /**
     * Filter which Guardians to update
     */
    where?: GuardianWhereInput
    /**
     * Limit how many Guardians to update.
     */
    limit?: number
  }

  /**
   * Guardian updateManyAndReturn
   */
  export type GuardianUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guardian
     */
    select?: GuardianSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Guardian
     */
    omit?: GuardianOmit<ExtArgs> | null
    /**
     * The data used to update Guardians.
     */
    data: XOR<GuardianUpdateManyMutationInput, GuardianUncheckedUpdateManyInput>
    /**
     * Filter which Guardians to update
     */
    where?: GuardianWhereInput
    /**
     * Limit how many Guardians to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuardianIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Guardian upsert
   */
  export type GuardianUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guardian
     */
    select?: GuardianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guardian
     */
    omit?: GuardianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuardianInclude<ExtArgs> | null
    /**
     * The filter to search for the Guardian to update in case it exists.
     */
    where: GuardianWhereUniqueInput
    /**
     * In case the Guardian found by the `where` argument doesn't exist, create a new Guardian with this data.
     */
    create: XOR<GuardianCreateInput, GuardianUncheckedCreateInput>
    /**
     * In case the Guardian was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuardianUpdateInput, GuardianUncheckedUpdateInput>
  }

  /**
   * Guardian delete
   */
  export type GuardianDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guardian
     */
    select?: GuardianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guardian
     */
    omit?: GuardianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuardianInclude<ExtArgs> | null
    /**
     * Filter which Guardian to delete.
     */
    where: GuardianWhereUniqueInput
  }

  /**
   * Guardian deleteMany
   */
  export type GuardianDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Guardians to delete
     */
    where?: GuardianWhereInput
    /**
     * Limit how many Guardians to delete.
     */
    limit?: number
  }

  /**
   * Guardian.invoices
   */
  export type Guardian$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Guardian.students
   */
  export type Guardian$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Guardian.linkedStudentProfiles
   */
  export type Guardian$linkedStudentProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedStudentProfile
     */
    select?: LinkedStudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedStudentProfile
     */
    omit?: LinkedStudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedStudentProfileInclude<ExtArgs> | null
    where?: LinkedStudentProfileWhereInput
    orderBy?: LinkedStudentProfileOrderByWithRelationInput | LinkedStudentProfileOrderByWithRelationInput[]
    cursor?: LinkedStudentProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LinkedStudentProfileScalarFieldEnum | LinkedStudentProfileScalarFieldEnum[]
  }

  /**
   * Guardian.transactions
   */
  export type Guardian$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Guardian without action
   */
  export type GuardianDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guardian
     */
    select?: GuardianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guardian
     */
    omit?: GuardianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuardianInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _avg: VerificationAvgAggregateOutputType | null
    _sum: VerificationSumAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationAvgAggregateOutputType = {
    resendCount: number | null
  }

  export type VerificationSumAggregateOutputType = {
    resendCount: number | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.VerificationType | null
    code: string | null
    expiresAt: Date | null
    resendCount: number | null
    used: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.VerificationType | null
    code: string | null
    expiresAt: Date | null
    resendCount: number | null
    used: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    code: number
    expiresAt: number
    resendCount: number
    used: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationAvgAggregateInputType = {
    resendCount?: true
  }

  export type VerificationSumAggregateInputType = {
    resendCount?: true
  }

  export type VerificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    code?: true
    expiresAt?: true
    resendCount?: true
    used?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    code?: true
    expiresAt?: true
    resendCount?: true
    used?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    code?: true
    expiresAt?: true
    resendCount?: true
    used?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VerificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VerificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _avg?: VerificationAvgAggregateInputType
    _sum?: VerificationSumAggregateInputType
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.VerificationType
    code: string
    expiresAt: Date
    resendCount: number
    used: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: VerificationCountAggregateOutputType | null
    _avg: VerificationAvgAggregateOutputType | null
    _sum: VerificationSumAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    code?: boolean
    expiresAt?: boolean
    resendCount?: boolean
    used?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    code?: boolean
    expiresAt?: boolean
    resendCount?: boolean
    used?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    code?: boolean
    expiresAt?: boolean
    resendCount?: boolean
    used?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    code?: boolean
    expiresAt?: boolean
    resendCount?: boolean
    used?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "code" | "expiresAt" | "resendCount" | "used" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>
  export type VerificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VerificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VerificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.VerificationType
      code: string
      expiresAt: Date
      resendCount: number
      used: boolean
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly userId: FieldRef<"Verification", 'String'>
    readonly type: FieldRef<"Verification", 'VerificationType'>
    readonly code: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly resendCount: FieldRef<"Verification", 'Int'>
    readonly used: FieldRef<"Verification", 'Boolean'>
    readonly isDeleted: FieldRef<"Verification", 'Boolean'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationInclude<ExtArgs> | null
  }


  /**
   * Model School
   */

  export type AggregateSchool = {
    _count: SchoolCountAggregateOutputType | null
    _avg: SchoolAvgAggregateOutputType | null
    _sum: SchoolSumAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  export type SchoolAvgAggregateOutputType = {
    establishedYear: number | null
  }

  export type SchoolSumAggregateOutputType = {
    establishedYear: number | null
  }

  export type SchoolMinAggregateOutputType = {
    id: string | null
    ownerId: string | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    lga: string | null
    postalCode: string | null
    email: string | null
    phoneNumber: string | null
    establishedYear: number | null
    website: string | null
    logo: string | null
    schoolType: $Enums.SchoolType | null
    ownership: $Enums.SchoolOwnership | null
    status: $Enums.SchoolStatus | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolMaxAggregateOutputType = {
    id: string | null
    ownerId: string | null
    name: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    lga: string | null
    postalCode: string | null
    email: string | null
    phoneNumber: string | null
    establishedYear: number | null
    website: string | null
    logo: string | null
    schoolType: $Enums.SchoolType | null
    ownership: $Enums.SchoolOwnership | null
    status: $Enums.SchoolStatus | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolCountAggregateOutputType = {
    id: number
    ownerId: number
    name: number
    address: number
    city: number
    state: number
    country: number
    lga: number
    postalCode: number
    email: number
    phoneNumber: number
    establishedYear: number
    website: number
    logo: number
    schoolType: number
    ownership: number
    status: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolAvgAggregateInputType = {
    establishedYear?: true
  }

  export type SchoolSumAggregateInputType = {
    establishedYear?: true
  }

  export type SchoolMinAggregateInputType = {
    id?: true
    ownerId?: true
    name?: true
    address?: true
    city?: true
    state?: true
    country?: true
    lga?: true
    postalCode?: true
    email?: true
    phoneNumber?: true
    establishedYear?: true
    website?: true
    logo?: true
    schoolType?: true
    ownership?: true
    status?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolMaxAggregateInputType = {
    id?: true
    ownerId?: true
    name?: true
    address?: true
    city?: true
    state?: true
    country?: true
    lga?: true
    postalCode?: true
    email?: true
    phoneNumber?: true
    establishedYear?: true
    website?: true
    logo?: true
    schoolType?: true
    ownership?: true
    status?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolCountAggregateInputType = {
    id?: true
    ownerId?: true
    name?: true
    address?: true
    city?: true
    state?: true
    country?: true
    lga?: true
    postalCode?: true
    email?: true
    phoneNumber?: true
    establishedYear?: true
    website?: true
    logo?: true
    schoolType?: true
    ownership?: true
    status?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which School to aggregate.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schools
    **/
    _count?: true | SchoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SchoolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SchoolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolMaxAggregateInputType
  }

  export type GetSchoolAggregateType<T extends SchoolAggregateArgs> = {
        [P in keyof T & keyof AggregateSchool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchool[P]>
      : GetScalarType<T[P], AggregateSchool[P]>
  }




  export type SchoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
    orderBy?: SchoolOrderByWithAggregationInput | SchoolOrderByWithAggregationInput[]
    by: SchoolScalarFieldEnum[] | SchoolScalarFieldEnum
    having?: SchoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolCountAggregateInputType | true
    _avg?: SchoolAvgAggregateInputType
    _sum?: SchoolSumAggregateInputType
    _min?: SchoolMinAggregateInputType
    _max?: SchoolMaxAggregateInputType
  }

  export type SchoolGroupByOutputType = {
    id: string
    ownerId: string
    name: string
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    lga: string | null
    postalCode: string | null
    email: string
    phoneNumber: string | null
    establishedYear: number | null
    website: string | null
    logo: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status: $Enums.SchoolStatus
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: SchoolCountAggregateOutputType | null
    _avg: SchoolAvgAggregateOutputType | null
    _sum: SchoolSumAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  type GetSchoolGroupByPayload<T extends SchoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolGroupByOutputType[P]>
        }
      >
    >


  export type SchoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    lga?: boolean
    postalCode?: boolean
    email?: boolean
    phoneNumber?: boolean
    establishedYear?: boolean
    website?: boolean
    logo?: boolean
    schoolType?: boolean
    ownership?: boolean
    status?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    schoolDirectorVerification?: boolean | School$schoolDirectorVerificationArgs<ExtArgs>
    schoolOwnershipVerification?: boolean | School$schoolOwnershipVerificationArgs<ExtArgs>
    schoolVerification?: boolean | School$schoolVerificationArgs<ExtArgs>
    schoolPayoutDetail?: boolean | School$schoolPayoutDetailArgs<ExtArgs>
    schoolAndPlatformLegalAgreement?: boolean | School$schoolAndPlatformLegalAgreementArgs<ExtArgs>
    classes?: boolean | School$classesArgs<ExtArgs>
    academicSessions?: boolean | School$academicSessionsArgs<ExtArgs>
    terms?: boolean | School$termsArgs<ExtArgs>
    fees?: boolean | School$feesArgs<ExtArgs>
    payouts?: boolean | School$payoutsArgs<ExtArgs>
    kycverification?: boolean | School$kycverificationArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    lga?: boolean
    postalCode?: boolean
    email?: boolean
    phoneNumber?: boolean
    establishedYear?: boolean
    website?: boolean
    logo?: boolean
    schoolType?: boolean
    ownership?: boolean
    status?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    lga?: boolean
    postalCode?: boolean
    email?: boolean
    phoneNumber?: boolean
    establishedYear?: boolean
    website?: boolean
    logo?: boolean
    schoolType?: boolean
    ownership?: boolean
    status?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectScalar = {
    id?: boolean
    ownerId?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    lga?: boolean
    postalCode?: boolean
    email?: boolean
    phoneNumber?: boolean
    establishedYear?: boolean
    website?: boolean
    logo?: boolean
    schoolType?: boolean
    ownership?: boolean
    status?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ownerId" | "name" | "address" | "city" | "state" | "country" | "lga" | "postalCode" | "email" | "phoneNumber" | "establishedYear" | "website" | "logo" | "schoolType" | "ownership" | "status" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["school"]>
  export type SchoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    schoolDirectorVerification?: boolean | School$schoolDirectorVerificationArgs<ExtArgs>
    schoolOwnershipVerification?: boolean | School$schoolOwnershipVerificationArgs<ExtArgs>
    schoolVerification?: boolean | School$schoolVerificationArgs<ExtArgs>
    schoolPayoutDetail?: boolean | School$schoolPayoutDetailArgs<ExtArgs>
    schoolAndPlatformLegalAgreement?: boolean | School$schoolAndPlatformLegalAgreementArgs<ExtArgs>
    classes?: boolean | School$classesArgs<ExtArgs>
    academicSessions?: boolean | School$academicSessionsArgs<ExtArgs>
    terms?: boolean | School$termsArgs<ExtArgs>
    fees?: boolean | School$feesArgs<ExtArgs>
    payouts?: boolean | School$payoutsArgs<ExtArgs>
    kycverification?: boolean | School$kycverificationArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SchoolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SchoolIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SchoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "School"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      schoolDirectorVerification: Prisma.$SchoolDirectorVerificationPayload<ExtArgs> | null
      schoolOwnershipVerification: Prisma.$SchoolOwnershipVerificationPayload<ExtArgs> | null
      schoolVerification: Prisma.$SchoolVerificationPayload<ExtArgs> | null
      schoolPayoutDetail: Prisma.$SchoolPayoutDetailPayload<ExtArgs> | null
      schoolAndPlatformLegalAgreement: Prisma.$SchoolAndPlatformLegalAgreementPayload<ExtArgs> | null
      classes: Prisma.$ClassPayload<ExtArgs>[]
      academicSessions: Prisma.$AcademicSessionPayload<ExtArgs>[]
      terms: Prisma.$TermPayload<ExtArgs>[]
      fees: Prisma.$FeesPayload<ExtArgs>[]
      payouts: Prisma.$PayoutPayload<ExtArgs>[]
      kycverification: Prisma.$KYCVerificationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ownerId: string
      name: string
      address: string | null
      city: string | null
      state: string | null
      country: string | null
      lga: string | null
      postalCode: string | null
      email: string
      phoneNumber: string | null
      establishedYear: number | null
      website: string | null
      logo: string | null
      schoolType: $Enums.SchoolType
      ownership: $Enums.SchoolOwnership
      status: $Enums.SchoolStatus
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["school"]>
    composites: {}
  }

  type SchoolGetPayload<S extends boolean | null | undefined | SchoolDefaultArgs> = $Result.GetResult<Prisma.$SchoolPayload, S>

  type SchoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SchoolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SchoolCountAggregateInputType | true
    }

  export interface SchoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['School'], meta: { name: 'School' } }
    /**
     * Find zero or one School that matches the filter.
     * @param {SchoolFindUniqueArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolFindUniqueArgs>(args: SelectSubset<T, SchoolFindUniqueArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one School that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SchoolFindUniqueOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first School that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolFindFirstArgs>(args?: SelectSubset<T, SchoolFindFirstArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first School that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schools
     * const schools = await prisma.school.findMany()
     * 
     * // Get first 10 Schools
     * const schools = await prisma.school.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolWithIdOnly = await prisma.school.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolFindManyArgs>(args?: SelectSubset<T, SchoolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a School.
     * @param {SchoolCreateArgs} args - Arguments to create a School.
     * @example
     * // Create one School
     * const School = await prisma.school.create({
     *   data: {
     *     // ... data to create a School
     *   }
     * })
     * 
     */
    create<T extends SchoolCreateArgs>(args: SelectSubset<T, SchoolCreateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schools.
     * @param {SchoolCreateManyArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolCreateManyArgs>(args?: SelectSubset<T, SchoolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schools and returns the data saved in the database.
     * @param {SchoolCreateManyAndReturnArgs} args - Arguments to create many Schools.
     * @example
     * // Create many Schools
     * const school = await prisma.school.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schools and only return the `id`
     * const schoolWithIdOnly = await prisma.school.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a School.
     * @param {SchoolDeleteArgs} args - Arguments to delete one School.
     * @example
     * // Delete one School
     * const School = await prisma.school.delete({
     *   where: {
     *     // ... filter to delete one School
     *   }
     * })
     * 
     */
    delete<T extends SchoolDeleteArgs>(args: SelectSubset<T, SchoolDeleteArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one School.
     * @param {SchoolUpdateArgs} args - Arguments to update one School.
     * @example
     * // Update one School
     * const school = await prisma.school.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolUpdateArgs>(args: SelectSubset<T, SchoolUpdateArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schools.
     * @param {SchoolDeleteManyArgs} args - Arguments to filter Schools to delete.
     * @example
     * // Delete a few Schools
     * const { count } = await prisma.school.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolDeleteManyArgs>(args?: SelectSubset<T, SchoolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolUpdateManyArgs>(args: SelectSubset<T, SchoolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools and returns the data updated in the database.
     * @param {SchoolUpdateManyAndReturnArgs} args - Arguments to update many Schools.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Schools and only return the `id`
     * const schoolWithIdOnly = await prisma.school.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SchoolUpdateManyAndReturnArgs>(args: SelectSubset<T, SchoolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one School.
     * @param {SchoolUpsertArgs} args - Arguments to update or create a School.
     * @example
     * // Update or create a School
     * const school = await prisma.school.upsert({
     *   create: {
     *     // ... data to create a School
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the School we want to update
     *   }
     * })
     */
    upsert<T extends SchoolUpsertArgs>(args: SelectSubset<T, SchoolUpsertArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolCountArgs} args - Arguments to filter Schools to count.
     * @example
     * // Count the number of Schools
     * const count = await prisma.school.count({
     *   where: {
     *     // ... the filter for the Schools we want to count
     *   }
     * })
    **/
    count<T extends SchoolCountArgs>(
      args?: Subset<T, SchoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolAggregateArgs>(args: Subset<T, SchoolAggregateArgs>): Prisma.PrismaPromise<GetSchoolAggregateType<T>>

    /**
     * Group by School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolGroupByArgs['orderBy'] }
        : { orderBy?: SchoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the School model
   */
  readonly fields: SchoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for School.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    schoolDirectorVerification<T extends School$schoolDirectorVerificationArgs<ExtArgs> = {}>(args?: Subset<T, School$schoolDirectorVerificationArgs<ExtArgs>>): Prisma__SchoolDirectorVerificationClient<$Result.GetResult<Prisma.$SchoolDirectorVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    schoolOwnershipVerification<T extends School$schoolOwnershipVerificationArgs<ExtArgs> = {}>(args?: Subset<T, School$schoolOwnershipVerificationArgs<ExtArgs>>): Prisma__SchoolOwnershipVerificationClient<$Result.GetResult<Prisma.$SchoolOwnershipVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    schoolVerification<T extends School$schoolVerificationArgs<ExtArgs> = {}>(args?: Subset<T, School$schoolVerificationArgs<ExtArgs>>): Prisma__SchoolVerificationClient<$Result.GetResult<Prisma.$SchoolVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    schoolPayoutDetail<T extends School$schoolPayoutDetailArgs<ExtArgs> = {}>(args?: Subset<T, School$schoolPayoutDetailArgs<ExtArgs>>): Prisma__SchoolPayoutDetailClient<$Result.GetResult<Prisma.$SchoolPayoutDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    schoolAndPlatformLegalAgreement<T extends School$schoolAndPlatformLegalAgreementArgs<ExtArgs> = {}>(args?: Subset<T, School$schoolAndPlatformLegalAgreementArgs<ExtArgs>>): Prisma__SchoolAndPlatformLegalAgreementClient<$Result.GetResult<Prisma.$SchoolAndPlatformLegalAgreementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    classes<T extends School$classesArgs<ExtArgs> = {}>(args?: Subset<T, School$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    academicSessions<T extends School$academicSessionsArgs<ExtArgs> = {}>(args?: Subset<T, School$academicSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    terms<T extends School$termsArgs<ExtArgs> = {}>(args?: Subset<T, School$termsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fees<T extends School$feesArgs<ExtArgs> = {}>(args?: Subset<T, School$feesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payouts<T extends School$payoutsArgs<ExtArgs> = {}>(args?: Subset<T, School$payoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kycverification<T extends School$kycverificationArgs<ExtArgs> = {}>(args?: Subset<T, School$kycverificationArgs<ExtArgs>>): Prisma__KYCVerificationClient<$Result.GetResult<Prisma.$KYCVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the School model
   */
  interface SchoolFieldRefs {
    readonly id: FieldRef<"School", 'String'>
    readonly ownerId: FieldRef<"School", 'String'>
    readonly name: FieldRef<"School", 'String'>
    readonly address: FieldRef<"School", 'String'>
    readonly city: FieldRef<"School", 'String'>
    readonly state: FieldRef<"School", 'String'>
    readonly country: FieldRef<"School", 'String'>
    readonly lga: FieldRef<"School", 'String'>
    readonly postalCode: FieldRef<"School", 'String'>
    readonly email: FieldRef<"School", 'String'>
    readonly phoneNumber: FieldRef<"School", 'String'>
    readonly establishedYear: FieldRef<"School", 'Int'>
    readonly website: FieldRef<"School", 'String'>
    readonly logo: FieldRef<"School", 'String'>
    readonly schoolType: FieldRef<"School", 'SchoolType'>
    readonly ownership: FieldRef<"School", 'SchoolOwnership'>
    readonly status: FieldRef<"School", 'SchoolStatus'>
    readonly isDeleted: FieldRef<"School", 'Boolean'>
    readonly createdAt: FieldRef<"School", 'DateTime'>
    readonly updatedAt: FieldRef<"School", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * School findUnique
   */
  export type SchoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findUniqueOrThrow
   */
  export type SchoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findFirst
   */
  export type SchoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findFirstOrThrow
   */
  export type SchoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School findMany
   */
  export type SchoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which Schools to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: SchoolOrderByWithRelationInput | SchoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }

  /**
   * School create
   */
  export type SchoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to create a School.
     */
    data: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
  }

  /**
   * School createMany
   */
  export type SchoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * School createManyAndReturn
   */
  export type SchoolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * The data used to create many Schools.
     */
    data: SchoolCreateManyInput | SchoolCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * School update
   */
  export type SchoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to update a School.
     */
    data: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
    /**
     * Choose, which School to update.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School updateMany
   */
  export type SchoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to update.
     */
    limit?: number
  }

  /**
   * School updateManyAndReturn
   */
  export type SchoolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * School upsert
   */
  export type SchoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The filter to search for the School to update in case it exists.
     */
    where: SchoolWhereUniqueInput
    /**
     * In case the School found by the `where` argument doesn't exist, create a new School with this data.
     */
    create: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
    /**
     * In case the School was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
  }

  /**
   * School delete
   */
  export type SchoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter which School to delete.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School deleteMany
   */
  export type SchoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schools to delete
     */
    where?: SchoolWhereInput
    /**
     * Limit how many Schools to delete.
     */
    limit?: number
  }

  /**
   * School.schoolDirectorVerification
   */
  export type School$schoolDirectorVerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolDirectorVerification
     */
    select?: SchoolDirectorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolDirectorVerification
     */
    omit?: SchoolDirectorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolDirectorVerificationInclude<ExtArgs> | null
    where?: SchoolDirectorVerificationWhereInput
  }

  /**
   * School.schoolOwnershipVerification
   */
  export type School$schoolOwnershipVerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolOwnershipVerification
     */
    select?: SchoolOwnershipVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolOwnershipVerification
     */
    omit?: SchoolOwnershipVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolOwnershipVerificationInclude<ExtArgs> | null
    where?: SchoolOwnershipVerificationWhereInput
  }

  /**
   * School.schoolVerification
   */
  export type School$schoolVerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolVerification
     */
    select?: SchoolVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolVerification
     */
    omit?: SchoolVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolVerificationInclude<ExtArgs> | null
    where?: SchoolVerificationWhereInput
  }

  /**
   * School.schoolPayoutDetail
   */
  export type School$schoolPayoutDetailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolPayoutDetail
     */
    select?: SchoolPayoutDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolPayoutDetail
     */
    omit?: SchoolPayoutDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolPayoutDetailInclude<ExtArgs> | null
    where?: SchoolPayoutDetailWhereInput
  }

  /**
   * School.schoolAndPlatformLegalAgreement
   */
  export type School$schoolAndPlatformLegalAgreementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAndPlatformLegalAgreement
     */
    select?: SchoolAndPlatformLegalAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAndPlatformLegalAgreement
     */
    omit?: SchoolAndPlatformLegalAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAndPlatformLegalAgreementInclude<ExtArgs> | null
    where?: SchoolAndPlatformLegalAgreementWhereInput
  }

  /**
   * School.classes
   */
  export type School$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * School.academicSessions
   */
  export type School$academicSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSession
     */
    select?: AcademicSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSession
     */
    omit?: AcademicSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSessionInclude<ExtArgs> | null
    where?: AcademicSessionWhereInput
    orderBy?: AcademicSessionOrderByWithRelationInput | AcademicSessionOrderByWithRelationInput[]
    cursor?: AcademicSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcademicSessionScalarFieldEnum | AcademicSessionScalarFieldEnum[]
  }

  /**
   * School.terms
   */
  export type School$termsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null
    where?: TermWhereInput
    orderBy?: TermOrderByWithRelationInput | TermOrderByWithRelationInput[]
    cursor?: TermWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TermScalarFieldEnum | TermScalarFieldEnum[]
  }

  /**
   * School.fees
   */
  export type School$feesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null
    where?: FeesWhereInput
    orderBy?: FeesOrderByWithRelationInput | FeesOrderByWithRelationInput[]
    cursor?: FeesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeesScalarFieldEnum | FeesScalarFieldEnum[]
  }

  /**
   * School.payouts
   */
  export type School$payoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payout
     */
    omit?: PayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    where?: PayoutWhereInput
    orderBy?: PayoutOrderByWithRelationInput | PayoutOrderByWithRelationInput[]
    cursor?: PayoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayoutScalarFieldEnum | PayoutScalarFieldEnum[]
  }

  /**
   * School.kycverification
   */
  export type School$kycverificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCVerification
     */
    select?: KYCVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCVerification
     */
    omit?: KYCVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCVerificationInclude<ExtArgs> | null
    where?: KYCVerificationWhereInput
  }

  /**
   * School without action
   */
  export type SchoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the School
     */
    omit?: SchoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolInclude<ExtArgs> | null
  }


  /**
   * Model SchoolDirectorVerification
   */

  export type AggregateSchoolDirectorVerification = {
    _count: SchoolDirectorVerificationCountAggregateOutputType | null
    _min: SchoolDirectorVerificationMinAggregateOutputType | null
    _max: SchoolDirectorVerificationMaxAggregateOutputType | null
  }

  export type SchoolDirectorVerificationMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    directorFullName: string | null
    directorIDType: $Enums.DirectorIDType | null
    directorIDNumber: string | null
    document: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolDirectorVerificationMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    directorFullName: string | null
    directorIDType: $Enums.DirectorIDType | null
    directorIDNumber: string | null
    document: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolDirectorVerificationCountAggregateOutputType = {
    id: number
    schoolId: number
    directorFullName: number
    directorIDType: number
    directorIDNumber: number
    document: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolDirectorVerificationMinAggregateInputType = {
    id?: true
    schoolId?: true
    directorFullName?: true
    directorIDType?: true
    directorIDNumber?: true
    document?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolDirectorVerificationMaxAggregateInputType = {
    id?: true
    schoolId?: true
    directorFullName?: true
    directorIDType?: true
    directorIDNumber?: true
    document?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolDirectorVerificationCountAggregateInputType = {
    id?: true
    schoolId?: true
    directorFullName?: true
    directorIDType?: true
    directorIDNumber?: true
    document?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolDirectorVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolDirectorVerification to aggregate.
     */
    where?: SchoolDirectorVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolDirectorVerifications to fetch.
     */
    orderBy?: SchoolDirectorVerificationOrderByWithRelationInput | SchoolDirectorVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolDirectorVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolDirectorVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolDirectorVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolDirectorVerifications
    **/
    _count?: true | SchoolDirectorVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolDirectorVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolDirectorVerificationMaxAggregateInputType
  }

  export type GetSchoolDirectorVerificationAggregateType<T extends SchoolDirectorVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolDirectorVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolDirectorVerification[P]>
      : GetScalarType<T[P], AggregateSchoolDirectorVerification[P]>
  }




  export type SchoolDirectorVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolDirectorVerificationWhereInput
    orderBy?: SchoolDirectorVerificationOrderByWithAggregationInput | SchoolDirectorVerificationOrderByWithAggregationInput[]
    by: SchoolDirectorVerificationScalarFieldEnum[] | SchoolDirectorVerificationScalarFieldEnum
    having?: SchoolDirectorVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolDirectorVerificationCountAggregateInputType | true
    _min?: SchoolDirectorVerificationMinAggregateInputType
    _max?: SchoolDirectorVerificationMaxAggregateInputType
  }

  export type SchoolDirectorVerificationGroupByOutputType = {
    id: string
    schoolId: string
    directorFullName: string
    directorIDType: $Enums.DirectorIDType
    directorIDNumber: string
    document: string
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: SchoolDirectorVerificationCountAggregateOutputType | null
    _min: SchoolDirectorVerificationMinAggregateOutputType | null
    _max: SchoolDirectorVerificationMaxAggregateOutputType | null
  }

  type GetSchoolDirectorVerificationGroupByPayload<T extends SchoolDirectorVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolDirectorVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolDirectorVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolDirectorVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolDirectorVerificationGroupByOutputType[P]>
        }
      >
    >


  export type SchoolDirectorVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    directorFullName?: boolean
    directorIDType?: boolean
    directorIDNumber?: boolean
    document?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolDirectorVerification"]>

  export type SchoolDirectorVerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    directorFullName?: boolean
    directorIDType?: boolean
    directorIDNumber?: boolean
    document?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolDirectorVerification"]>

  export type SchoolDirectorVerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    directorFullName?: boolean
    directorIDType?: boolean
    directorIDNumber?: boolean
    document?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolDirectorVerification"]>

  export type SchoolDirectorVerificationSelectScalar = {
    id?: boolean
    schoolId?: boolean
    directorFullName?: boolean
    directorIDType?: boolean
    directorIDNumber?: boolean
    document?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolDirectorVerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "schoolId" | "directorFullName" | "directorIDType" | "directorIDNumber" | "document" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["schoolDirectorVerification"]>
  export type SchoolDirectorVerificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type SchoolDirectorVerificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type SchoolDirectorVerificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $SchoolDirectorVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SchoolDirectorVerification"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      directorFullName: string
      directorIDType: $Enums.DirectorIDType
      directorIDNumber: string
      document: string
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schoolDirectorVerification"]>
    composites: {}
  }

  type SchoolDirectorVerificationGetPayload<S extends boolean | null | undefined | SchoolDirectorVerificationDefaultArgs> = $Result.GetResult<Prisma.$SchoolDirectorVerificationPayload, S>

  type SchoolDirectorVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SchoolDirectorVerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SchoolDirectorVerificationCountAggregateInputType | true
    }

  export interface SchoolDirectorVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SchoolDirectorVerification'], meta: { name: 'SchoolDirectorVerification' } }
    /**
     * Find zero or one SchoolDirectorVerification that matches the filter.
     * @param {SchoolDirectorVerificationFindUniqueArgs} args - Arguments to find a SchoolDirectorVerification
     * @example
     * // Get one SchoolDirectorVerification
     * const schoolDirectorVerification = await prisma.schoolDirectorVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolDirectorVerificationFindUniqueArgs>(args: SelectSubset<T, SchoolDirectorVerificationFindUniqueArgs<ExtArgs>>): Prisma__SchoolDirectorVerificationClient<$Result.GetResult<Prisma.$SchoolDirectorVerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SchoolDirectorVerification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SchoolDirectorVerificationFindUniqueOrThrowArgs} args - Arguments to find a SchoolDirectorVerification
     * @example
     * // Get one SchoolDirectorVerification
     * const schoolDirectorVerification = await prisma.schoolDirectorVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolDirectorVerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolDirectorVerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolDirectorVerificationClient<$Result.GetResult<Prisma.$SchoolDirectorVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SchoolDirectorVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolDirectorVerificationFindFirstArgs} args - Arguments to find a SchoolDirectorVerification
     * @example
     * // Get one SchoolDirectorVerification
     * const schoolDirectorVerification = await prisma.schoolDirectorVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolDirectorVerificationFindFirstArgs>(args?: SelectSubset<T, SchoolDirectorVerificationFindFirstArgs<ExtArgs>>): Prisma__SchoolDirectorVerificationClient<$Result.GetResult<Prisma.$SchoolDirectorVerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SchoolDirectorVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolDirectorVerificationFindFirstOrThrowArgs} args - Arguments to find a SchoolDirectorVerification
     * @example
     * // Get one SchoolDirectorVerification
     * const schoolDirectorVerification = await prisma.schoolDirectorVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolDirectorVerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolDirectorVerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolDirectorVerificationClient<$Result.GetResult<Prisma.$SchoolDirectorVerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SchoolDirectorVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolDirectorVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolDirectorVerifications
     * const schoolDirectorVerifications = await prisma.schoolDirectorVerification.findMany()
     * 
     * // Get first 10 SchoolDirectorVerifications
     * const schoolDirectorVerifications = await prisma.schoolDirectorVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolDirectorVerificationWithIdOnly = await prisma.schoolDirectorVerification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolDirectorVerificationFindManyArgs>(args?: SelectSubset<T, SchoolDirectorVerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolDirectorVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SchoolDirectorVerification.
     * @param {SchoolDirectorVerificationCreateArgs} args - Arguments to create a SchoolDirectorVerification.
     * @example
     * // Create one SchoolDirectorVerification
     * const SchoolDirectorVerification = await prisma.schoolDirectorVerification.create({
     *   data: {
     *     // ... data to create a SchoolDirectorVerification
     *   }
     * })
     * 
     */
    create<T extends SchoolDirectorVerificationCreateArgs>(args: SelectSubset<T, SchoolDirectorVerificationCreateArgs<ExtArgs>>): Prisma__SchoolDirectorVerificationClient<$Result.GetResult<Prisma.$SchoolDirectorVerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SchoolDirectorVerifications.
     * @param {SchoolDirectorVerificationCreateManyArgs} args - Arguments to create many SchoolDirectorVerifications.
     * @example
     * // Create many SchoolDirectorVerifications
     * const schoolDirectorVerification = await prisma.schoolDirectorVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolDirectorVerificationCreateManyArgs>(args?: SelectSubset<T, SchoolDirectorVerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SchoolDirectorVerifications and returns the data saved in the database.
     * @param {SchoolDirectorVerificationCreateManyAndReturnArgs} args - Arguments to create many SchoolDirectorVerifications.
     * @example
     * // Create many SchoolDirectorVerifications
     * const schoolDirectorVerification = await prisma.schoolDirectorVerification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SchoolDirectorVerifications and only return the `id`
     * const schoolDirectorVerificationWithIdOnly = await prisma.schoolDirectorVerification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolDirectorVerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolDirectorVerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolDirectorVerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SchoolDirectorVerification.
     * @param {SchoolDirectorVerificationDeleteArgs} args - Arguments to delete one SchoolDirectorVerification.
     * @example
     * // Delete one SchoolDirectorVerification
     * const SchoolDirectorVerification = await prisma.schoolDirectorVerification.delete({
     *   where: {
     *     // ... filter to delete one SchoolDirectorVerification
     *   }
     * })
     * 
     */
    delete<T extends SchoolDirectorVerificationDeleteArgs>(args: SelectSubset<T, SchoolDirectorVerificationDeleteArgs<ExtArgs>>): Prisma__SchoolDirectorVerificationClient<$Result.GetResult<Prisma.$SchoolDirectorVerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SchoolDirectorVerification.
     * @param {SchoolDirectorVerificationUpdateArgs} args - Arguments to update one SchoolDirectorVerification.
     * @example
     * // Update one SchoolDirectorVerification
     * const schoolDirectorVerification = await prisma.schoolDirectorVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolDirectorVerificationUpdateArgs>(args: SelectSubset<T, SchoolDirectorVerificationUpdateArgs<ExtArgs>>): Prisma__SchoolDirectorVerificationClient<$Result.GetResult<Prisma.$SchoolDirectorVerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SchoolDirectorVerifications.
     * @param {SchoolDirectorVerificationDeleteManyArgs} args - Arguments to filter SchoolDirectorVerifications to delete.
     * @example
     * // Delete a few SchoolDirectorVerifications
     * const { count } = await prisma.schoolDirectorVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolDirectorVerificationDeleteManyArgs>(args?: SelectSubset<T, SchoolDirectorVerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolDirectorVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolDirectorVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolDirectorVerifications
     * const schoolDirectorVerification = await prisma.schoolDirectorVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolDirectorVerificationUpdateManyArgs>(args: SelectSubset<T, SchoolDirectorVerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolDirectorVerifications and returns the data updated in the database.
     * @param {SchoolDirectorVerificationUpdateManyAndReturnArgs} args - Arguments to update many SchoolDirectorVerifications.
     * @example
     * // Update many SchoolDirectorVerifications
     * const schoolDirectorVerification = await prisma.schoolDirectorVerification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SchoolDirectorVerifications and only return the `id`
     * const schoolDirectorVerificationWithIdOnly = await prisma.schoolDirectorVerification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SchoolDirectorVerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, SchoolDirectorVerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolDirectorVerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SchoolDirectorVerification.
     * @param {SchoolDirectorVerificationUpsertArgs} args - Arguments to update or create a SchoolDirectorVerification.
     * @example
     * // Update or create a SchoolDirectorVerification
     * const schoolDirectorVerification = await prisma.schoolDirectorVerification.upsert({
     *   create: {
     *     // ... data to create a SchoolDirectorVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolDirectorVerification we want to update
     *   }
     * })
     */
    upsert<T extends SchoolDirectorVerificationUpsertArgs>(args: SelectSubset<T, SchoolDirectorVerificationUpsertArgs<ExtArgs>>): Prisma__SchoolDirectorVerificationClient<$Result.GetResult<Prisma.$SchoolDirectorVerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SchoolDirectorVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolDirectorVerificationCountArgs} args - Arguments to filter SchoolDirectorVerifications to count.
     * @example
     * // Count the number of SchoolDirectorVerifications
     * const count = await prisma.schoolDirectorVerification.count({
     *   where: {
     *     // ... the filter for the SchoolDirectorVerifications we want to count
     *   }
     * })
    **/
    count<T extends SchoolDirectorVerificationCountArgs>(
      args?: Subset<T, SchoolDirectorVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolDirectorVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolDirectorVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolDirectorVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolDirectorVerificationAggregateArgs>(args: Subset<T, SchoolDirectorVerificationAggregateArgs>): Prisma.PrismaPromise<GetSchoolDirectorVerificationAggregateType<T>>

    /**
     * Group by SchoolDirectorVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolDirectorVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolDirectorVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolDirectorVerificationGroupByArgs['orderBy'] }
        : { orderBy?: SchoolDirectorVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolDirectorVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolDirectorVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SchoolDirectorVerification model
   */
  readonly fields: SchoolDirectorVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolDirectorVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolDirectorVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SchoolDirectorVerification model
   */
  interface SchoolDirectorVerificationFieldRefs {
    readonly id: FieldRef<"SchoolDirectorVerification", 'String'>
    readonly schoolId: FieldRef<"SchoolDirectorVerification", 'String'>
    readonly directorFullName: FieldRef<"SchoolDirectorVerification", 'String'>
    readonly directorIDType: FieldRef<"SchoolDirectorVerification", 'DirectorIDType'>
    readonly directorIDNumber: FieldRef<"SchoolDirectorVerification", 'String'>
    readonly document: FieldRef<"SchoolDirectorVerification", 'String'>
    readonly isDeleted: FieldRef<"SchoolDirectorVerification", 'Boolean'>
    readonly createdAt: FieldRef<"SchoolDirectorVerification", 'DateTime'>
    readonly updatedAt: FieldRef<"SchoolDirectorVerification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SchoolDirectorVerification findUnique
   */
  export type SchoolDirectorVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolDirectorVerification
     */
    select?: SchoolDirectorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolDirectorVerification
     */
    omit?: SchoolDirectorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolDirectorVerificationInclude<ExtArgs> | null
    /**
     * Filter, which SchoolDirectorVerification to fetch.
     */
    where: SchoolDirectorVerificationWhereUniqueInput
  }

  /**
   * SchoolDirectorVerification findUniqueOrThrow
   */
  export type SchoolDirectorVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolDirectorVerification
     */
    select?: SchoolDirectorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolDirectorVerification
     */
    omit?: SchoolDirectorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolDirectorVerificationInclude<ExtArgs> | null
    /**
     * Filter, which SchoolDirectorVerification to fetch.
     */
    where: SchoolDirectorVerificationWhereUniqueInput
  }

  /**
   * SchoolDirectorVerification findFirst
   */
  export type SchoolDirectorVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolDirectorVerification
     */
    select?: SchoolDirectorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolDirectorVerification
     */
    omit?: SchoolDirectorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolDirectorVerificationInclude<ExtArgs> | null
    /**
     * Filter, which SchoolDirectorVerification to fetch.
     */
    where?: SchoolDirectorVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolDirectorVerifications to fetch.
     */
    orderBy?: SchoolDirectorVerificationOrderByWithRelationInput | SchoolDirectorVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolDirectorVerifications.
     */
    cursor?: SchoolDirectorVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolDirectorVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolDirectorVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolDirectorVerifications.
     */
    distinct?: SchoolDirectorVerificationScalarFieldEnum | SchoolDirectorVerificationScalarFieldEnum[]
  }

  /**
   * SchoolDirectorVerification findFirstOrThrow
   */
  export type SchoolDirectorVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolDirectorVerification
     */
    select?: SchoolDirectorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolDirectorVerification
     */
    omit?: SchoolDirectorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolDirectorVerificationInclude<ExtArgs> | null
    /**
     * Filter, which SchoolDirectorVerification to fetch.
     */
    where?: SchoolDirectorVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolDirectorVerifications to fetch.
     */
    orderBy?: SchoolDirectorVerificationOrderByWithRelationInput | SchoolDirectorVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolDirectorVerifications.
     */
    cursor?: SchoolDirectorVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolDirectorVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolDirectorVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolDirectorVerifications.
     */
    distinct?: SchoolDirectorVerificationScalarFieldEnum | SchoolDirectorVerificationScalarFieldEnum[]
  }

  /**
   * SchoolDirectorVerification findMany
   */
  export type SchoolDirectorVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolDirectorVerification
     */
    select?: SchoolDirectorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolDirectorVerification
     */
    omit?: SchoolDirectorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolDirectorVerificationInclude<ExtArgs> | null
    /**
     * Filter, which SchoolDirectorVerifications to fetch.
     */
    where?: SchoolDirectorVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolDirectorVerifications to fetch.
     */
    orderBy?: SchoolDirectorVerificationOrderByWithRelationInput | SchoolDirectorVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolDirectorVerifications.
     */
    cursor?: SchoolDirectorVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolDirectorVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolDirectorVerifications.
     */
    skip?: number
    distinct?: SchoolDirectorVerificationScalarFieldEnum | SchoolDirectorVerificationScalarFieldEnum[]
  }

  /**
   * SchoolDirectorVerification create
   */
  export type SchoolDirectorVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolDirectorVerification
     */
    select?: SchoolDirectorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolDirectorVerification
     */
    omit?: SchoolDirectorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolDirectorVerificationInclude<ExtArgs> | null
    /**
     * The data needed to create a SchoolDirectorVerification.
     */
    data: XOR<SchoolDirectorVerificationCreateInput, SchoolDirectorVerificationUncheckedCreateInput>
  }

  /**
   * SchoolDirectorVerification createMany
   */
  export type SchoolDirectorVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SchoolDirectorVerifications.
     */
    data: SchoolDirectorVerificationCreateManyInput | SchoolDirectorVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SchoolDirectorVerification createManyAndReturn
   */
  export type SchoolDirectorVerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolDirectorVerification
     */
    select?: SchoolDirectorVerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolDirectorVerification
     */
    omit?: SchoolDirectorVerificationOmit<ExtArgs> | null
    /**
     * The data used to create many SchoolDirectorVerifications.
     */
    data: SchoolDirectorVerificationCreateManyInput | SchoolDirectorVerificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolDirectorVerificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolDirectorVerification update
   */
  export type SchoolDirectorVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolDirectorVerification
     */
    select?: SchoolDirectorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolDirectorVerification
     */
    omit?: SchoolDirectorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolDirectorVerificationInclude<ExtArgs> | null
    /**
     * The data needed to update a SchoolDirectorVerification.
     */
    data: XOR<SchoolDirectorVerificationUpdateInput, SchoolDirectorVerificationUncheckedUpdateInput>
    /**
     * Choose, which SchoolDirectorVerification to update.
     */
    where: SchoolDirectorVerificationWhereUniqueInput
  }

  /**
   * SchoolDirectorVerification updateMany
   */
  export type SchoolDirectorVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SchoolDirectorVerifications.
     */
    data: XOR<SchoolDirectorVerificationUpdateManyMutationInput, SchoolDirectorVerificationUncheckedUpdateManyInput>
    /**
     * Filter which SchoolDirectorVerifications to update
     */
    where?: SchoolDirectorVerificationWhereInput
    /**
     * Limit how many SchoolDirectorVerifications to update.
     */
    limit?: number
  }

  /**
   * SchoolDirectorVerification updateManyAndReturn
   */
  export type SchoolDirectorVerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolDirectorVerification
     */
    select?: SchoolDirectorVerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolDirectorVerification
     */
    omit?: SchoolDirectorVerificationOmit<ExtArgs> | null
    /**
     * The data used to update SchoolDirectorVerifications.
     */
    data: XOR<SchoolDirectorVerificationUpdateManyMutationInput, SchoolDirectorVerificationUncheckedUpdateManyInput>
    /**
     * Filter which SchoolDirectorVerifications to update
     */
    where?: SchoolDirectorVerificationWhereInput
    /**
     * Limit how many SchoolDirectorVerifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolDirectorVerificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolDirectorVerification upsert
   */
  export type SchoolDirectorVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolDirectorVerification
     */
    select?: SchoolDirectorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolDirectorVerification
     */
    omit?: SchoolDirectorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolDirectorVerificationInclude<ExtArgs> | null
    /**
     * The filter to search for the SchoolDirectorVerification to update in case it exists.
     */
    where: SchoolDirectorVerificationWhereUniqueInput
    /**
     * In case the SchoolDirectorVerification found by the `where` argument doesn't exist, create a new SchoolDirectorVerification with this data.
     */
    create: XOR<SchoolDirectorVerificationCreateInput, SchoolDirectorVerificationUncheckedCreateInput>
    /**
     * In case the SchoolDirectorVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolDirectorVerificationUpdateInput, SchoolDirectorVerificationUncheckedUpdateInput>
  }

  /**
   * SchoolDirectorVerification delete
   */
  export type SchoolDirectorVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolDirectorVerification
     */
    select?: SchoolDirectorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolDirectorVerification
     */
    omit?: SchoolDirectorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolDirectorVerificationInclude<ExtArgs> | null
    /**
     * Filter which SchoolDirectorVerification to delete.
     */
    where: SchoolDirectorVerificationWhereUniqueInput
  }

  /**
   * SchoolDirectorVerification deleteMany
   */
  export type SchoolDirectorVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolDirectorVerifications to delete
     */
    where?: SchoolDirectorVerificationWhereInput
    /**
     * Limit how many SchoolDirectorVerifications to delete.
     */
    limit?: number
  }

  /**
   * SchoolDirectorVerification without action
   */
  export type SchoolDirectorVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolDirectorVerification
     */
    select?: SchoolDirectorVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolDirectorVerification
     */
    omit?: SchoolDirectorVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolDirectorVerificationInclude<ExtArgs> | null
  }


  /**
   * Model SchoolOwnershipVerification
   */

  export type AggregateSchoolOwnershipVerification = {
    _count: SchoolOwnershipVerificationCountAggregateOutputType | null
    _min: SchoolOwnershipVerificationMinAggregateOutputType | null
    _max: SchoolOwnershipVerificationMaxAggregateOutputType | null
  }

  export type SchoolOwnershipVerificationMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    cacform7: string | null
    cacShareAllotmentForm: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolOwnershipVerificationMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    cacform7: string | null
    cacShareAllotmentForm: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolOwnershipVerificationCountAggregateOutputType = {
    id: number
    schoolId: number
    cacform7: number
    cacShareAllotmentForm: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolOwnershipVerificationMinAggregateInputType = {
    id?: true
    schoolId?: true
    cacform7?: true
    cacShareAllotmentForm?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolOwnershipVerificationMaxAggregateInputType = {
    id?: true
    schoolId?: true
    cacform7?: true
    cacShareAllotmentForm?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolOwnershipVerificationCountAggregateInputType = {
    id?: true
    schoolId?: true
    cacform7?: true
    cacShareAllotmentForm?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolOwnershipVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolOwnershipVerification to aggregate.
     */
    where?: SchoolOwnershipVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolOwnershipVerifications to fetch.
     */
    orderBy?: SchoolOwnershipVerificationOrderByWithRelationInput | SchoolOwnershipVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolOwnershipVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolOwnershipVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolOwnershipVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolOwnershipVerifications
    **/
    _count?: true | SchoolOwnershipVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolOwnershipVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolOwnershipVerificationMaxAggregateInputType
  }

  export type GetSchoolOwnershipVerificationAggregateType<T extends SchoolOwnershipVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolOwnershipVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolOwnershipVerification[P]>
      : GetScalarType<T[P], AggregateSchoolOwnershipVerification[P]>
  }




  export type SchoolOwnershipVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolOwnershipVerificationWhereInput
    orderBy?: SchoolOwnershipVerificationOrderByWithAggregationInput | SchoolOwnershipVerificationOrderByWithAggregationInput[]
    by: SchoolOwnershipVerificationScalarFieldEnum[] | SchoolOwnershipVerificationScalarFieldEnum
    having?: SchoolOwnershipVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolOwnershipVerificationCountAggregateInputType | true
    _min?: SchoolOwnershipVerificationMinAggregateInputType
    _max?: SchoolOwnershipVerificationMaxAggregateInputType
  }

  export type SchoolOwnershipVerificationGroupByOutputType = {
    id: string
    schoolId: string
    cacform7: string
    cacShareAllotmentForm: string
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: SchoolOwnershipVerificationCountAggregateOutputType | null
    _min: SchoolOwnershipVerificationMinAggregateOutputType | null
    _max: SchoolOwnershipVerificationMaxAggregateOutputType | null
  }

  type GetSchoolOwnershipVerificationGroupByPayload<T extends SchoolOwnershipVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolOwnershipVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolOwnershipVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolOwnershipVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolOwnershipVerificationGroupByOutputType[P]>
        }
      >
    >


  export type SchoolOwnershipVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    cacform7?: boolean
    cacShareAllotmentForm?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolOwnershipVerification"]>

  export type SchoolOwnershipVerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    cacform7?: boolean
    cacShareAllotmentForm?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolOwnershipVerification"]>

  export type SchoolOwnershipVerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    cacform7?: boolean
    cacShareAllotmentForm?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolOwnershipVerification"]>

  export type SchoolOwnershipVerificationSelectScalar = {
    id?: boolean
    schoolId?: boolean
    cacform7?: boolean
    cacShareAllotmentForm?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolOwnershipVerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "schoolId" | "cacform7" | "cacShareAllotmentForm" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["schoolOwnershipVerification"]>
  export type SchoolOwnershipVerificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type SchoolOwnershipVerificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type SchoolOwnershipVerificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $SchoolOwnershipVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SchoolOwnershipVerification"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      cacform7: string
      cacShareAllotmentForm: string
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schoolOwnershipVerification"]>
    composites: {}
  }

  type SchoolOwnershipVerificationGetPayload<S extends boolean | null | undefined | SchoolOwnershipVerificationDefaultArgs> = $Result.GetResult<Prisma.$SchoolOwnershipVerificationPayload, S>

  type SchoolOwnershipVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SchoolOwnershipVerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SchoolOwnershipVerificationCountAggregateInputType | true
    }

  export interface SchoolOwnershipVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SchoolOwnershipVerification'], meta: { name: 'SchoolOwnershipVerification' } }
    /**
     * Find zero or one SchoolOwnershipVerification that matches the filter.
     * @param {SchoolOwnershipVerificationFindUniqueArgs} args - Arguments to find a SchoolOwnershipVerification
     * @example
     * // Get one SchoolOwnershipVerification
     * const schoolOwnershipVerification = await prisma.schoolOwnershipVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolOwnershipVerificationFindUniqueArgs>(args: SelectSubset<T, SchoolOwnershipVerificationFindUniqueArgs<ExtArgs>>): Prisma__SchoolOwnershipVerificationClient<$Result.GetResult<Prisma.$SchoolOwnershipVerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SchoolOwnershipVerification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SchoolOwnershipVerificationFindUniqueOrThrowArgs} args - Arguments to find a SchoolOwnershipVerification
     * @example
     * // Get one SchoolOwnershipVerification
     * const schoolOwnershipVerification = await prisma.schoolOwnershipVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolOwnershipVerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolOwnershipVerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolOwnershipVerificationClient<$Result.GetResult<Prisma.$SchoolOwnershipVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SchoolOwnershipVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolOwnershipVerificationFindFirstArgs} args - Arguments to find a SchoolOwnershipVerification
     * @example
     * // Get one SchoolOwnershipVerification
     * const schoolOwnershipVerification = await prisma.schoolOwnershipVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolOwnershipVerificationFindFirstArgs>(args?: SelectSubset<T, SchoolOwnershipVerificationFindFirstArgs<ExtArgs>>): Prisma__SchoolOwnershipVerificationClient<$Result.GetResult<Prisma.$SchoolOwnershipVerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SchoolOwnershipVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolOwnershipVerificationFindFirstOrThrowArgs} args - Arguments to find a SchoolOwnershipVerification
     * @example
     * // Get one SchoolOwnershipVerification
     * const schoolOwnershipVerification = await prisma.schoolOwnershipVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolOwnershipVerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolOwnershipVerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolOwnershipVerificationClient<$Result.GetResult<Prisma.$SchoolOwnershipVerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SchoolOwnershipVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolOwnershipVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolOwnershipVerifications
     * const schoolOwnershipVerifications = await prisma.schoolOwnershipVerification.findMany()
     * 
     * // Get first 10 SchoolOwnershipVerifications
     * const schoolOwnershipVerifications = await prisma.schoolOwnershipVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolOwnershipVerificationWithIdOnly = await prisma.schoolOwnershipVerification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolOwnershipVerificationFindManyArgs>(args?: SelectSubset<T, SchoolOwnershipVerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolOwnershipVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SchoolOwnershipVerification.
     * @param {SchoolOwnershipVerificationCreateArgs} args - Arguments to create a SchoolOwnershipVerification.
     * @example
     * // Create one SchoolOwnershipVerification
     * const SchoolOwnershipVerification = await prisma.schoolOwnershipVerification.create({
     *   data: {
     *     // ... data to create a SchoolOwnershipVerification
     *   }
     * })
     * 
     */
    create<T extends SchoolOwnershipVerificationCreateArgs>(args: SelectSubset<T, SchoolOwnershipVerificationCreateArgs<ExtArgs>>): Prisma__SchoolOwnershipVerificationClient<$Result.GetResult<Prisma.$SchoolOwnershipVerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SchoolOwnershipVerifications.
     * @param {SchoolOwnershipVerificationCreateManyArgs} args - Arguments to create many SchoolOwnershipVerifications.
     * @example
     * // Create many SchoolOwnershipVerifications
     * const schoolOwnershipVerification = await prisma.schoolOwnershipVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolOwnershipVerificationCreateManyArgs>(args?: SelectSubset<T, SchoolOwnershipVerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SchoolOwnershipVerifications and returns the data saved in the database.
     * @param {SchoolOwnershipVerificationCreateManyAndReturnArgs} args - Arguments to create many SchoolOwnershipVerifications.
     * @example
     * // Create many SchoolOwnershipVerifications
     * const schoolOwnershipVerification = await prisma.schoolOwnershipVerification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SchoolOwnershipVerifications and only return the `id`
     * const schoolOwnershipVerificationWithIdOnly = await prisma.schoolOwnershipVerification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolOwnershipVerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolOwnershipVerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolOwnershipVerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SchoolOwnershipVerification.
     * @param {SchoolOwnershipVerificationDeleteArgs} args - Arguments to delete one SchoolOwnershipVerification.
     * @example
     * // Delete one SchoolOwnershipVerification
     * const SchoolOwnershipVerification = await prisma.schoolOwnershipVerification.delete({
     *   where: {
     *     // ... filter to delete one SchoolOwnershipVerification
     *   }
     * })
     * 
     */
    delete<T extends SchoolOwnershipVerificationDeleteArgs>(args: SelectSubset<T, SchoolOwnershipVerificationDeleteArgs<ExtArgs>>): Prisma__SchoolOwnershipVerificationClient<$Result.GetResult<Prisma.$SchoolOwnershipVerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SchoolOwnershipVerification.
     * @param {SchoolOwnershipVerificationUpdateArgs} args - Arguments to update one SchoolOwnershipVerification.
     * @example
     * // Update one SchoolOwnershipVerification
     * const schoolOwnershipVerification = await prisma.schoolOwnershipVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolOwnershipVerificationUpdateArgs>(args: SelectSubset<T, SchoolOwnershipVerificationUpdateArgs<ExtArgs>>): Prisma__SchoolOwnershipVerificationClient<$Result.GetResult<Prisma.$SchoolOwnershipVerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SchoolOwnershipVerifications.
     * @param {SchoolOwnershipVerificationDeleteManyArgs} args - Arguments to filter SchoolOwnershipVerifications to delete.
     * @example
     * // Delete a few SchoolOwnershipVerifications
     * const { count } = await prisma.schoolOwnershipVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolOwnershipVerificationDeleteManyArgs>(args?: SelectSubset<T, SchoolOwnershipVerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolOwnershipVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolOwnershipVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolOwnershipVerifications
     * const schoolOwnershipVerification = await prisma.schoolOwnershipVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolOwnershipVerificationUpdateManyArgs>(args: SelectSubset<T, SchoolOwnershipVerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolOwnershipVerifications and returns the data updated in the database.
     * @param {SchoolOwnershipVerificationUpdateManyAndReturnArgs} args - Arguments to update many SchoolOwnershipVerifications.
     * @example
     * // Update many SchoolOwnershipVerifications
     * const schoolOwnershipVerification = await prisma.schoolOwnershipVerification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SchoolOwnershipVerifications and only return the `id`
     * const schoolOwnershipVerificationWithIdOnly = await prisma.schoolOwnershipVerification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SchoolOwnershipVerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, SchoolOwnershipVerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolOwnershipVerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SchoolOwnershipVerification.
     * @param {SchoolOwnershipVerificationUpsertArgs} args - Arguments to update or create a SchoolOwnershipVerification.
     * @example
     * // Update or create a SchoolOwnershipVerification
     * const schoolOwnershipVerification = await prisma.schoolOwnershipVerification.upsert({
     *   create: {
     *     // ... data to create a SchoolOwnershipVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolOwnershipVerification we want to update
     *   }
     * })
     */
    upsert<T extends SchoolOwnershipVerificationUpsertArgs>(args: SelectSubset<T, SchoolOwnershipVerificationUpsertArgs<ExtArgs>>): Prisma__SchoolOwnershipVerificationClient<$Result.GetResult<Prisma.$SchoolOwnershipVerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SchoolOwnershipVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolOwnershipVerificationCountArgs} args - Arguments to filter SchoolOwnershipVerifications to count.
     * @example
     * // Count the number of SchoolOwnershipVerifications
     * const count = await prisma.schoolOwnershipVerification.count({
     *   where: {
     *     // ... the filter for the SchoolOwnershipVerifications we want to count
     *   }
     * })
    **/
    count<T extends SchoolOwnershipVerificationCountArgs>(
      args?: Subset<T, SchoolOwnershipVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolOwnershipVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolOwnershipVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolOwnershipVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolOwnershipVerificationAggregateArgs>(args: Subset<T, SchoolOwnershipVerificationAggregateArgs>): Prisma.PrismaPromise<GetSchoolOwnershipVerificationAggregateType<T>>

    /**
     * Group by SchoolOwnershipVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolOwnershipVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolOwnershipVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolOwnershipVerificationGroupByArgs['orderBy'] }
        : { orderBy?: SchoolOwnershipVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolOwnershipVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolOwnershipVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SchoolOwnershipVerification model
   */
  readonly fields: SchoolOwnershipVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolOwnershipVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolOwnershipVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SchoolOwnershipVerification model
   */
  interface SchoolOwnershipVerificationFieldRefs {
    readonly id: FieldRef<"SchoolOwnershipVerification", 'String'>
    readonly schoolId: FieldRef<"SchoolOwnershipVerification", 'String'>
    readonly cacform7: FieldRef<"SchoolOwnershipVerification", 'String'>
    readonly cacShareAllotmentForm: FieldRef<"SchoolOwnershipVerification", 'String'>
    readonly isDeleted: FieldRef<"SchoolOwnershipVerification", 'Boolean'>
    readonly createdAt: FieldRef<"SchoolOwnershipVerification", 'DateTime'>
    readonly updatedAt: FieldRef<"SchoolOwnershipVerification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SchoolOwnershipVerification findUnique
   */
  export type SchoolOwnershipVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolOwnershipVerification
     */
    select?: SchoolOwnershipVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolOwnershipVerification
     */
    omit?: SchoolOwnershipVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolOwnershipVerificationInclude<ExtArgs> | null
    /**
     * Filter, which SchoolOwnershipVerification to fetch.
     */
    where: SchoolOwnershipVerificationWhereUniqueInput
  }

  /**
   * SchoolOwnershipVerification findUniqueOrThrow
   */
  export type SchoolOwnershipVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolOwnershipVerification
     */
    select?: SchoolOwnershipVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolOwnershipVerification
     */
    omit?: SchoolOwnershipVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolOwnershipVerificationInclude<ExtArgs> | null
    /**
     * Filter, which SchoolOwnershipVerification to fetch.
     */
    where: SchoolOwnershipVerificationWhereUniqueInput
  }

  /**
   * SchoolOwnershipVerification findFirst
   */
  export type SchoolOwnershipVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolOwnershipVerification
     */
    select?: SchoolOwnershipVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolOwnershipVerification
     */
    omit?: SchoolOwnershipVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolOwnershipVerificationInclude<ExtArgs> | null
    /**
     * Filter, which SchoolOwnershipVerification to fetch.
     */
    where?: SchoolOwnershipVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolOwnershipVerifications to fetch.
     */
    orderBy?: SchoolOwnershipVerificationOrderByWithRelationInput | SchoolOwnershipVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolOwnershipVerifications.
     */
    cursor?: SchoolOwnershipVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolOwnershipVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolOwnershipVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolOwnershipVerifications.
     */
    distinct?: SchoolOwnershipVerificationScalarFieldEnum | SchoolOwnershipVerificationScalarFieldEnum[]
  }

  /**
   * SchoolOwnershipVerification findFirstOrThrow
   */
  export type SchoolOwnershipVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolOwnershipVerification
     */
    select?: SchoolOwnershipVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolOwnershipVerification
     */
    omit?: SchoolOwnershipVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolOwnershipVerificationInclude<ExtArgs> | null
    /**
     * Filter, which SchoolOwnershipVerification to fetch.
     */
    where?: SchoolOwnershipVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolOwnershipVerifications to fetch.
     */
    orderBy?: SchoolOwnershipVerificationOrderByWithRelationInput | SchoolOwnershipVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolOwnershipVerifications.
     */
    cursor?: SchoolOwnershipVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolOwnershipVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolOwnershipVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolOwnershipVerifications.
     */
    distinct?: SchoolOwnershipVerificationScalarFieldEnum | SchoolOwnershipVerificationScalarFieldEnum[]
  }

  /**
   * SchoolOwnershipVerification findMany
   */
  export type SchoolOwnershipVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolOwnershipVerification
     */
    select?: SchoolOwnershipVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolOwnershipVerification
     */
    omit?: SchoolOwnershipVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolOwnershipVerificationInclude<ExtArgs> | null
    /**
     * Filter, which SchoolOwnershipVerifications to fetch.
     */
    where?: SchoolOwnershipVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolOwnershipVerifications to fetch.
     */
    orderBy?: SchoolOwnershipVerificationOrderByWithRelationInput | SchoolOwnershipVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolOwnershipVerifications.
     */
    cursor?: SchoolOwnershipVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolOwnershipVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolOwnershipVerifications.
     */
    skip?: number
    distinct?: SchoolOwnershipVerificationScalarFieldEnum | SchoolOwnershipVerificationScalarFieldEnum[]
  }

  /**
   * SchoolOwnershipVerification create
   */
  export type SchoolOwnershipVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolOwnershipVerification
     */
    select?: SchoolOwnershipVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolOwnershipVerification
     */
    omit?: SchoolOwnershipVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolOwnershipVerificationInclude<ExtArgs> | null
    /**
     * The data needed to create a SchoolOwnershipVerification.
     */
    data: XOR<SchoolOwnershipVerificationCreateInput, SchoolOwnershipVerificationUncheckedCreateInput>
  }

  /**
   * SchoolOwnershipVerification createMany
   */
  export type SchoolOwnershipVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SchoolOwnershipVerifications.
     */
    data: SchoolOwnershipVerificationCreateManyInput | SchoolOwnershipVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SchoolOwnershipVerification createManyAndReturn
   */
  export type SchoolOwnershipVerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolOwnershipVerification
     */
    select?: SchoolOwnershipVerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolOwnershipVerification
     */
    omit?: SchoolOwnershipVerificationOmit<ExtArgs> | null
    /**
     * The data used to create many SchoolOwnershipVerifications.
     */
    data: SchoolOwnershipVerificationCreateManyInput | SchoolOwnershipVerificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolOwnershipVerificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolOwnershipVerification update
   */
  export type SchoolOwnershipVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolOwnershipVerification
     */
    select?: SchoolOwnershipVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolOwnershipVerification
     */
    omit?: SchoolOwnershipVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolOwnershipVerificationInclude<ExtArgs> | null
    /**
     * The data needed to update a SchoolOwnershipVerification.
     */
    data: XOR<SchoolOwnershipVerificationUpdateInput, SchoolOwnershipVerificationUncheckedUpdateInput>
    /**
     * Choose, which SchoolOwnershipVerification to update.
     */
    where: SchoolOwnershipVerificationWhereUniqueInput
  }

  /**
   * SchoolOwnershipVerification updateMany
   */
  export type SchoolOwnershipVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SchoolOwnershipVerifications.
     */
    data: XOR<SchoolOwnershipVerificationUpdateManyMutationInput, SchoolOwnershipVerificationUncheckedUpdateManyInput>
    /**
     * Filter which SchoolOwnershipVerifications to update
     */
    where?: SchoolOwnershipVerificationWhereInput
    /**
     * Limit how many SchoolOwnershipVerifications to update.
     */
    limit?: number
  }

  /**
   * SchoolOwnershipVerification updateManyAndReturn
   */
  export type SchoolOwnershipVerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolOwnershipVerification
     */
    select?: SchoolOwnershipVerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolOwnershipVerification
     */
    omit?: SchoolOwnershipVerificationOmit<ExtArgs> | null
    /**
     * The data used to update SchoolOwnershipVerifications.
     */
    data: XOR<SchoolOwnershipVerificationUpdateManyMutationInput, SchoolOwnershipVerificationUncheckedUpdateManyInput>
    /**
     * Filter which SchoolOwnershipVerifications to update
     */
    where?: SchoolOwnershipVerificationWhereInput
    /**
     * Limit how many SchoolOwnershipVerifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolOwnershipVerificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolOwnershipVerification upsert
   */
  export type SchoolOwnershipVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolOwnershipVerification
     */
    select?: SchoolOwnershipVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolOwnershipVerification
     */
    omit?: SchoolOwnershipVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolOwnershipVerificationInclude<ExtArgs> | null
    /**
     * The filter to search for the SchoolOwnershipVerification to update in case it exists.
     */
    where: SchoolOwnershipVerificationWhereUniqueInput
    /**
     * In case the SchoolOwnershipVerification found by the `where` argument doesn't exist, create a new SchoolOwnershipVerification with this data.
     */
    create: XOR<SchoolOwnershipVerificationCreateInput, SchoolOwnershipVerificationUncheckedCreateInput>
    /**
     * In case the SchoolOwnershipVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolOwnershipVerificationUpdateInput, SchoolOwnershipVerificationUncheckedUpdateInput>
  }

  /**
   * SchoolOwnershipVerification delete
   */
  export type SchoolOwnershipVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolOwnershipVerification
     */
    select?: SchoolOwnershipVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolOwnershipVerification
     */
    omit?: SchoolOwnershipVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolOwnershipVerificationInclude<ExtArgs> | null
    /**
     * Filter which SchoolOwnershipVerification to delete.
     */
    where: SchoolOwnershipVerificationWhereUniqueInput
  }

  /**
   * SchoolOwnershipVerification deleteMany
   */
  export type SchoolOwnershipVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolOwnershipVerifications to delete
     */
    where?: SchoolOwnershipVerificationWhereInput
    /**
     * Limit how many SchoolOwnershipVerifications to delete.
     */
    limit?: number
  }

  /**
   * SchoolOwnershipVerification without action
   */
  export type SchoolOwnershipVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolOwnershipVerification
     */
    select?: SchoolOwnershipVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolOwnershipVerification
     */
    omit?: SchoolOwnershipVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolOwnershipVerificationInclude<ExtArgs> | null
  }


  /**
   * Model SchoolVerification
   */

  export type AggregateSchoolVerification = {
    _count: SchoolVerificationCountAggregateOutputType | null
    _min: SchoolVerificationMinAggregateOutputType | null
    _max: SchoolVerificationMaxAggregateOutputType | null
  }

  export type SchoolVerificationMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    cacCertificate: string | null
    accreditationDocument: string | null
    taxIdentificationNumber: string | null
    licenseDocument: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolVerificationMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    cacCertificate: string | null
    accreditationDocument: string | null
    taxIdentificationNumber: string | null
    licenseDocument: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolVerificationCountAggregateOutputType = {
    id: number
    schoolId: number
    cacCertificate: number
    accreditationDocument: number
    taxIdentificationNumber: number
    licenseDocument: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolVerificationMinAggregateInputType = {
    id?: true
    schoolId?: true
    cacCertificate?: true
    accreditationDocument?: true
    taxIdentificationNumber?: true
    licenseDocument?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolVerificationMaxAggregateInputType = {
    id?: true
    schoolId?: true
    cacCertificate?: true
    accreditationDocument?: true
    taxIdentificationNumber?: true
    licenseDocument?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolVerificationCountAggregateInputType = {
    id?: true
    schoolId?: true
    cacCertificate?: true
    accreditationDocument?: true
    taxIdentificationNumber?: true
    licenseDocument?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolVerification to aggregate.
     */
    where?: SchoolVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolVerifications to fetch.
     */
    orderBy?: SchoolVerificationOrderByWithRelationInput | SchoolVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolVerifications
    **/
    _count?: true | SchoolVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolVerificationMaxAggregateInputType
  }

  export type GetSchoolVerificationAggregateType<T extends SchoolVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolVerification[P]>
      : GetScalarType<T[P], AggregateSchoolVerification[P]>
  }




  export type SchoolVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolVerificationWhereInput
    orderBy?: SchoolVerificationOrderByWithAggregationInput | SchoolVerificationOrderByWithAggregationInput[]
    by: SchoolVerificationScalarFieldEnum[] | SchoolVerificationScalarFieldEnum
    having?: SchoolVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolVerificationCountAggregateInputType | true
    _min?: SchoolVerificationMinAggregateInputType
    _max?: SchoolVerificationMaxAggregateInputType
  }

  export type SchoolVerificationGroupByOutputType = {
    id: string
    schoolId: string
    cacCertificate: string
    accreditationDocument: string
    taxIdentificationNumber: string
    licenseDocument: string
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: SchoolVerificationCountAggregateOutputType | null
    _min: SchoolVerificationMinAggregateOutputType | null
    _max: SchoolVerificationMaxAggregateOutputType | null
  }

  type GetSchoolVerificationGroupByPayload<T extends SchoolVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolVerificationGroupByOutputType[P]>
        }
      >
    >


  export type SchoolVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    cacCertificate?: boolean
    accreditationDocument?: boolean
    taxIdentificationNumber?: boolean
    licenseDocument?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolVerification"]>

  export type SchoolVerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    cacCertificate?: boolean
    accreditationDocument?: boolean
    taxIdentificationNumber?: boolean
    licenseDocument?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolVerification"]>

  export type SchoolVerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    cacCertificate?: boolean
    accreditationDocument?: boolean
    taxIdentificationNumber?: boolean
    licenseDocument?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolVerification"]>

  export type SchoolVerificationSelectScalar = {
    id?: boolean
    schoolId?: boolean
    cacCertificate?: boolean
    accreditationDocument?: boolean
    taxIdentificationNumber?: boolean
    licenseDocument?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolVerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "schoolId" | "cacCertificate" | "accreditationDocument" | "taxIdentificationNumber" | "licenseDocument" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["schoolVerification"]>
  export type SchoolVerificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type SchoolVerificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type SchoolVerificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $SchoolVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SchoolVerification"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      cacCertificate: string
      accreditationDocument: string
      taxIdentificationNumber: string
      licenseDocument: string
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schoolVerification"]>
    composites: {}
  }

  type SchoolVerificationGetPayload<S extends boolean | null | undefined | SchoolVerificationDefaultArgs> = $Result.GetResult<Prisma.$SchoolVerificationPayload, S>

  type SchoolVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SchoolVerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SchoolVerificationCountAggregateInputType | true
    }

  export interface SchoolVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SchoolVerification'], meta: { name: 'SchoolVerification' } }
    /**
     * Find zero or one SchoolVerification that matches the filter.
     * @param {SchoolVerificationFindUniqueArgs} args - Arguments to find a SchoolVerification
     * @example
     * // Get one SchoolVerification
     * const schoolVerification = await prisma.schoolVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolVerificationFindUniqueArgs>(args: SelectSubset<T, SchoolVerificationFindUniqueArgs<ExtArgs>>): Prisma__SchoolVerificationClient<$Result.GetResult<Prisma.$SchoolVerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SchoolVerification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SchoolVerificationFindUniqueOrThrowArgs} args - Arguments to find a SchoolVerification
     * @example
     * // Get one SchoolVerification
     * const schoolVerification = await prisma.schoolVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolVerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolVerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolVerificationClient<$Result.GetResult<Prisma.$SchoolVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SchoolVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolVerificationFindFirstArgs} args - Arguments to find a SchoolVerification
     * @example
     * // Get one SchoolVerification
     * const schoolVerification = await prisma.schoolVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolVerificationFindFirstArgs>(args?: SelectSubset<T, SchoolVerificationFindFirstArgs<ExtArgs>>): Prisma__SchoolVerificationClient<$Result.GetResult<Prisma.$SchoolVerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SchoolVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolVerificationFindFirstOrThrowArgs} args - Arguments to find a SchoolVerification
     * @example
     * // Get one SchoolVerification
     * const schoolVerification = await prisma.schoolVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolVerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolVerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolVerificationClient<$Result.GetResult<Prisma.$SchoolVerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SchoolVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolVerifications
     * const schoolVerifications = await prisma.schoolVerification.findMany()
     * 
     * // Get first 10 SchoolVerifications
     * const schoolVerifications = await prisma.schoolVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolVerificationWithIdOnly = await prisma.schoolVerification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolVerificationFindManyArgs>(args?: SelectSubset<T, SchoolVerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SchoolVerification.
     * @param {SchoolVerificationCreateArgs} args - Arguments to create a SchoolVerification.
     * @example
     * // Create one SchoolVerification
     * const SchoolVerification = await prisma.schoolVerification.create({
     *   data: {
     *     // ... data to create a SchoolVerification
     *   }
     * })
     * 
     */
    create<T extends SchoolVerificationCreateArgs>(args: SelectSubset<T, SchoolVerificationCreateArgs<ExtArgs>>): Prisma__SchoolVerificationClient<$Result.GetResult<Prisma.$SchoolVerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SchoolVerifications.
     * @param {SchoolVerificationCreateManyArgs} args - Arguments to create many SchoolVerifications.
     * @example
     * // Create many SchoolVerifications
     * const schoolVerification = await prisma.schoolVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolVerificationCreateManyArgs>(args?: SelectSubset<T, SchoolVerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SchoolVerifications and returns the data saved in the database.
     * @param {SchoolVerificationCreateManyAndReturnArgs} args - Arguments to create many SchoolVerifications.
     * @example
     * // Create many SchoolVerifications
     * const schoolVerification = await prisma.schoolVerification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SchoolVerifications and only return the `id`
     * const schoolVerificationWithIdOnly = await prisma.schoolVerification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolVerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolVerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolVerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SchoolVerification.
     * @param {SchoolVerificationDeleteArgs} args - Arguments to delete one SchoolVerification.
     * @example
     * // Delete one SchoolVerification
     * const SchoolVerification = await prisma.schoolVerification.delete({
     *   where: {
     *     // ... filter to delete one SchoolVerification
     *   }
     * })
     * 
     */
    delete<T extends SchoolVerificationDeleteArgs>(args: SelectSubset<T, SchoolVerificationDeleteArgs<ExtArgs>>): Prisma__SchoolVerificationClient<$Result.GetResult<Prisma.$SchoolVerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SchoolVerification.
     * @param {SchoolVerificationUpdateArgs} args - Arguments to update one SchoolVerification.
     * @example
     * // Update one SchoolVerification
     * const schoolVerification = await prisma.schoolVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolVerificationUpdateArgs>(args: SelectSubset<T, SchoolVerificationUpdateArgs<ExtArgs>>): Prisma__SchoolVerificationClient<$Result.GetResult<Prisma.$SchoolVerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SchoolVerifications.
     * @param {SchoolVerificationDeleteManyArgs} args - Arguments to filter SchoolVerifications to delete.
     * @example
     * // Delete a few SchoolVerifications
     * const { count } = await prisma.schoolVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolVerificationDeleteManyArgs>(args?: SelectSubset<T, SchoolVerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolVerifications
     * const schoolVerification = await prisma.schoolVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolVerificationUpdateManyArgs>(args: SelectSubset<T, SchoolVerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolVerifications and returns the data updated in the database.
     * @param {SchoolVerificationUpdateManyAndReturnArgs} args - Arguments to update many SchoolVerifications.
     * @example
     * // Update many SchoolVerifications
     * const schoolVerification = await prisma.schoolVerification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SchoolVerifications and only return the `id`
     * const schoolVerificationWithIdOnly = await prisma.schoolVerification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SchoolVerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, SchoolVerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolVerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SchoolVerification.
     * @param {SchoolVerificationUpsertArgs} args - Arguments to update or create a SchoolVerification.
     * @example
     * // Update or create a SchoolVerification
     * const schoolVerification = await prisma.schoolVerification.upsert({
     *   create: {
     *     // ... data to create a SchoolVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolVerification we want to update
     *   }
     * })
     */
    upsert<T extends SchoolVerificationUpsertArgs>(args: SelectSubset<T, SchoolVerificationUpsertArgs<ExtArgs>>): Prisma__SchoolVerificationClient<$Result.GetResult<Prisma.$SchoolVerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SchoolVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolVerificationCountArgs} args - Arguments to filter SchoolVerifications to count.
     * @example
     * // Count the number of SchoolVerifications
     * const count = await prisma.schoolVerification.count({
     *   where: {
     *     // ... the filter for the SchoolVerifications we want to count
     *   }
     * })
    **/
    count<T extends SchoolVerificationCountArgs>(
      args?: Subset<T, SchoolVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolVerificationAggregateArgs>(args: Subset<T, SchoolVerificationAggregateArgs>): Prisma.PrismaPromise<GetSchoolVerificationAggregateType<T>>

    /**
     * Group by SchoolVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolVerificationGroupByArgs['orderBy'] }
        : { orderBy?: SchoolVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SchoolVerification model
   */
  readonly fields: SchoolVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SchoolVerification model
   */
  interface SchoolVerificationFieldRefs {
    readonly id: FieldRef<"SchoolVerification", 'String'>
    readonly schoolId: FieldRef<"SchoolVerification", 'String'>
    readonly cacCertificate: FieldRef<"SchoolVerification", 'String'>
    readonly accreditationDocument: FieldRef<"SchoolVerification", 'String'>
    readonly taxIdentificationNumber: FieldRef<"SchoolVerification", 'String'>
    readonly licenseDocument: FieldRef<"SchoolVerification", 'String'>
    readonly isDeleted: FieldRef<"SchoolVerification", 'Boolean'>
    readonly createdAt: FieldRef<"SchoolVerification", 'DateTime'>
    readonly updatedAt: FieldRef<"SchoolVerification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SchoolVerification findUnique
   */
  export type SchoolVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolVerification
     */
    select?: SchoolVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolVerification
     */
    omit?: SchoolVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolVerificationInclude<ExtArgs> | null
    /**
     * Filter, which SchoolVerification to fetch.
     */
    where: SchoolVerificationWhereUniqueInput
  }

  /**
   * SchoolVerification findUniqueOrThrow
   */
  export type SchoolVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolVerification
     */
    select?: SchoolVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolVerification
     */
    omit?: SchoolVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolVerificationInclude<ExtArgs> | null
    /**
     * Filter, which SchoolVerification to fetch.
     */
    where: SchoolVerificationWhereUniqueInput
  }

  /**
   * SchoolVerification findFirst
   */
  export type SchoolVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolVerification
     */
    select?: SchoolVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolVerification
     */
    omit?: SchoolVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolVerificationInclude<ExtArgs> | null
    /**
     * Filter, which SchoolVerification to fetch.
     */
    where?: SchoolVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolVerifications to fetch.
     */
    orderBy?: SchoolVerificationOrderByWithRelationInput | SchoolVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolVerifications.
     */
    cursor?: SchoolVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolVerifications.
     */
    distinct?: SchoolVerificationScalarFieldEnum | SchoolVerificationScalarFieldEnum[]
  }

  /**
   * SchoolVerification findFirstOrThrow
   */
  export type SchoolVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolVerification
     */
    select?: SchoolVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolVerification
     */
    omit?: SchoolVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolVerificationInclude<ExtArgs> | null
    /**
     * Filter, which SchoolVerification to fetch.
     */
    where?: SchoolVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolVerifications to fetch.
     */
    orderBy?: SchoolVerificationOrderByWithRelationInput | SchoolVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolVerifications.
     */
    cursor?: SchoolVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolVerifications.
     */
    distinct?: SchoolVerificationScalarFieldEnum | SchoolVerificationScalarFieldEnum[]
  }

  /**
   * SchoolVerification findMany
   */
  export type SchoolVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolVerification
     */
    select?: SchoolVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolVerification
     */
    omit?: SchoolVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolVerificationInclude<ExtArgs> | null
    /**
     * Filter, which SchoolVerifications to fetch.
     */
    where?: SchoolVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolVerifications to fetch.
     */
    orderBy?: SchoolVerificationOrderByWithRelationInput | SchoolVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolVerifications.
     */
    cursor?: SchoolVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolVerifications.
     */
    skip?: number
    distinct?: SchoolVerificationScalarFieldEnum | SchoolVerificationScalarFieldEnum[]
  }

  /**
   * SchoolVerification create
   */
  export type SchoolVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolVerification
     */
    select?: SchoolVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolVerification
     */
    omit?: SchoolVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolVerificationInclude<ExtArgs> | null
    /**
     * The data needed to create a SchoolVerification.
     */
    data: XOR<SchoolVerificationCreateInput, SchoolVerificationUncheckedCreateInput>
  }

  /**
   * SchoolVerification createMany
   */
  export type SchoolVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SchoolVerifications.
     */
    data: SchoolVerificationCreateManyInput | SchoolVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SchoolVerification createManyAndReturn
   */
  export type SchoolVerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolVerification
     */
    select?: SchoolVerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolVerification
     */
    omit?: SchoolVerificationOmit<ExtArgs> | null
    /**
     * The data used to create many SchoolVerifications.
     */
    data: SchoolVerificationCreateManyInput | SchoolVerificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolVerificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolVerification update
   */
  export type SchoolVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolVerification
     */
    select?: SchoolVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolVerification
     */
    omit?: SchoolVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolVerificationInclude<ExtArgs> | null
    /**
     * The data needed to update a SchoolVerification.
     */
    data: XOR<SchoolVerificationUpdateInput, SchoolVerificationUncheckedUpdateInput>
    /**
     * Choose, which SchoolVerification to update.
     */
    where: SchoolVerificationWhereUniqueInput
  }

  /**
   * SchoolVerification updateMany
   */
  export type SchoolVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SchoolVerifications.
     */
    data: XOR<SchoolVerificationUpdateManyMutationInput, SchoolVerificationUncheckedUpdateManyInput>
    /**
     * Filter which SchoolVerifications to update
     */
    where?: SchoolVerificationWhereInput
    /**
     * Limit how many SchoolVerifications to update.
     */
    limit?: number
  }

  /**
   * SchoolVerification updateManyAndReturn
   */
  export type SchoolVerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolVerification
     */
    select?: SchoolVerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolVerification
     */
    omit?: SchoolVerificationOmit<ExtArgs> | null
    /**
     * The data used to update SchoolVerifications.
     */
    data: XOR<SchoolVerificationUpdateManyMutationInput, SchoolVerificationUncheckedUpdateManyInput>
    /**
     * Filter which SchoolVerifications to update
     */
    where?: SchoolVerificationWhereInput
    /**
     * Limit how many SchoolVerifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolVerificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolVerification upsert
   */
  export type SchoolVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolVerification
     */
    select?: SchoolVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolVerification
     */
    omit?: SchoolVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolVerificationInclude<ExtArgs> | null
    /**
     * The filter to search for the SchoolVerification to update in case it exists.
     */
    where: SchoolVerificationWhereUniqueInput
    /**
     * In case the SchoolVerification found by the `where` argument doesn't exist, create a new SchoolVerification with this data.
     */
    create: XOR<SchoolVerificationCreateInput, SchoolVerificationUncheckedCreateInput>
    /**
     * In case the SchoolVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolVerificationUpdateInput, SchoolVerificationUncheckedUpdateInput>
  }

  /**
   * SchoolVerification delete
   */
  export type SchoolVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolVerification
     */
    select?: SchoolVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolVerification
     */
    omit?: SchoolVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolVerificationInclude<ExtArgs> | null
    /**
     * Filter which SchoolVerification to delete.
     */
    where: SchoolVerificationWhereUniqueInput
  }

  /**
   * SchoolVerification deleteMany
   */
  export type SchoolVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolVerifications to delete
     */
    where?: SchoolVerificationWhereInput
    /**
     * Limit how many SchoolVerifications to delete.
     */
    limit?: number
  }

  /**
   * SchoolVerification without action
   */
  export type SchoolVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolVerification
     */
    select?: SchoolVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolVerification
     */
    omit?: SchoolVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolVerificationInclude<ExtArgs> | null
  }


  /**
   * Model SchoolPayoutDetail
   */

  export type AggregateSchoolPayoutDetail = {
    _count: SchoolPayoutDetailCountAggregateOutputType | null
    _min: SchoolPayoutDetailMinAggregateOutputType | null
    _max: SchoolPayoutDetailMaxAggregateOutputType | null
  }

  export type SchoolPayoutDetailMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    bankName: string | null
    bankCode: string | null
    accountNumber: string | null
    accountName: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolPayoutDetailMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    bankName: string | null
    bankCode: string | null
    accountNumber: string | null
    accountName: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolPayoutDetailCountAggregateOutputType = {
    id: number
    schoolId: number
    bankName: number
    bankCode: number
    accountNumber: number
    accountName: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolPayoutDetailMinAggregateInputType = {
    id?: true
    schoolId?: true
    bankName?: true
    bankCode?: true
    accountNumber?: true
    accountName?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolPayoutDetailMaxAggregateInputType = {
    id?: true
    schoolId?: true
    bankName?: true
    bankCode?: true
    accountNumber?: true
    accountName?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolPayoutDetailCountAggregateInputType = {
    id?: true
    schoolId?: true
    bankName?: true
    bankCode?: true
    accountNumber?: true
    accountName?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolPayoutDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolPayoutDetail to aggregate.
     */
    where?: SchoolPayoutDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolPayoutDetails to fetch.
     */
    orderBy?: SchoolPayoutDetailOrderByWithRelationInput | SchoolPayoutDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolPayoutDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolPayoutDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolPayoutDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolPayoutDetails
    **/
    _count?: true | SchoolPayoutDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolPayoutDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolPayoutDetailMaxAggregateInputType
  }

  export type GetSchoolPayoutDetailAggregateType<T extends SchoolPayoutDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolPayoutDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolPayoutDetail[P]>
      : GetScalarType<T[P], AggregateSchoolPayoutDetail[P]>
  }




  export type SchoolPayoutDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolPayoutDetailWhereInput
    orderBy?: SchoolPayoutDetailOrderByWithAggregationInput | SchoolPayoutDetailOrderByWithAggregationInput[]
    by: SchoolPayoutDetailScalarFieldEnum[] | SchoolPayoutDetailScalarFieldEnum
    having?: SchoolPayoutDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolPayoutDetailCountAggregateInputType | true
    _min?: SchoolPayoutDetailMinAggregateInputType
    _max?: SchoolPayoutDetailMaxAggregateInputType
  }

  export type SchoolPayoutDetailGroupByOutputType = {
    id: string
    schoolId: string
    bankName: string
    bankCode: string
    accountNumber: string
    accountName: string
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: SchoolPayoutDetailCountAggregateOutputType | null
    _min: SchoolPayoutDetailMinAggregateOutputType | null
    _max: SchoolPayoutDetailMaxAggregateOutputType | null
  }

  type GetSchoolPayoutDetailGroupByPayload<T extends SchoolPayoutDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolPayoutDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolPayoutDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolPayoutDetailGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolPayoutDetailGroupByOutputType[P]>
        }
      >
    >


  export type SchoolPayoutDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    bankName?: boolean
    bankCode?: boolean
    accountNumber?: boolean
    accountName?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolPayoutDetail"]>

  export type SchoolPayoutDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    bankName?: boolean
    bankCode?: boolean
    accountNumber?: boolean
    accountName?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolPayoutDetail"]>

  export type SchoolPayoutDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    bankName?: boolean
    bankCode?: boolean
    accountNumber?: boolean
    accountName?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolPayoutDetail"]>

  export type SchoolPayoutDetailSelectScalar = {
    id?: boolean
    schoolId?: boolean
    bankName?: boolean
    bankCode?: boolean
    accountNumber?: boolean
    accountName?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolPayoutDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "schoolId" | "bankName" | "bankCode" | "accountNumber" | "accountName" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["schoolPayoutDetail"]>
  export type SchoolPayoutDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type SchoolPayoutDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type SchoolPayoutDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $SchoolPayoutDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SchoolPayoutDetail"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      bankName: string
      bankCode: string
      accountNumber: string
      accountName: string
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schoolPayoutDetail"]>
    composites: {}
  }

  type SchoolPayoutDetailGetPayload<S extends boolean | null | undefined | SchoolPayoutDetailDefaultArgs> = $Result.GetResult<Prisma.$SchoolPayoutDetailPayload, S>

  type SchoolPayoutDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SchoolPayoutDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SchoolPayoutDetailCountAggregateInputType | true
    }

  export interface SchoolPayoutDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SchoolPayoutDetail'], meta: { name: 'SchoolPayoutDetail' } }
    /**
     * Find zero or one SchoolPayoutDetail that matches the filter.
     * @param {SchoolPayoutDetailFindUniqueArgs} args - Arguments to find a SchoolPayoutDetail
     * @example
     * // Get one SchoolPayoutDetail
     * const schoolPayoutDetail = await prisma.schoolPayoutDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolPayoutDetailFindUniqueArgs>(args: SelectSubset<T, SchoolPayoutDetailFindUniqueArgs<ExtArgs>>): Prisma__SchoolPayoutDetailClient<$Result.GetResult<Prisma.$SchoolPayoutDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SchoolPayoutDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SchoolPayoutDetailFindUniqueOrThrowArgs} args - Arguments to find a SchoolPayoutDetail
     * @example
     * // Get one SchoolPayoutDetail
     * const schoolPayoutDetail = await prisma.schoolPayoutDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolPayoutDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolPayoutDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolPayoutDetailClient<$Result.GetResult<Prisma.$SchoolPayoutDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SchoolPayoutDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolPayoutDetailFindFirstArgs} args - Arguments to find a SchoolPayoutDetail
     * @example
     * // Get one SchoolPayoutDetail
     * const schoolPayoutDetail = await prisma.schoolPayoutDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolPayoutDetailFindFirstArgs>(args?: SelectSubset<T, SchoolPayoutDetailFindFirstArgs<ExtArgs>>): Prisma__SchoolPayoutDetailClient<$Result.GetResult<Prisma.$SchoolPayoutDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SchoolPayoutDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolPayoutDetailFindFirstOrThrowArgs} args - Arguments to find a SchoolPayoutDetail
     * @example
     * // Get one SchoolPayoutDetail
     * const schoolPayoutDetail = await prisma.schoolPayoutDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolPayoutDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolPayoutDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolPayoutDetailClient<$Result.GetResult<Prisma.$SchoolPayoutDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SchoolPayoutDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolPayoutDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolPayoutDetails
     * const schoolPayoutDetails = await prisma.schoolPayoutDetail.findMany()
     * 
     * // Get first 10 SchoolPayoutDetails
     * const schoolPayoutDetails = await prisma.schoolPayoutDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolPayoutDetailWithIdOnly = await prisma.schoolPayoutDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolPayoutDetailFindManyArgs>(args?: SelectSubset<T, SchoolPayoutDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayoutDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SchoolPayoutDetail.
     * @param {SchoolPayoutDetailCreateArgs} args - Arguments to create a SchoolPayoutDetail.
     * @example
     * // Create one SchoolPayoutDetail
     * const SchoolPayoutDetail = await prisma.schoolPayoutDetail.create({
     *   data: {
     *     // ... data to create a SchoolPayoutDetail
     *   }
     * })
     * 
     */
    create<T extends SchoolPayoutDetailCreateArgs>(args: SelectSubset<T, SchoolPayoutDetailCreateArgs<ExtArgs>>): Prisma__SchoolPayoutDetailClient<$Result.GetResult<Prisma.$SchoolPayoutDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SchoolPayoutDetails.
     * @param {SchoolPayoutDetailCreateManyArgs} args - Arguments to create many SchoolPayoutDetails.
     * @example
     * // Create many SchoolPayoutDetails
     * const schoolPayoutDetail = await prisma.schoolPayoutDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolPayoutDetailCreateManyArgs>(args?: SelectSubset<T, SchoolPayoutDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SchoolPayoutDetails and returns the data saved in the database.
     * @param {SchoolPayoutDetailCreateManyAndReturnArgs} args - Arguments to create many SchoolPayoutDetails.
     * @example
     * // Create many SchoolPayoutDetails
     * const schoolPayoutDetail = await prisma.schoolPayoutDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SchoolPayoutDetails and only return the `id`
     * const schoolPayoutDetailWithIdOnly = await prisma.schoolPayoutDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolPayoutDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolPayoutDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayoutDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SchoolPayoutDetail.
     * @param {SchoolPayoutDetailDeleteArgs} args - Arguments to delete one SchoolPayoutDetail.
     * @example
     * // Delete one SchoolPayoutDetail
     * const SchoolPayoutDetail = await prisma.schoolPayoutDetail.delete({
     *   where: {
     *     // ... filter to delete one SchoolPayoutDetail
     *   }
     * })
     * 
     */
    delete<T extends SchoolPayoutDetailDeleteArgs>(args: SelectSubset<T, SchoolPayoutDetailDeleteArgs<ExtArgs>>): Prisma__SchoolPayoutDetailClient<$Result.GetResult<Prisma.$SchoolPayoutDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SchoolPayoutDetail.
     * @param {SchoolPayoutDetailUpdateArgs} args - Arguments to update one SchoolPayoutDetail.
     * @example
     * // Update one SchoolPayoutDetail
     * const schoolPayoutDetail = await prisma.schoolPayoutDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolPayoutDetailUpdateArgs>(args: SelectSubset<T, SchoolPayoutDetailUpdateArgs<ExtArgs>>): Prisma__SchoolPayoutDetailClient<$Result.GetResult<Prisma.$SchoolPayoutDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SchoolPayoutDetails.
     * @param {SchoolPayoutDetailDeleteManyArgs} args - Arguments to filter SchoolPayoutDetails to delete.
     * @example
     * // Delete a few SchoolPayoutDetails
     * const { count } = await prisma.schoolPayoutDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolPayoutDetailDeleteManyArgs>(args?: SelectSubset<T, SchoolPayoutDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolPayoutDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolPayoutDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolPayoutDetails
     * const schoolPayoutDetail = await prisma.schoolPayoutDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolPayoutDetailUpdateManyArgs>(args: SelectSubset<T, SchoolPayoutDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolPayoutDetails and returns the data updated in the database.
     * @param {SchoolPayoutDetailUpdateManyAndReturnArgs} args - Arguments to update many SchoolPayoutDetails.
     * @example
     * // Update many SchoolPayoutDetails
     * const schoolPayoutDetail = await prisma.schoolPayoutDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SchoolPayoutDetails and only return the `id`
     * const schoolPayoutDetailWithIdOnly = await prisma.schoolPayoutDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SchoolPayoutDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, SchoolPayoutDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolPayoutDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SchoolPayoutDetail.
     * @param {SchoolPayoutDetailUpsertArgs} args - Arguments to update or create a SchoolPayoutDetail.
     * @example
     * // Update or create a SchoolPayoutDetail
     * const schoolPayoutDetail = await prisma.schoolPayoutDetail.upsert({
     *   create: {
     *     // ... data to create a SchoolPayoutDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolPayoutDetail we want to update
     *   }
     * })
     */
    upsert<T extends SchoolPayoutDetailUpsertArgs>(args: SelectSubset<T, SchoolPayoutDetailUpsertArgs<ExtArgs>>): Prisma__SchoolPayoutDetailClient<$Result.GetResult<Prisma.$SchoolPayoutDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SchoolPayoutDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolPayoutDetailCountArgs} args - Arguments to filter SchoolPayoutDetails to count.
     * @example
     * // Count the number of SchoolPayoutDetails
     * const count = await prisma.schoolPayoutDetail.count({
     *   where: {
     *     // ... the filter for the SchoolPayoutDetails we want to count
     *   }
     * })
    **/
    count<T extends SchoolPayoutDetailCountArgs>(
      args?: Subset<T, SchoolPayoutDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolPayoutDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolPayoutDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolPayoutDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolPayoutDetailAggregateArgs>(args: Subset<T, SchoolPayoutDetailAggregateArgs>): Prisma.PrismaPromise<GetSchoolPayoutDetailAggregateType<T>>

    /**
     * Group by SchoolPayoutDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolPayoutDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolPayoutDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolPayoutDetailGroupByArgs['orderBy'] }
        : { orderBy?: SchoolPayoutDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolPayoutDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolPayoutDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SchoolPayoutDetail model
   */
  readonly fields: SchoolPayoutDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolPayoutDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolPayoutDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SchoolPayoutDetail model
   */
  interface SchoolPayoutDetailFieldRefs {
    readonly id: FieldRef<"SchoolPayoutDetail", 'String'>
    readonly schoolId: FieldRef<"SchoolPayoutDetail", 'String'>
    readonly bankName: FieldRef<"SchoolPayoutDetail", 'String'>
    readonly bankCode: FieldRef<"SchoolPayoutDetail", 'String'>
    readonly accountNumber: FieldRef<"SchoolPayoutDetail", 'String'>
    readonly accountName: FieldRef<"SchoolPayoutDetail", 'String'>
    readonly isDeleted: FieldRef<"SchoolPayoutDetail", 'Boolean'>
    readonly createdAt: FieldRef<"SchoolPayoutDetail", 'DateTime'>
    readonly updatedAt: FieldRef<"SchoolPayoutDetail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SchoolPayoutDetail findUnique
   */
  export type SchoolPayoutDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolPayoutDetail
     */
    select?: SchoolPayoutDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolPayoutDetail
     */
    omit?: SchoolPayoutDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolPayoutDetailInclude<ExtArgs> | null
    /**
     * Filter, which SchoolPayoutDetail to fetch.
     */
    where: SchoolPayoutDetailWhereUniqueInput
  }

  /**
   * SchoolPayoutDetail findUniqueOrThrow
   */
  export type SchoolPayoutDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolPayoutDetail
     */
    select?: SchoolPayoutDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolPayoutDetail
     */
    omit?: SchoolPayoutDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolPayoutDetailInclude<ExtArgs> | null
    /**
     * Filter, which SchoolPayoutDetail to fetch.
     */
    where: SchoolPayoutDetailWhereUniqueInput
  }

  /**
   * SchoolPayoutDetail findFirst
   */
  export type SchoolPayoutDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolPayoutDetail
     */
    select?: SchoolPayoutDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolPayoutDetail
     */
    omit?: SchoolPayoutDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolPayoutDetailInclude<ExtArgs> | null
    /**
     * Filter, which SchoolPayoutDetail to fetch.
     */
    where?: SchoolPayoutDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolPayoutDetails to fetch.
     */
    orderBy?: SchoolPayoutDetailOrderByWithRelationInput | SchoolPayoutDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolPayoutDetails.
     */
    cursor?: SchoolPayoutDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolPayoutDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolPayoutDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolPayoutDetails.
     */
    distinct?: SchoolPayoutDetailScalarFieldEnum | SchoolPayoutDetailScalarFieldEnum[]
  }

  /**
   * SchoolPayoutDetail findFirstOrThrow
   */
  export type SchoolPayoutDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolPayoutDetail
     */
    select?: SchoolPayoutDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolPayoutDetail
     */
    omit?: SchoolPayoutDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolPayoutDetailInclude<ExtArgs> | null
    /**
     * Filter, which SchoolPayoutDetail to fetch.
     */
    where?: SchoolPayoutDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolPayoutDetails to fetch.
     */
    orderBy?: SchoolPayoutDetailOrderByWithRelationInput | SchoolPayoutDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolPayoutDetails.
     */
    cursor?: SchoolPayoutDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolPayoutDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolPayoutDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolPayoutDetails.
     */
    distinct?: SchoolPayoutDetailScalarFieldEnum | SchoolPayoutDetailScalarFieldEnum[]
  }

  /**
   * SchoolPayoutDetail findMany
   */
  export type SchoolPayoutDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolPayoutDetail
     */
    select?: SchoolPayoutDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolPayoutDetail
     */
    omit?: SchoolPayoutDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolPayoutDetailInclude<ExtArgs> | null
    /**
     * Filter, which SchoolPayoutDetails to fetch.
     */
    where?: SchoolPayoutDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolPayoutDetails to fetch.
     */
    orderBy?: SchoolPayoutDetailOrderByWithRelationInput | SchoolPayoutDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolPayoutDetails.
     */
    cursor?: SchoolPayoutDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolPayoutDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolPayoutDetails.
     */
    skip?: number
    distinct?: SchoolPayoutDetailScalarFieldEnum | SchoolPayoutDetailScalarFieldEnum[]
  }

  /**
   * SchoolPayoutDetail create
   */
  export type SchoolPayoutDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolPayoutDetail
     */
    select?: SchoolPayoutDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolPayoutDetail
     */
    omit?: SchoolPayoutDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolPayoutDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a SchoolPayoutDetail.
     */
    data: XOR<SchoolPayoutDetailCreateInput, SchoolPayoutDetailUncheckedCreateInput>
  }

  /**
   * SchoolPayoutDetail createMany
   */
  export type SchoolPayoutDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SchoolPayoutDetails.
     */
    data: SchoolPayoutDetailCreateManyInput | SchoolPayoutDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SchoolPayoutDetail createManyAndReturn
   */
  export type SchoolPayoutDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolPayoutDetail
     */
    select?: SchoolPayoutDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolPayoutDetail
     */
    omit?: SchoolPayoutDetailOmit<ExtArgs> | null
    /**
     * The data used to create many SchoolPayoutDetails.
     */
    data: SchoolPayoutDetailCreateManyInput | SchoolPayoutDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolPayoutDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolPayoutDetail update
   */
  export type SchoolPayoutDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolPayoutDetail
     */
    select?: SchoolPayoutDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolPayoutDetail
     */
    omit?: SchoolPayoutDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolPayoutDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a SchoolPayoutDetail.
     */
    data: XOR<SchoolPayoutDetailUpdateInput, SchoolPayoutDetailUncheckedUpdateInput>
    /**
     * Choose, which SchoolPayoutDetail to update.
     */
    where: SchoolPayoutDetailWhereUniqueInput
  }

  /**
   * SchoolPayoutDetail updateMany
   */
  export type SchoolPayoutDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SchoolPayoutDetails.
     */
    data: XOR<SchoolPayoutDetailUpdateManyMutationInput, SchoolPayoutDetailUncheckedUpdateManyInput>
    /**
     * Filter which SchoolPayoutDetails to update
     */
    where?: SchoolPayoutDetailWhereInput
    /**
     * Limit how many SchoolPayoutDetails to update.
     */
    limit?: number
  }

  /**
   * SchoolPayoutDetail updateManyAndReturn
   */
  export type SchoolPayoutDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolPayoutDetail
     */
    select?: SchoolPayoutDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolPayoutDetail
     */
    omit?: SchoolPayoutDetailOmit<ExtArgs> | null
    /**
     * The data used to update SchoolPayoutDetails.
     */
    data: XOR<SchoolPayoutDetailUpdateManyMutationInput, SchoolPayoutDetailUncheckedUpdateManyInput>
    /**
     * Filter which SchoolPayoutDetails to update
     */
    where?: SchoolPayoutDetailWhereInput
    /**
     * Limit how many SchoolPayoutDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolPayoutDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolPayoutDetail upsert
   */
  export type SchoolPayoutDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolPayoutDetail
     */
    select?: SchoolPayoutDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolPayoutDetail
     */
    omit?: SchoolPayoutDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolPayoutDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the SchoolPayoutDetail to update in case it exists.
     */
    where: SchoolPayoutDetailWhereUniqueInput
    /**
     * In case the SchoolPayoutDetail found by the `where` argument doesn't exist, create a new SchoolPayoutDetail with this data.
     */
    create: XOR<SchoolPayoutDetailCreateInput, SchoolPayoutDetailUncheckedCreateInput>
    /**
     * In case the SchoolPayoutDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolPayoutDetailUpdateInput, SchoolPayoutDetailUncheckedUpdateInput>
  }

  /**
   * SchoolPayoutDetail delete
   */
  export type SchoolPayoutDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolPayoutDetail
     */
    select?: SchoolPayoutDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolPayoutDetail
     */
    omit?: SchoolPayoutDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolPayoutDetailInclude<ExtArgs> | null
    /**
     * Filter which SchoolPayoutDetail to delete.
     */
    where: SchoolPayoutDetailWhereUniqueInput
  }

  /**
   * SchoolPayoutDetail deleteMany
   */
  export type SchoolPayoutDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolPayoutDetails to delete
     */
    where?: SchoolPayoutDetailWhereInput
    /**
     * Limit how many SchoolPayoutDetails to delete.
     */
    limit?: number
  }

  /**
   * SchoolPayoutDetail without action
   */
  export type SchoolPayoutDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolPayoutDetail
     */
    select?: SchoolPayoutDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolPayoutDetail
     */
    omit?: SchoolPayoutDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolPayoutDetailInclude<ExtArgs> | null
  }


  /**
   * Model SchoolAndPlatformLegalAgreement
   */

  export type AggregateSchoolAndPlatformLegalAgreement = {
    _count: SchoolAndPlatformLegalAgreementCountAggregateOutputType | null
    _min: SchoolAndPlatformLegalAgreementMinAggregateOutputType | null
    _max: SchoolAndPlatformLegalAgreementMaxAggregateOutputType | null
  }

  export type SchoolAndPlatformLegalAgreementMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    signedById: string | null
    signature: string | null
    signedAt: Date | null
    legalDocumentRef: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolAndPlatformLegalAgreementMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    signedById: string | null
    signature: string | null
    signedAt: Date | null
    legalDocumentRef: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolAndPlatformLegalAgreementCountAggregateOutputType = {
    id: number
    schoolId: number
    signedById: number
    signature: number
    signedAt: number
    legalDocumentRef: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolAndPlatformLegalAgreementMinAggregateInputType = {
    id?: true
    schoolId?: true
    signedById?: true
    signature?: true
    signedAt?: true
    legalDocumentRef?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolAndPlatformLegalAgreementMaxAggregateInputType = {
    id?: true
    schoolId?: true
    signedById?: true
    signature?: true
    signedAt?: true
    legalDocumentRef?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolAndPlatformLegalAgreementCountAggregateInputType = {
    id?: true
    schoolId?: true
    signedById?: true
    signature?: true
    signedAt?: true
    legalDocumentRef?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolAndPlatformLegalAgreementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolAndPlatformLegalAgreement to aggregate.
     */
    where?: SchoolAndPlatformLegalAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolAndPlatformLegalAgreements to fetch.
     */
    orderBy?: SchoolAndPlatformLegalAgreementOrderByWithRelationInput | SchoolAndPlatformLegalAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolAndPlatformLegalAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolAndPlatformLegalAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolAndPlatformLegalAgreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolAndPlatformLegalAgreements
    **/
    _count?: true | SchoolAndPlatformLegalAgreementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolAndPlatformLegalAgreementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolAndPlatformLegalAgreementMaxAggregateInputType
  }

  export type GetSchoolAndPlatformLegalAgreementAggregateType<T extends SchoolAndPlatformLegalAgreementAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolAndPlatformLegalAgreement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolAndPlatformLegalAgreement[P]>
      : GetScalarType<T[P], AggregateSchoolAndPlatformLegalAgreement[P]>
  }




  export type SchoolAndPlatformLegalAgreementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolAndPlatformLegalAgreementWhereInput
    orderBy?: SchoolAndPlatformLegalAgreementOrderByWithAggregationInput | SchoolAndPlatformLegalAgreementOrderByWithAggregationInput[]
    by: SchoolAndPlatformLegalAgreementScalarFieldEnum[] | SchoolAndPlatformLegalAgreementScalarFieldEnum
    having?: SchoolAndPlatformLegalAgreementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolAndPlatformLegalAgreementCountAggregateInputType | true
    _min?: SchoolAndPlatformLegalAgreementMinAggregateInputType
    _max?: SchoolAndPlatformLegalAgreementMaxAggregateInputType
  }

  export type SchoolAndPlatformLegalAgreementGroupByOutputType = {
    id: string
    schoolId: string
    signedById: string
    signature: string
    signedAt: Date
    legalDocumentRef: string
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: SchoolAndPlatformLegalAgreementCountAggregateOutputType | null
    _min: SchoolAndPlatformLegalAgreementMinAggregateOutputType | null
    _max: SchoolAndPlatformLegalAgreementMaxAggregateOutputType | null
  }

  type GetSchoolAndPlatformLegalAgreementGroupByPayload<T extends SchoolAndPlatformLegalAgreementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolAndPlatformLegalAgreementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolAndPlatformLegalAgreementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolAndPlatformLegalAgreementGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolAndPlatformLegalAgreementGroupByOutputType[P]>
        }
      >
    >


  export type SchoolAndPlatformLegalAgreementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    signedById?: boolean
    signature?: boolean
    signedAt?: boolean
    legalDocumentRef?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    signedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolAndPlatformLegalAgreement"]>

  export type SchoolAndPlatformLegalAgreementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    signedById?: boolean
    signature?: boolean
    signedAt?: boolean
    legalDocumentRef?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    signedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolAndPlatformLegalAgreement"]>

  export type SchoolAndPlatformLegalAgreementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    signedById?: boolean
    signature?: boolean
    signedAt?: boolean
    legalDocumentRef?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    signedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolAndPlatformLegalAgreement"]>

  export type SchoolAndPlatformLegalAgreementSelectScalar = {
    id?: boolean
    schoolId?: boolean
    signedById?: boolean
    signature?: boolean
    signedAt?: boolean
    legalDocumentRef?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolAndPlatformLegalAgreementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "schoolId" | "signedById" | "signature" | "signedAt" | "legalDocumentRef" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["schoolAndPlatformLegalAgreement"]>
  export type SchoolAndPlatformLegalAgreementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    signedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SchoolAndPlatformLegalAgreementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    signedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SchoolAndPlatformLegalAgreementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    signedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SchoolAndPlatformLegalAgreementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SchoolAndPlatformLegalAgreement"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      signedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      signedById: string
      signature: string
      signedAt: Date
      legalDocumentRef: string
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schoolAndPlatformLegalAgreement"]>
    composites: {}
  }

  type SchoolAndPlatformLegalAgreementGetPayload<S extends boolean | null | undefined | SchoolAndPlatformLegalAgreementDefaultArgs> = $Result.GetResult<Prisma.$SchoolAndPlatformLegalAgreementPayload, S>

  type SchoolAndPlatformLegalAgreementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SchoolAndPlatformLegalAgreementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SchoolAndPlatformLegalAgreementCountAggregateInputType | true
    }

  export interface SchoolAndPlatformLegalAgreementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SchoolAndPlatformLegalAgreement'], meta: { name: 'SchoolAndPlatformLegalAgreement' } }
    /**
     * Find zero or one SchoolAndPlatformLegalAgreement that matches the filter.
     * @param {SchoolAndPlatformLegalAgreementFindUniqueArgs} args - Arguments to find a SchoolAndPlatformLegalAgreement
     * @example
     * // Get one SchoolAndPlatformLegalAgreement
     * const schoolAndPlatformLegalAgreement = await prisma.schoolAndPlatformLegalAgreement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolAndPlatformLegalAgreementFindUniqueArgs>(args: SelectSubset<T, SchoolAndPlatformLegalAgreementFindUniqueArgs<ExtArgs>>): Prisma__SchoolAndPlatformLegalAgreementClient<$Result.GetResult<Prisma.$SchoolAndPlatformLegalAgreementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SchoolAndPlatformLegalAgreement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SchoolAndPlatformLegalAgreementFindUniqueOrThrowArgs} args - Arguments to find a SchoolAndPlatformLegalAgreement
     * @example
     * // Get one SchoolAndPlatformLegalAgreement
     * const schoolAndPlatformLegalAgreement = await prisma.schoolAndPlatformLegalAgreement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolAndPlatformLegalAgreementFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolAndPlatformLegalAgreementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolAndPlatformLegalAgreementClient<$Result.GetResult<Prisma.$SchoolAndPlatformLegalAgreementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SchoolAndPlatformLegalAgreement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAndPlatformLegalAgreementFindFirstArgs} args - Arguments to find a SchoolAndPlatformLegalAgreement
     * @example
     * // Get one SchoolAndPlatformLegalAgreement
     * const schoolAndPlatformLegalAgreement = await prisma.schoolAndPlatformLegalAgreement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolAndPlatformLegalAgreementFindFirstArgs>(args?: SelectSubset<T, SchoolAndPlatformLegalAgreementFindFirstArgs<ExtArgs>>): Prisma__SchoolAndPlatformLegalAgreementClient<$Result.GetResult<Prisma.$SchoolAndPlatformLegalAgreementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SchoolAndPlatformLegalAgreement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAndPlatformLegalAgreementFindFirstOrThrowArgs} args - Arguments to find a SchoolAndPlatformLegalAgreement
     * @example
     * // Get one SchoolAndPlatformLegalAgreement
     * const schoolAndPlatformLegalAgreement = await prisma.schoolAndPlatformLegalAgreement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolAndPlatformLegalAgreementFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolAndPlatformLegalAgreementFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolAndPlatformLegalAgreementClient<$Result.GetResult<Prisma.$SchoolAndPlatformLegalAgreementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SchoolAndPlatformLegalAgreements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAndPlatformLegalAgreementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolAndPlatformLegalAgreements
     * const schoolAndPlatformLegalAgreements = await prisma.schoolAndPlatformLegalAgreement.findMany()
     * 
     * // Get first 10 SchoolAndPlatformLegalAgreements
     * const schoolAndPlatformLegalAgreements = await prisma.schoolAndPlatformLegalAgreement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolAndPlatformLegalAgreementWithIdOnly = await prisma.schoolAndPlatformLegalAgreement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolAndPlatformLegalAgreementFindManyArgs>(args?: SelectSubset<T, SchoolAndPlatformLegalAgreementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolAndPlatformLegalAgreementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SchoolAndPlatformLegalAgreement.
     * @param {SchoolAndPlatformLegalAgreementCreateArgs} args - Arguments to create a SchoolAndPlatformLegalAgreement.
     * @example
     * // Create one SchoolAndPlatformLegalAgreement
     * const SchoolAndPlatformLegalAgreement = await prisma.schoolAndPlatformLegalAgreement.create({
     *   data: {
     *     // ... data to create a SchoolAndPlatformLegalAgreement
     *   }
     * })
     * 
     */
    create<T extends SchoolAndPlatformLegalAgreementCreateArgs>(args: SelectSubset<T, SchoolAndPlatformLegalAgreementCreateArgs<ExtArgs>>): Prisma__SchoolAndPlatformLegalAgreementClient<$Result.GetResult<Prisma.$SchoolAndPlatformLegalAgreementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SchoolAndPlatformLegalAgreements.
     * @param {SchoolAndPlatformLegalAgreementCreateManyArgs} args - Arguments to create many SchoolAndPlatformLegalAgreements.
     * @example
     * // Create many SchoolAndPlatformLegalAgreements
     * const schoolAndPlatformLegalAgreement = await prisma.schoolAndPlatformLegalAgreement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolAndPlatformLegalAgreementCreateManyArgs>(args?: SelectSubset<T, SchoolAndPlatformLegalAgreementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SchoolAndPlatformLegalAgreements and returns the data saved in the database.
     * @param {SchoolAndPlatformLegalAgreementCreateManyAndReturnArgs} args - Arguments to create many SchoolAndPlatformLegalAgreements.
     * @example
     * // Create many SchoolAndPlatformLegalAgreements
     * const schoolAndPlatformLegalAgreement = await prisma.schoolAndPlatformLegalAgreement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SchoolAndPlatformLegalAgreements and only return the `id`
     * const schoolAndPlatformLegalAgreementWithIdOnly = await prisma.schoolAndPlatformLegalAgreement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolAndPlatformLegalAgreementCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolAndPlatformLegalAgreementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolAndPlatformLegalAgreementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SchoolAndPlatformLegalAgreement.
     * @param {SchoolAndPlatformLegalAgreementDeleteArgs} args - Arguments to delete one SchoolAndPlatformLegalAgreement.
     * @example
     * // Delete one SchoolAndPlatformLegalAgreement
     * const SchoolAndPlatformLegalAgreement = await prisma.schoolAndPlatformLegalAgreement.delete({
     *   where: {
     *     // ... filter to delete one SchoolAndPlatformLegalAgreement
     *   }
     * })
     * 
     */
    delete<T extends SchoolAndPlatformLegalAgreementDeleteArgs>(args: SelectSubset<T, SchoolAndPlatformLegalAgreementDeleteArgs<ExtArgs>>): Prisma__SchoolAndPlatformLegalAgreementClient<$Result.GetResult<Prisma.$SchoolAndPlatformLegalAgreementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SchoolAndPlatformLegalAgreement.
     * @param {SchoolAndPlatformLegalAgreementUpdateArgs} args - Arguments to update one SchoolAndPlatformLegalAgreement.
     * @example
     * // Update one SchoolAndPlatformLegalAgreement
     * const schoolAndPlatformLegalAgreement = await prisma.schoolAndPlatformLegalAgreement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolAndPlatformLegalAgreementUpdateArgs>(args: SelectSubset<T, SchoolAndPlatformLegalAgreementUpdateArgs<ExtArgs>>): Prisma__SchoolAndPlatformLegalAgreementClient<$Result.GetResult<Prisma.$SchoolAndPlatformLegalAgreementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SchoolAndPlatformLegalAgreements.
     * @param {SchoolAndPlatformLegalAgreementDeleteManyArgs} args - Arguments to filter SchoolAndPlatformLegalAgreements to delete.
     * @example
     * // Delete a few SchoolAndPlatformLegalAgreements
     * const { count } = await prisma.schoolAndPlatformLegalAgreement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolAndPlatformLegalAgreementDeleteManyArgs>(args?: SelectSubset<T, SchoolAndPlatformLegalAgreementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolAndPlatformLegalAgreements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAndPlatformLegalAgreementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolAndPlatformLegalAgreements
     * const schoolAndPlatformLegalAgreement = await prisma.schoolAndPlatformLegalAgreement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolAndPlatformLegalAgreementUpdateManyArgs>(args: SelectSubset<T, SchoolAndPlatformLegalAgreementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolAndPlatformLegalAgreements and returns the data updated in the database.
     * @param {SchoolAndPlatformLegalAgreementUpdateManyAndReturnArgs} args - Arguments to update many SchoolAndPlatformLegalAgreements.
     * @example
     * // Update many SchoolAndPlatformLegalAgreements
     * const schoolAndPlatformLegalAgreement = await prisma.schoolAndPlatformLegalAgreement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SchoolAndPlatformLegalAgreements and only return the `id`
     * const schoolAndPlatformLegalAgreementWithIdOnly = await prisma.schoolAndPlatformLegalAgreement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SchoolAndPlatformLegalAgreementUpdateManyAndReturnArgs>(args: SelectSubset<T, SchoolAndPlatformLegalAgreementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolAndPlatformLegalAgreementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SchoolAndPlatformLegalAgreement.
     * @param {SchoolAndPlatformLegalAgreementUpsertArgs} args - Arguments to update or create a SchoolAndPlatformLegalAgreement.
     * @example
     * // Update or create a SchoolAndPlatformLegalAgreement
     * const schoolAndPlatformLegalAgreement = await prisma.schoolAndPlatformLegalAgreement.upsert({
     *   create: {
     *     // ... data to create a SchoolAndPlatformLegalAgreement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolAndPlatformLegalAgreement we want to update
     *   }
     * })
     */
    upsert<T extends SchoolAndPlatformLegalAgreementUpsertArgs>(args: SelectSubset<T, SchoolAndPlatformLegalAgreementUpsertArgs<ExtArgs>>): Prisma__SchoolAndPlatformLegalAgreementClient<$Result.GetResult<Prisma.$SchoolAndPlatformLegalAgreementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SchoolAndPlatformLegalAgreements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAndPlatformLegalAgreementCountArgs} args - Arguments to filter SchoolAndPlatformLegalAgreements to count.
     * @example
     * // Count the number of SchoolAndPlatformLegalAgreements
     * const count = await prisma.schoolAndPlatformLegalAgreement.count({
     *   where: {
     *     // ... the filter for the SchoolAndPlatformLegalAgreements we want to count
     *   }
     * })
    **/
    count<T extends SchoolAndPlatformLegalAgreementCountArgs>(
      args?: Subset<T, SchoolAndPlatformLegalAgreementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolAndPlatformLegalAgreementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolAndPlatformLegalAgreement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAndPlatformLegalAgreementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolAndPlatformLegalAgreementAggregateArgs>(args: Subset<T, SchoolAndPlatformLegalAgreementAggregateArgs>): Prisma.PrismaPromise<GetSchoolAndPlatformLegalAgreementAggregateType<T>>

    /**
     * Group by SchoolAndPlatformLegalAgreement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAndPlatformLegalAgreementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolAndPlatformLegalAgreementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolAndPlatformLegalAgreementGroupByArgs['orderBy'] }
        : { orderBy?: SchoolAndPlatformLegalAgreementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolAndPlatformLegalAgreementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolAndPlatformLegalAgreementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SchoolAndPlatformLegalAgreement model
   */
  readonly fields: SchoolAndPlatformLegalAgreementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolAndPlatformLegalAgreement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolAndPlatformLegalAgreementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    signedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SchoolAndPlatformLegalAgreement model
   */
  interface SchoolAndPlatformLegalAgreementFieldRefs {
    readonly id: FieldRef<"SchoolAndPlatformLegalAgreement", 'String'>
    readonly schoolId: FieldRef<"SchoolAndPlatformLegalAgreement", 'String'>
    readonly signedById: FieldRef<"SchoolAndPlatformLegalAgreement", 'String'>
    readonly signature: FieldRef<"SchoolAndPlatformLegalAgreement", 'String'>
    readonly signedAt: FieldRef<"SchoolAndPlatformLegalAgreement", 'DateTime'>
    readonly legalDocumentRef: FieldRef<"SchoolAndPlatformLegalAgreement", 'String'>
    readonly isDeleted: FieldRef<"SchoolAndPlatformLegalAgreement", 'Boolean'>
    readonly createdAt: FieldRef<"SchoolAndPlatformLegalAgreement", 'DateTime'>
    readonly updatedAt: FieldRef<"SchoolAndPlatformLegalAgreement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SchoolAndPlatformLegalAgreement findUnique
   */
  export type SchoolAndPlatformLegalAgreementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAndPlatformLegalAgreement
     */
    select?: SchoolAndPlatformLegalAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAndPlatformLegalAgreement
     */
    omit?: SchoolAndPlatformLegalAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAndPlatformLegalAgreementInclude<ExtArgs> | null
    /**
     * Filter, which SchoolAndPlatformLegalAgreement to fetch.
     */
    where: SchoolAndPlatformLegalAgreementWhereUniqueInput
  }

  /**
   * SchoolAndPlatformLegalAgreement findUniqueOrThrow
   */
  export type SchoolAndPlatformLegalAgreementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAndPlatformLegalAgreement
     */
    select?: SchoolAndPlatformLegalAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAndPlatformLegalAgreement
     */
    omit?: SchoolAndPlatformLegalAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAndPlatformLegalAgreementInclude<ExtArgs> | null
    /**
     * Filter, which SchoolAndPlatformLegalAgreement to fetch.
     */
    where: SchoolAndPlatformLegalAgreementWhereUniqueInput
  }

  /**
   * SchoolAndPlatformLegalAgreement findFirst
   */
  export type SchoolAndPlatformLegalAgreementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAndPlatformLegalAgreement
     */
    select?: SchoolAndPlatformLegalAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAndPlatformLegalAgreement
     */
    omit?: SchoolAndPlatformLegalAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAndPlatformLegalAgreementInclude<ExtArgs> | null
    /**
     * Filter, which SchoolAndPlatformLegalAgreement to fetch.
     */
    where?: SchoolAndPlatformLegalAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolAndPlatformLegalAgreements to fetch.
     */
    orderBy?: SchoolAndPlatformLegalAgreementOrderByWithRelationInput | SchoolAndPlatformLegalAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolAndPlatformLegalAgreements.
     */
    cursor?: SchoolAndPlatformLegalAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolAndPlatformLegalAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolAndPlatformLegalAgreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolAndPlatformLegalAgreements.
     */
    distinct?: SchoolAndPlatformLegalAgreementScalarFieldEnum | SchoolAndPlatformLegalAgreementScalarFieldEnum[]
  }

  /**
   * SchoolAndPlatformLegalAgreement findFirstOrThrow
   */
  export type SchoolAndPlatformLegalAgreementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAndPlatformLegalAgreement
     */
    select?: SchoolAndPlatformLegalAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAndPlatformLegalAgreement
     */
    omit?: SchoolAndPlatformLegalAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAndPlatformLegalAgreementInclude<ExtArgs> | null
    /**
     * Filter, which SchoolAndPlatformLegalAgreement to fetch.
     */
    where?: SchoolAndPlatformLegalAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolAndPlatformLegalAgreements to fetch.
     */
    orderBy?: SchoolAndPlatformLegalAgreementOrderByWithRelationInput | SchoolAndPlatformLegalAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolAndPlatformLegalAgreements.
     */
    cursor?: SchoolAndPlatformLegalAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolAndPlatformLegalAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolAndPlatformLegalAgreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolAndPlatformLegalAgreements.
     */
    distinct?: SchoolAndPlatformLegalAgreementScalarFieldEnum | SchoolAndPlatformLegalAgreementScalarFieldEnum[]
  }

  /**
   * SchoolAndPlatformLegalAgreement findMany
   */
  export type SchoolAndPlatformLegalAgreementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAndPlatformLegalAgreement
     */
    select?: SchoolAndPlatformLegalAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAndPlatformLegalAgreement
     */
    omit?: SchoolAndPlatformLegalAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAndPlatformLegalAgreementInclude<ExtArgs> | null
    /**
     * Filter, which SchoolAndPlatformLegalAgreements to fetch.
     */
    where?: SchoolAndPlatformLegalAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolAndPlatformLegalAgreements to fetch.
     */
    orderBy?: SchoolAndPlatformLegalAgreementOrderByWithRelationInput | SchoolAndPlatformLegalAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolAndPlatformLegalAgreements.
     */
    cursor?: SchoolAndPlatformLegalAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolAndPlatformLegalAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolAndPlatformLegalAgreements.
     */
    skip?: number
    distinct?: SchoolAndPlatformLegalAgreementScalarFieldEnum | SchoolAndPlatformLegalAgreementScalarFieldEnum[]
  }

  /**
   * SchoolAndPlatformLegalAgreement create
   */
  export type SchoolAndPlatformLegalAgreementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAndPlatformLegalAgreement
     */
    select?: SchoolAndPlatformLegalAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAndPlatformLegalAgreement
     */
    omit?: SchoolAndPlatformLegalAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAndPlatformLegalAgreementInclude<ExtArgs> | null
    /**
     * The data needed to create a SchoolAndPlatformLegalAgreement.
     */
    data: XOR<SchoolAndPlatformLegalAgreementCreateInput, SchoolAndPlatformLegalAgreementUncheckedCreateInput>
  }

  /**
   * SchoolAndPlatformLegalAgreement createMany
   */
  export type SchoolAndPlatformLegalAgreementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SchoolAndPlatformLegalAgreements.
     */
    data: SchoolAndPlatformLegalAgreementCreateManyInput | SchoolAndPlatformLegalAgreementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SchoolAndPlatformLegalAgreement createManyAndReturn
   */
  export type SchoolAndPlatformLegalAgreementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAndPlatformLegalAgreement
     */
    select?: SchoolAndPlatformLegalAgreementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAndPlatformLegalAgreement
     */
    omit?: SchoolAndPlatformLegalAgreementOmit<ExtArgs> | null
    /**
     * The data used to create many SchoolAndPlatformLegalAgreements.
     */
    data: SchoolAndPlatformLegalAgreementCreateManyInput | SchoolAndPlatformLegalAgreementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAndPlatformLegalAgreementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolAndPlatformLegalAgreement update
   */
  export type SchoolAndPlatformLegalAgreementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAndPlatformLegalAgreement
     */
    select?: SchoolAndPlatformLegalAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAndPlatformLegalAgreement
     */
    omit?: SchoolAndPlatformLegalAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAndPlatformLegalAgreementInclude<ExtArgs> | null
    /**
     * The data needed to update a SchoolAndPlatformLegalAgreement.
     */
    data: XOR<SchoolAndPlatformLegalAgreementUpdateInput, SchoolAndPlatformLegalAgreementUncheckedUpdateInput>
    /**
     * Choose, which SchoolAndPlatformLegalAgreement to update.
     */
    where: SchoolAndPlatformLegalAgreementWhereUniqueInput
  }

  /**
   * SchoolAndPlatformLegalAgreement updateMany
   */
  export type SchoolAndPlatformLegalAgreementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SchoolAndPlatformLegalAgreements.
     */
    data: XOR<SchoolAndPlatformLegalAgreementUpdateManyMutationInput, SchoolAndPlatformLegalAgreementUncheckedUpdateManyInput>
    /**
     * Filter which SchoolAndPlatformLegalAgreements to update
     */
    where?: SchoolAndPlatformLegalAgreementWhereInput
    /**
     * Limit how many SchoolAndPlatformLegalAgreements to update.
     */
    limit?: number
  }

  /**
   * SchoolAndPlatformLegalAgreement updateManyAndReturn
   */
  export type SchoolAndPlatformLegalAgreementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAndPlatformLegalAgreement
     */
    select?: SchoolAndPlatformLegalAgreementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAndPlatformLegalAgreement
     */
    omit?: SchoolAndPlatformLegalAgreementOmit<ExtArgs> | null
    /**
     * The data used to update SchoolAndPlatformLegalAgreements.
     */
    data: XOR<SchoolAndPlatformLegalAgreementUpdateManyMutationInput, SchoolAndPlatformLegalAgreementUncheckedUpdateManyInput>
    /**
     * Filter which SchoolAndPlatformLegalAgreements to update
     */
    where?: SchoolAndPlatformLegalAgreementWhereInput
    /**
     * Limit how many SchoolAndPlatformLegalAgreements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAndPlatformLegalAgreementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolAndPlatformLegalAgreement upsert
   */
  export type SchoolAndPlatformLegalAgreementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAndPlatformLegalAgreement
     */
    select?: SchoolAndPlatformLegalAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAndPlatformLegalAgreement
     */
    omit?: SchoolAndPlatformLegalAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAndPlatformLegalAgreementInclude<ExtArgs> | null
    /**
     * The filter to search for the SchoolAndPlatformLegalAgreement to update in case it exists.
     */
    where: SchoolAndPlatformLegalAgreementWhereUniqueInput
    /**
     * In case the SchoolAndPlatformLegalAgreement found by the `where` argument doesn't exist, create a new SchoolAndPlatformLegalAgreement with this data.
     */
    create: XOR<SchoolAndPlatformLegalAgreementCreateInput, SchoolAndPlatformLegalAgreementUncheckedCreateInput>
    /**
     * In case the SchoolAndPlatformLegalAgreement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolAndPlatformLegalAgreementUpdateInput, SchoolAndPlatformLegalAgreementUncheckedUpdateInput>
  }

  /**
   * SchoolAndPlatformLegalAgreement delete
   */
  export type SchoolAndPlatformLegalAgreementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAndPlatformLegalAgreement
     */
    select?: SchoolAndPlatformLegalAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAndPlatformLegalAgreement
     */
    omit?: SchoolAndPlatformLegalAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAndPlatformLegalAgreementInclude<ExtArgs> | null
    /**
     * Filter which SchoolAndPlatformLegalAgreement to delete.
     */
    where: SchoolAndPlatformLegalAgreementWhereUniqueInput
  }

  /**
   * SchoolAndPlatformLegalAgreement deleteMany
   */
  export type SchoolAndPlatformLegalAgreementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolAndPlatformLegalAgreements to delete
     */
    where?: SchoolAndPlatformLegalAgreementWhereInput
    /**
     * Limit how many SchoolAndPlatformLegalAgreements to delete.
     */
    limit?: number
  }

  /**
   * SchoolAndPlatformLegalAgreement without action
   */
  export type SchoolAndPlatformLegalAgreementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolAndPlatformLegalAgreement
     */
    select?: SchoolAndPlatformLegalAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolAndPlatformLegalAgreement
     */
    omit?: SchoolAndPlatformLegalAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolAndPlatformLegalAgreementInclude<ExtArgs> | null
  }


  /**
   * Model KYCVerification
   */

  export type AggregateKYCVerification = {
    _count: KYCVerificationCountAggregateOutputType | null
    _min: KYCVerificationMinAggregateOutputType | null
    _max: KYCVerificationMaxAggregateOutputType | null
  }

  export type KYCVerificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    schoolId: string | null
    status: $Enums.KYCVerificationStatus | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KYCVerificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    schoolId: string | null
    status: $Enums.KYCVerificationStatus | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KYCVerificationCountAggregateOutputType = {
    id: number
    userId: number
    schoolId: number
    status: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KYCVerificationMinAggregateInputType = {
    id?: true
    userId?: true
    schoolId?: true
    status?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KYCVerificationMaxAggregateInputType = {
    id?: true
    userId?: true
    schoolId?: true
    status?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KYCVerificationCountAggregateInputType = {
    id?: true
    userId?: true
    schoolId?: true
    status?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KYCVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KYCVerification to aggregate.
     */
    where?: KYCVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCVerifications to fetch.
     */
    orderBy?: KYCVerificationOrderByWithRelationInput | KYCVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KYCVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KYCVerifications
    **/
    _count?: true | KYCVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KYCVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KYCVerificationMaxAggregateInputType
  }

  export type GetKYCVerificationAggregateType<T extends KYCVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateKYCVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKYCVerification[P]>
      : GetScalarType<T[P], AggregateKYCVerification[P]>
  }




  export type KYCVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KYCVerificationWhereInput
    orderBy?: KYCVerificationOrderByWithAggregationInput | KYCVerificationOrderByWithAggregationInput[]
    by: KYCVerificationScalarFieldEnum[] | KYCVerificationScalarFieldEnum
    having?: KYCVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KYCVerificationCountAggregateInputType | true
    _min?: KYCVerificationMinAggregateInputType
    _max?: KYCVerificationMaxAggregateInputType
  }

  export type KYCVerificationGroupByOutputType = {
    id: string
    userId: string
    schoolId: string
    status: $Enums.KYCVerificationStatus
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: KYCVerificationCountAggregateOutputType | null
    _min: KYCVerificationMinAggregateOutputType | null
    _max: KYCVerificationMaxAggregateOutputType | null
  }

  type GetKYCVerificationGroupByPayload<T extends KYCVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KYCVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KYCVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KYCVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], KYCVerificationGroupByOutputType[P]>
        }
      >
    >


  export type KYCVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    schoolId?: boolean
    status?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kYCVerification"]>

  export type KYCVerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    schoolId?: boolean
    status?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kYCVerification"]>

  export type KYCVerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    schoolId?: boolean
    status?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kYCVerification"]>

  export type KYCVerificationSelectScalar = {
    id?: boolean
    userId?: boolean
    schoolId?: boolean
    status?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KYCVerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "schoolId" | "status" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["kYCVerification"]>
  export type KYCVerificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type KYCVerificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type KYCVerificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $KYCVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KYCVerification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      schoolId: string
      status: $Enums.KYCVerificationStatus
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["kYCVerification"]>
    composites: {}
  }

  type KYCVerificationGetPayload<S extends boolean | null | undefined | KYCVerificationDefaultArgs> = $Result.GetResult<Prisma.$KYCVerificationPayload, S>

  type KYCVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KYCVerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KYCVerificationCountAggregateInputType | true
    }

  export interface KYCVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KYCVerification'], meta: { name: 'KYCVerification' } }
    /**
     * Find zero or one KYCVerification that matches the filter.
     * @param {KYCVerificationFindUniqueArgs} args - Arguments to find a KYCVerification
     * @example
     * // Get one KYCVerification
     * const kYCVerification = await prisma.kYCVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KYCVerificationFindUniqueArgs>(args: SelectSubset<T, KYCVerificationFindUniqueArgs<ExtArgs>>): Prisma__KYCVerificationClient<$Result.GetResult<Prisma.$KYCVerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KYCVerification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KYCVerificationFindUniqueOrThrowArgs} args - Arguments to find a KYCVerification
     * @example
     * // Get one KYCVerification
     * const kYCVerification = await prisma.kYCVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KYCVerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, KYCVerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KYCVerificationClient<$Result.GetResult<Prisma.$KYCVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KYCVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCVerificationFindFirstArgs} args - Arguments to find a KYCVerification
     * @example
     * // Get one KYCVerification
     * const kYCVerification = await prisma.kYCVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KYCVerificationFindFirstArgs>(args?: SelectSubset<T, KYCVerificationFindFirstArgs<ExtArgs>>): Prisma__KYCVerificationClient<$Result.GetResult<Prisma.$KYCVerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KYCVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCVerificationFindFirstOrThrowArgs} args - Arguments to find a KYCVerification
     * @example
     * // Get one KYCVerification
     * const kYCVerification = await prisma.kYCVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KYCVerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, KYCVerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__KYCVerificationClient<$Result.GetResult<Prisma.$KYCVerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KYCVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KYCVerifications
     * const kYCVerifications = await prisma.kYCVerification.findMany()
     * 
     * // Get first 10 KYCVerifications
     * const kYCVerifications = await prisma.kYCVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kYCVerificationWithIdOnly = await prisma.kYCVerification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KYCVerificationFindManyArgs>(args?: SelectSubset<T, KYCVerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KYCVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KYCVerification.
     * @param {KYCVerificationCreateArgs} args - Arguments to create a KYCVerification.
     * @example
     * // Create one KYCVerification
     * const KYCVerification = await prisma.kYCVerification.create({
     *   data: {
     *     // ... data to create a KYCVerification
     *   }
     * })
     * 
     */
    create<T extends KYCVerificationCreateArgs>(args: SelectSubset<T, KYCVerificationCreateArgs<ExtArgs>>): Prisma__KYCVerificationClient<$Result.GetResult<Prisma.$KYCVerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KYCVerifications.
     * @param {KYCVerificationCreateManyArgs} args - Arguments to create many KYCVerifications.
     * @example
     * // Create many KYCVerifications
     * const kYCVerification = await prisma.kYCVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KYCVerificationCreateManyArgs>(args?: SelectSubset<T, KYCVerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KYCVerifications and returns the data saved in the database.
     * @param {KYCVerificationCreateManyAndReturnArgs} args - Arguments to create many KYCVerifications.
     * @example
     * // Create many KYCVerifications
     * const kYCVerification = await prisma.kYCVerification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KYCVerifications and only return the `id`
     * const kYCVerificationWithIdOnly = await prisma.kYCVerification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KYCVerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, KYCVerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KYCVerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KYCVerification.
     * @param {KYCVerificationDeleteArgs} args - Arguments to delete one KYCVerification.
     * @example
     * // Delete one KYCVerification
     * const KYCVerification = await prisma.kYCVerification.delete({
     *   where: {
     *     // ... filter to delete one KYCVerification
     *   }
     * })
     * 
     */
    delete<T extends KYCVerificationDeleteArgs>(args: SelectSubset<T, KYCVerificationDeleteArgs<ExtArgs>>): Prisma__KYCVerificationClient<$Result.GetResult<Prisma.$KYCVerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KYCVerification.
     * @param {KYCVerificationUpdateArgs} args - Arguments to update one KYCVerification.
     * @example
     * // Update one KYCVerification
     * const kYCVerification = await prisma.kYCVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KYCVerificationUpdateArgs>(args: SelectSubset<T, KYCVerificationUpdateArgs<ExtArgs>>): Prisma__KYCVerificationClient<$Result.GetResult<Prisma.$KYCVerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KYCVerifications.
     * @param {KYCVerificationDeleteManyArgs} args - Arguments to filter KYCVerifications to delete.
     * @example
     * // Delete a few KYCVerifications
     * const { count } = await prisma.kYCVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KYCVerificationDeleteManyArgs>(args?: SelectSubset<T, KYCVerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KYCVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KYCVerifications
     * const kYCVerification = await prisma.kYCVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KYCVerificationUpdateManyArgs>(args: SelectSubset<T, KYCVerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KYCVerifications and returns the data updated in the database.
     * @param {KYCVerificationUpdateManyAndReturnArgs} args - Arguments to update many KYCVerifications.
     * @example
     * // Update many KYCVerifications
     * const kYCVerification = await prisma.kYCVerification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KYCVerifications and only return the `id`
     * const kYCVerificationWithIdOnly = await prisma.kYCVerification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KYCVerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, KYCVerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KYCVerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KYCVerification.
     * @param {KYCVerificationUpsertArgs} args - Arguments to update or create a KYCVerification.
     * @example
     * // Update or create a KYCVerification
     * const kYCVerification = await prisma.kYCVerification.upsert({
     *   create: {
     *     // ... data to create a KYCVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KYCVerification we want to update
     *   }
     * })
     */
    upsert<T extends KYCVerificationUpsertArgs>(args: SelectSubset<T, KYCVerificationUpsertArgs<ExtArgs>>): Prisma__KYCVerificationClient<$Result.GetResult<Prisma.$KYCVerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KYCVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCVerificationCountArgs} args - Arguments to filter KYCVerifications to count.
     * @example
     * // Count the number of KYCVerifications
     * const count = await prisma.kYCVerification.count({
     *   where: {
     *     // ... the filter for the KYCVerifications we want to count
     *   }
     * })
    **/
    count<T extends KYCVerificationCountArgs>(
      args?: Subset<T, KYCVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KYCVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KYCVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KYCVerificationAggregateArgs>(args: Subset<T, KYCVerificationAggregateArgs>): Prisma.PrismaPromise<GetKYCVerificationAggregateType<T>>

    /**
     * Group by KYCVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KYCVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KYCVerificationGroupByArgs['orderBy'] }
        : { orderBy?: KYCVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KYCVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKYCVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KYCVerification model
   */
  readonly fields: KYCVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KYCVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KYCVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KYCVerification model
   */
  interface KYCVerificationFieldRefs {
    readonly id: FieldRef<"KYCVerification", 'String'>
    readonly userId: FieldRef<"KYCVerification", 'String'>
    readonly schoolId: FieldRef<"KYCVerification", 'String'>
    readonly status: FieldRef<"KYCVerification", 'KYCVerificationStatus'>
    readonly isDeleted: FieldRef<"KYCVerification", 'Boolean'>
    readonly createdAt: FieldRef<"KYCVerification", 'DateTime'>
    readonly updatedAt: FieldRef<"KYCVerification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KYCVerification findUnique
   */
  export type KYCVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCVerification
     */
    select?: KYCVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCVerification
     */
    omit?: KYCVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCVerificationInclude<ExtArgs> | null
    /**
     * Filter, which KYCVerification to fetch.
     */
    where: KYCVerificationWhereUniqueInput
  }

  /**
   * KYCVerification findUniqueOrThrow
   */
  export type KYCVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCVerification
     */
    select?: KYCVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCVerification
     */
    omit?: KYCVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCVerificationInclude<ExtArgs> | null
    /**
     * Filter, which KYCVerification to fetch.
     */
    where: KYCVerificationWhereUniqueInput
  }

  /**
   * KYCVerification findFirst
   */
  export type KYCVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCVerification
     */
    select?: KYCVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCVerification
     */
    omit?: KYCVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCVerificationInclude<ExtArgs> | null
    /**
     * Filter, which KYCVerification to fetch.
     */
    where?: KYCVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCVerifications to fetch.
     */
    orderBy?: KYCVerificationOrderByWithRelationInput | KYCVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KYCVerifications.
     */
    cursor?: KYCVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KYCVerifications.
     */
    distinct?: KYCVerificationScalarFieldEnum | KYCVerificationScalarFieldEnum[]
  }

  /**
   * KYCVerification findFirstOrThrow
   */
  export type KYCVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCVerification
     */
    select?: KYCVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCVerification
     */
    omit?: KYCVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCVerificationInclude<ExtArgs> | null
    /**
     * Filter, which KYCVerification to fetch.
     */
    where?: KYCVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCVerifications to fetch.
     */
    orderBy?: KYCVerificationOrderByWithRelationInput | KYCVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KYCVerifications.
     */
    cursor?: KYCVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KYCVerifications.
     */
    distinct?: KYCVerificationScalarFieldEnum | KYCVerificationScalarFieldEnum[]
  }

  /**
   * KYCVerification findMany
   */
  export type KYCVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCVerification
     */
    select?: KYCVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCVerification
     */
    omit?: KYCVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCVerificationInclude<ExtArgs> | null
    /**
     * Filter, which KYCVerifications to fetch.
     */
    where?: KYCVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCVerifications to fetch.
     */
    orderBy?: KYCVerificationOrderByWithRelationInput | KYCVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KYCVerifications.
     */
    cursor?: KYCVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCVerifications.
     */
    skip?: number
    distinct?: KYCVerificationScalarFieldEnum | KYCVerificationScalarFieldEnum[]
  }

  /**
   * KYCVerification create
   */
  export type KYCVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCVerification
     */
    select?: KYCVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCVerification
     */
    omit?: KYCVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCVerificationInclude<ExtArgs> | null
    /**
     * The data needed to create a KYCVerification.
     */
    data: XOR<KYCVerificationCreateInput, KYCVerificationUncheckedCreateInput>
  }

  /**
   * KYCVerification createMany
   */
  export type KYCVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KYCVerifications.
     */
    data: KYCVerificationCreateManyInput | KYCVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KYCVerification createManyAndReturn
   */
  export type KYCVerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCVerification
     */
    select?: KYCVerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KYCVerification
     */
    omit?: KYCVerificationOmit<ExtArgs> | null
    /**
     * The data used to create many KYCVerifications.
     */
    data: KYCVerificationCreateManyInput | KYCVerificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCVerificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KYCVerification update
   */
  export type KYCVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCVerification
     */
    select?: KYCVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCVerification
     */
    omit?: KYCVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCVerificationInclude<ExtArgs> | null
    /**
     * The data needed to update a KYCVerification.
     */
    data: XOR<KYCVerificationUpdateInput, KYCVerificationUncheckedUpdateInput>
    /**
     * Choose, which KYCVerification to update.
     */
    where: KYCVerificationWhereUniqueInput
  }

  /**
   * KYCVerification updateMany
   */
  export type KYCVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KYCVerifications.
     */
    data: XOR<KYCVerificationUpdateManyMutationInput, KYCVerificationUncheckedUpdateManyInput>
    /**
     * Filter which KYCVerifications to update
     */
    where?: KYCVerificationWhereInput
    /**
     * Limit how many KYCVerifications to update.
     */
    limit?: number
  }

  /**
   * KYCVerification updateManyAndReturn
   */
  export type KYCVerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCVerification
     */
    select?: KYCVerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KYCVerification
     */
    omit?: KYCVerificationOmit<ExtArgs> | null
    /**
     * The data used to update KYCVerifications.
     */
    data: XOR<KYCVerificationUpdateManyMutationInput, KYCVerificationUncheckedUpdateManyInput>
    /**
     * Filter which KYCVerifications to update
     */
    where?: KYCVerificationWhereInput
    /**
     * Limit how many KYCVerifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCVerificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KYCVerification upsert
   */
  export type KYCVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCVerification
     */
    select?: KYCVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCVerification
     */
    omit?: KYCVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCVerificationInclude<ExtArgs> | null
    /**
     * The filter to search for the KYCVerification to update in case it exists.
     */
    where: KYCVerificationWhereUniqueInput
    /**
     * In case the KYCVerification found by the `where` argument doesn't exist, create a new KYCVerification with this data.
     */
    create: XOR<KYCVerificationCreateInput, KYCVerificationUncheckedCreateInput>
    /**
     * In case the KYCVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KYCVerificationUpdateInput, KYCVerificationUncheckedUpdateInput>
  }

  /**
   * KYCVerification delete
   */
  export type KYCVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCVerification
     */
    select?: KYCVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCVerification
     */
    omit?: KYCVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCVerificationInclude<ExtArgs> | null
    /**
     * Filter which KYCVerification to delete.
     */
    where: KYCVerificationWhereUniqueInput
  }

  /**
   * KYCVerification deleteMany
   */
  export type KYCVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KYCVerifications to delete
     */
    where?: KYCVerificationWhereInput
    /**
     * Limit how many KYCVerifications to delete.
     */
    limit?: number
  }

  /**
   * KYCVerification without action
   */
  export type KYCVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYCVerification
     */
    select?: KYCVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYCVerification
     */
    omit?: KYCVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCVerificationInclude<ExtArgs> | null
  }


  /**
   * Model Class
   */

  export type AggregateClass = {
    _count: ClassCountAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  export type ClassMinAggregateOutputType = {
    id: string | null
    name: string | null
    schoolId: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassMaxAggregateOutputType = {
    id: string | null
    name: string | null
    schoolId: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassCountAggregateOutputType = {
    id: number
    name: number
    schoolId: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClassMinAggregateInputType = {
    id?: true
    name?: true
    schoolId?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassMaxAggregateInputType = {
    id?: true
    name?: true
    schoolId?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassCountAggregateInputType = {
    id?: true
    name?: true
    schoolId?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Class to aggregate.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassMaxAggregateInputType
  }

  export type GetClassAggregateType<T extends ClassAggregateArgs> = {
        [P in keyof T & keyof AggregateClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass[P]>
      : GetScalarType<T[P], AggregateClass[P]>
  }




  export type ClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithAggregationInput | ClassOrderByWithAggregationInput[]
    by: ClassScalarFieldEnum[] | ClassScalarFieldEnum
    having?: ClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassCountAggregateInputType | true
    _min?: ClassMinAggregateInputType
    _max?: ClassMaxAggregateInputType
  }

  export type ClassGroupByOutputType = {
    id: string
    name: string
    schoolId: string
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: ClassCountAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  type GetClassGroupByPayload<T extends ClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassGroupByOutputType[P]>
            : GetScalarType<T[P], ClassGroupByOutputType[P]>
        }
      >
    >


  export type ClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    schoolId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    fees?: boolean | Class$feesArgs<ExtArgs>
    invoices?: boolean | Class$invoicesArgs<ExtArgs>
    students?: boolean | Class$studentsArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    schoolId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    schoolId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectScalar = {
    id?: boolean
    name?: boolean
    schoolId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "schoolId" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["class"]>
  export type ClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    fees?: boolean | Class$feesArgs<ExtArgs>
    invoices?: boolean | Class$invoicesArgs<ExtArgs>
    students?: boolean | Class$studentsArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type ClassIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $ClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Class"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      fees: Prisma.$FeesPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      schoolId: string
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["class"]>
    composites: {}
  }

  type ClassGetPayload<S extends boolean | null | undefined | ClassDefaultArgs> = $Result.GetResult<Prisma.$ClassPayload, S>

  type ClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassCountAggregateInputType | true
    }

  export interface ClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Class'], meta: { name: 'Class' } }
    /**
     * Find zero or one Class that matches the filter.
     * @param {ClassFindUniqueArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFindUniqueArgs>(args: SelectSubset<T, ClassFindUniqueArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Class that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassFindUniqueOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFindFirstArgs>(args?: SelectSubset<T, ClassFindFirstArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.class.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.class.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classWithIdOnly = await prisma.class.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassFindManyArgs>(args?: SelectSubset<T, ClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Class.
     * @param {ClassCreateArgs} args - Arguments to create a Class.
     * @example
     * // Create one Class
     * const Class = await prisma.class.create({
     *   data: {
     *     // ... data to create a Class
     *   }
     * })
     * 
     */
    create<T extends ClassCreateArgs>(args: SelectSubset<T, ClassCreateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Classes.
     * @param {ClassCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassCreateManyArgs>(args?: SelectSubset<T, ClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classes and returns the data saved in the database.
     * @param {ClassCreateManyAndReturnArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Class.
     * @param {ClassDeleteArgs} args - Arguments to delete one Class.
     * @example
     * // Delete one Class
     * const Class = await prisma.class.delete({
     *   where: {
     *     // ... filter to delete one Class
     *   }
     * })
     * 
     */
    delete<T extends ClassDeleteArgs>(args: SelectSubset<T, ClassDeleteArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Class.
     * @param {ClassUpdateArgs} args - Arguments to update one Class.
     * @example
     * // Update one Class
     * const class = await prisma.class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassUpdateArgs>(args: SelectSubset<T, ClassUpdateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Classes.
     * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassDeleteManyArgs>(args?: SelectSubset<T, ClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassUpdateManyArgs>(args: SelectSubset<T, ClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes and returns the data updated in the database.
     * @param {ClassUpdateManyAndReturnArgs} args - Arguments to update many Classes.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Class.
     * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
     * @example
     * // Update or create a Class
     * const class = await prisma.class.upsert({
     *   create: {
     *     // ... data to create a Class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class we want to update
     *   }
     * })
     */
    upsert<T extends ClassUpsertArgs>(args: SelectSubset<T, ClassUpsertArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.class.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassCountArgs>(
      args?: Subset<T, ClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAggregateArgs>(args: Subset<T, ClassAggregateArgs>): Prisma.PrismaPromise<GetClassAggregateType<T>>

    /**
     * Group by Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassGroupByArgs['orderBy'] }
        : { orderBy?: ClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Class model
   */
  readonly fields: ClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fees<T extends Class$feesArgs<ExtArgs> = {}>(args?: Subset<T, Class$feesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Class$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Class$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    students<T extends Class$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Class$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Class model
   */
  interface ClassFieldRefs {
    readonly id: FieldRef<"Class", 'String'>
    readonly name: FieldRef<"Class", 'String'>
    readonly schoolId: FieldRef<"Class", 'String'>
    readonly isDeleted: FieldRef<"Class", 'Boolean'>
    readonly createdAt: FieldRef<"Class", 'DateTime'>
    readonly updatedAt: FieldRef<"Class", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Class findUnique
   */
  export type ClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findUniqueOrThrow
   */
  export type ClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findFirst
   */
  export type ClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findFirstOrThrow
   */
  export type ClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findMany
   */
  export type ClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class create
   */
  export type ClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to create a Class.
     */
    data: XOR<ClassCreateInput, ClassUncheckedCreateInput>
  }

  /**
   * Class createMany
   */
  export type ClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Class createManyAndReturn
   */
  export type ClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Class update
   */
  export type ClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to update a Class.
     */
    data: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
    /**
     * Choose, which Class to update.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class updateMany
   */
  export type ClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Class updateManyAndReturn
   */
  export type ClassUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Class upsert
   */
  export type ClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The filter to search for the Class to update in case it exists.
     */
    where: ClassWhereUniqueInput
    /**
     * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
     */
    create: XOR<ClassCreateInput, ClassUncheckedCreateInput>
    /**
     * In case the Class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
  }

  /**
   * Class delete
   */
  export type ClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter which Class to delete.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class deleteMany
   */
  export type ClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to delete.
     */
    limit?: number
  }

  /**
   * Class.fees
   */
  export type Class$feesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null
    where?: FeesWhereInput
    orderBy?: FeesOrderByWithRelationInput | FeesOrderByWithRelationInput[]
    cursor?: FeesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeesScalarFieldEnum | FeesScalarFieldEnum[]
  }

  /**
   * Class.invoices
   */
  export type Class$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Class.students
   */
  export type Class$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Class without action
   */
  export type ClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
  }


  /**
   * Model AcademicSession
   */

  export type AggregateAcademicSession = {
    _count: AcademicSessionCountAggregateOutputType | null
    _min: AcademicSessionMinAggregateOutputType | null
    _max: AcademicSessionMaxAggregateOutputType | null
  }

  export type AcademicSessionMinAggregateOutputType = {
    id: string | null
    name: string | null
    schoolId: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicSessionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    schoolId: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicSessionCountAggregateOutputType = {
    id: number
    name: number
    schoolId: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AcademicSessionMinAggregateInputType = {
    id?: true
    name?: true
    schoolId?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicSessionMaxAggregateInputType = {
    id?: true
    name?: true
    schoolId?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicSessionCountAggregateInputType = {
    id?: true
    name?: true
    schoolId?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AcademicSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicSession to aggregate.
     */
    where?: AcademicSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicSessions to fetch.
     */
    orderBy?: AcademicSessionOrderByWithRelationInput | AcademicSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicSessions
    **/
    _count?: true | AcademicSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicSessionMaxAggregateInputType
  }

  export type GetAcademicSessionAggregateType<T extends AcademicSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicSession[P]>
      : GetScalarType<T[P], AggregateAcademicSession[P]>
  }




  export type AcademicSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicSessionWhereInput
    orderBy?: AcademicSessionOrderByWithAggregationInput | AcademicSessionOrderByWithAggregationInput[]
    by: AcademicSessionScalarFieldEnum[] | AcademicSessionScalarFieldEnum
    having?: AcademicSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicSessionCountAggregateInputType | true
    _min?: AcademicSessionMinAggregateInputType
    _max?: AcademicSessionMaxAggregateInputType
  }

  export type AcademicSessionGroupByOutputType = {
    id: string
    name: string
    schoolId: string
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: AcademicSessionCountAggregateOutputType | null
    _min: AcademicSessionMinAggregateOutputType | null
    _max: AcademicSessionMaxAggregateOutputType | null
  }

  type GetAcademicSessionGroupByPayload<T extends AcademicSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicSessionGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicSessionGroupByOutputType[P]>
        }
      >
    >


  export type AcademicSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    schoolId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    fees?: boolean | AcademicSession$feesArgs<ExtArgs>
    invoices?: boolean | AcademicSession$invoicesArgs<ExtArgs>
    _count?: boolean | AcademicSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicSession"]>

  export type AcademicSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    schoolId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicSession"]>

  export type AcademicSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    schoolId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicSession"]>

  export type AcademicSessionSelectScalar = {
    id?: boolean
    name?: boolean
    schoolId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AcademicSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "schoolId" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["academicSession"]>
  export type AcademicSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    fees?: boolean | AcademicSession$feesArgs<ExtArgs>
    invoices?: boolean | AcademicSession$invoicesArgs<ExtArgs>
    _count?: boolean | AcademicSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AcademicSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type AcademicSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $AcademicSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicSession"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      fees: Prisma.$FeesPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      schoolId: string
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["academicSession"]>
    composites: {}
  }

  type AcademicSessionGetPayload<S extends boolean | null | undefined | AcademicSessionDefaultArgs> = $Result.GetResult<Prisma.$AcademicSessionPayload, S>

  type AcademicSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AcademicSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AcademicSessionCountAggregateInputType | true
    }

  export interface AcademicSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicSession'], meta: { name: 'AcademicSession' } }
    /**
     * Find zero or one AcademicSession that matches the filter.
     * @param {AcademicSessionFindUniqueArgs} args - Arguments to find a AcademicSession
     * @example
     * // Get one AcademicSession
     * const academicSession = await prisma.academicSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicSessionFindUniqueArgs>(args: SelectSubset<T, AcademicSessionFindUniqueArgs<ExtArgs>>): Prisma__AcademicSessionClient<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AcademicSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AcademicSessionFindUniqueOrThrowArgs} args - Arguments to find a AcademicSession
     * @example
     * // Get one AcademicSession
     * const academicSession = await prisma.academicSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademicSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademicSessionClient<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSessionFindFirstArgs} args - Arguments to find a AcademicSession
     * @example
     * // Get one AcademicSession
     * const academicSession = await prisma.academicSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicSessionFindFirstArgs>(args?: SelectSubset<T, AcademicSessionFindFirstArgs<ExtArgs>>): Prisma__AcademicSessionClient<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSessionFindFirstOrThrowArgs} args - Arguments to find a AcademicSession
     * @example
     * // Get one AcademicSession
     * const academicSession = await prisma.academicSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademicSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademicSessionClient<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AcademicSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicSessions
     * const academicSessions = await prisma.academicSession.findMany()
     * 
     * // Get first 10 AcademicSessions
     * const academicSessions = await prisma.academicSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicSessionWithIdOnly = await prisma.academicSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademicSessionFindManyArgs>(args?: SelectSubset<T, AcademicSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AcademicSession.
     * @param {AcademicSessionCreateArgs} args - Arguments to create a AcademicSession.
     * @example
     * // Create one AcademicSession
     * const AcademicSession = await prisma.academicSession.create({
     *   data: {
     *     // ... data to create a AcademicSession
     *   }
     * })
     * 
     */
    create<T extends AcademicSessionCreateArgs>(args: SelectSubset<T, AcademicSessionCreateArgs<ExtArgs>>): Prisma__AcademicSessionClient<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AcademicSessions.
     * @param {AcademicSessionCreateManyArgs} args - Arguments to create many AcademicSessions.
     * @example
     * // Create many AcademicSessions
     * const academicSession = await prisma.academicSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademicSessionCreateManyArgs>(args?: SelectSubset<T, AcademicSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AcademicSessions and returns the data saved in the database.
     * @param {AcademicSessionCreateManyAndReturnArgs} args - Arguments to create many AcademicSessions.
     * @example
     * // Create many AcademicSessions
     * const academicSession = await prisma.academicSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AcademicSessions and only return the `id`
     * const academicSessionWithIdOnly = await prisma.academicSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AcademicSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, AcademicSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AcademicSession.
     * @param {AcademicSessionDeleteArgs} args - Arguments to delete one AcademicSession.
     * @example
     * // Delete one AcademicSession
     * const AcademicSession = await prisma.academicSession.delete({
     *   where: {
     *     // ... filter to delete one AcademicSession
     *   }
     * })
     * 
     */
    delete<T extends AcademicSessionDeleteArgs>(args: SelectSubset<T, AcademicSessionDeleteArgs<ExtArgs>>): Prisma__AcademicSessionClient<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AcademicSession.
     * @param {AcademicSessionUpdateArgs} args - Arguments to update one AcademicSession.
     * @example
     * // Update one AcademicSession
     * const academicSession = await prisma.academicSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademicSessionUpdateArgs>(args: SelectSubset<T, AcademicSessionUpdateArgs<ExtArgs>>): Prisma__AcademicSessionClient<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AcademicSessions.
     * @param {AcademicSessionDeleteManyArgs} args - Arguments to filter AcademicSessions to delete.
     * @example
     * // Delete a few AcademicSessions
     * const { count } = await prisma.academicSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademicSessionDeleteManyArgs>(args?: SelectSubset<T, AcademicSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicSessions
     * const academicSession = await prisma.academicSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademicSessionUpdateManyArgs>(args: SelectSubset<T, AcademicSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicSessions and returns the data updated in the database.
     * @param {AcademicSessionUpdateManyAndReturnArgs} args - Arguments to update many AcademicSessions.
     * @example
     * // Update many AcademicSessions
     * const academicSession = await prisma.academicSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AcademicSessions and only return the `id`
     * const academicSessionWithIdOnly = await prisma.academicSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AcademicSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, AcademicSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AcademicSession.
     * @param {AcademicSessionUpsertArgs} args - Arguments to update or create a AcademicSession.
     * @example
     * // Update or create a AcademicSession
     * const academicSession = await prisma.academicSession.upsert({
     *   create: {
     *     // ... data to create a AcademicSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicSession we want to update
     *   }
     * })
     */
    upsert<T extends AcademicSessionUpsertArgs>(args: SelectSubset<T, AcademicSessionUpsertArgs<ExtArgs>>): Prisma__AcademicSessionClient<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AcademicSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSessionCountArgs} args - Arguments to filter AcademicSessions to count.
     * @example
     * // Count the number of AcademicSessions
     * const count = await prisma.academicSession.count({
     *   where: {
     *     // ... the filter for the AcademicSessions we want to count
     *   }
     * })
    **/
    count<T extends AcademicSessionCountArgs>(
      args?: Subset<T, AcademicSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicSessionAggregateArgs>(args: Subset<T, AcademicSessionAggregateArgs>): Prisma.PrismaPromise<GetAcademicSessionAggregateType<T>>

    /**
     * Group by AcademicSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicSessionGroupByArgs['orderBy'] }
        : { orderBy?: AcademicSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicSession model
   */
  readonly fields: AcademicSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fees<T extends AcademicSession$feesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSession$feesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends AcademicSession$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSession$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcademicSession model
   */
  interface AcademicSessionFieldRefs {
    readonly id: FieldRef<"AcademicSession", 'String'>
    readonly name: FieldRef<"AcademicSession", 'String'>
    readonly schoolId: FieldRef<"AcademicSession", 'String'>
    readonly isDeleted: FieldRef<"AcademicSession", 'Boolean'>
    readonly createdAt: FieldRef<"AcademicSession", 'DateTime'>
    readonly updatedAt: FieldRef<"AcademicSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AcademicSession findUnique
   */
  export type AcademicSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSession
     */
    select?: AcademicSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSession
     */
    omit?: AcademicSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSessionInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSession to fetch.
     */
    where: AcademicSessionWhereUniqueInput
  }

  /**
   * AcademicSession findUniqueOrThrow
   */
  export type AcademicSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSession
     */
    select?: AcademicSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSession
     */
    omit?: AcademicSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSessionInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSession to fetch.
     */
    where: AcademicSessionWhereUniqueInput
  }

  /**
   * AcademicSession findFirst
   */
  export type AcademicSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSession
     */
    select?: AcademicSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSession
     */
    omit?: AcademicSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSessionInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSession to fetch.
     */
    where?: AcademicSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicSessions to fetch.
     */
    orderBy?: AcademicSessionOrderByWithRelationInput | AcademicSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicSessions.
     */
    cursor?: AcademicSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicSessions.
     */
    distinct?: AcademicSessionScalarFieldEnum | AcademicSessionScalarFieldEnum[]
  }

  /**
   * AcademicSession findFirstOrThrow
   */
  export type AcademicSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSession
     */
    select?: AcademicSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSession
     */
    omit?: AcademicSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSessionInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSession to fetch.
     */
    where?: AcademicSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicSessions to fetch.
     */
    orderBy?: AcademicSessionOrderByWithRelationInput | AcademicSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicSessions.
     */
    cursor?: AcademicSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicSessions.
     */
    distinct?: AcademicSessionScalarFieldEnum | AcademicSessionScalarFieldEnum[]
  }

  /**
   * AcademicSession findMany
   */
  export type AcademicSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSession
     */
    select?: AcademicSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSession
     */
    omit?: AcademicSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSessionInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSessions to fetch.
     */
    where?: AcademicSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicSessions to fetch.
     */
    orderBy?: AcademicSessionOrderByWithRelationInput | AcademicSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicSessions.
     */
    cursor?: AcademicSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicSessions.
     */
    skip?: number
    distinct?: AcademicSessionScalarFieldEnum | AcademicSessionScalarFieldEnum[]
  }

  /**
   * AcademicSession create
   */
  export type AcademicSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSession
     */
    select?: AcademicSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSession
     */
    omit?: AcademicSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicSession.
     */
    data: XOR<AcademicSessionCreateInput, AcademicSessionUncheckedCreateInput>
  }

  /**
   * AcademicSession createMany
   */
  export type AcademicSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicSessions.
     */
    data: AcademicSessionCreateManyInput | AcademicSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicSession createManyAndReturn
   */
  export type AcademicSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSession
     */
    select?: AcademicSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSession
     */
    omit?: AcademicSessionOmit<ExtArgs> | null
    /**
     * The data used to create many AcademicSessions.
     */
    data: AcademicSessionCreateManyInput | AcademicSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AcademicSession update
   */
  export type AcademicSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSession
     */
    select?: AcademicSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSession
     */
    omit?: AcademicSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicSession.
     */
    data: XOR<AcademicSessionUpdateInput, AcademicSessionUncheckedUpdateInput>
    /**
     * Choose, which AcademicSession to update.
     */
    where: AcademicSessionWhereUniqueInput
  }

  /**
   * AcademicSession updateMany
   */
  export type AcademicSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicSessions.
     */
    data: XOR<AcademicSessionUpdateManyMutationInput, AcademicSessionUncheckedUpdateManyInput>
    /**
     * Filter which AcademicSessions to update
     */
    where?: AcademicSessionWhereInput
    /**
     * Limit how many AcademicSessions to update.
     */
    limit?: number
  }

  /**
   * AcademicSession updateManyAndReturn
   */
  export type AcademicSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSession
     */
    select?: AcademicSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSession
     */
    omit?: AcademicSessionOmit<ExtArgs> | null
    /**
     * The data used to update AcademicSessions.
     */
    data: XOR<AcademicSessionUpdateManyMutationInput, AcademicSessionUncheckedUpdateManyInput>
    /**
     * Filter which AcademicSessions to update
     */
    where?: AcademicSessionWhereInput
    /**
     * Limit how many AcademicSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AcademicSession upsert
   */
  export type AcademicSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSession
     */
    select?: AcademicSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSession
     */
    omit?: AcademicSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicSession to update in case it exists.
     */
    where: AcademicSessionWhereUniqueInput
    /**
     * In case the AcademicSession found by the `where` argument doesn't exist, create a new AcademicSession with this data.
     */
    create: XOR<AcademicSessionCreateInput, AcademicSessionUncheckedCreateInput>
    /**
     * In case the AcademicSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicSessionUpdateInput, AcademicSessionUncheckedUpdateInput>
  }

  /**
   * AcademicSession delete
   */
  export type AcademicSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSession
     */
    select?: AcademicSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSession
     */
    omit?: AcademicSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSessionInclude<ExtArgs> | null
    /**
     * Filter which AcademicSession to delete.
     */
    where: AcademicSessionWhereUniqueInput
  }

  /**
   * AcademicSession deleteMany
   */
  export type AcademicSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicSessions to delete
     */
    where?: AcademicSessionWhereInput
    /**
     * Limit how many AcademicSessions to delete.
     */
    limit?: number
  }

  /**
   * AcademicSession.fees
   */
  export type AcademicSession$feesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null
    where?: FeesWhereInput
    orderBy?: FeesOrderByWithRelationInput | FeesOrderByWithRelationInput[]
    cursor?: FeesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeesScalarFieldEnum | FeesScalarFieldEnum[]
  }

  /**
   * AcademicSession.invoices
   */
  export type AcademicSession$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * AcademicSession without action
   */
  export type AcademicSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSession
     */
    select?: AcademicSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicSession
     */
    omit?: AcademicSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicSessionInclude<ExtArgs> | null
  }


  /**
   * Model Term
   */

  export type AggregateTerm = {
    _count: TermCountAggregateOutputType | null
    _min: TermMinAggregateOutputType | null
    _max: TermMaxAggregateOutputType | null
  }

  export type TermMinAggregateOutputType = {
    id: string | null
    name: string | null
    schoolId: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TermMaxAggregateOutputType = {
    id: string | null
    name: string | null
    schoolId: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TermCountAggregateOutputType = {
    id: number
    name: number
    schoolId: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TermMinAggregateInputType = {
    id?: true
    name?: true
    schoolId?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TermMaxAggregateInputType = {
    id?: true
    name?: true
    schoolId?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TermCountAggregateInputType = {
    id?: true
    name?: true
    schoolId?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TermAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Term to aggregate.
     */
    where?: TermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terms to fetch.
     */
    orderBy?: TermOrderByWithRelationInput | TermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Terms
    **/
    _count?: true | TermCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TermMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TermMaxAggregateInputType
  }

  export type GetTermAggregateType<T extends TermAggregateArgs> = {
        [P in keyof T & keyof AggregateTerm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTerm[P]>
      : GetScalarType<T[P], AggregateTerm[P]>
  }




  export type TermGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TermWhereInput
    orderBy?: TermOrderByWithAggregationInput | TermOrderByWithAggregationInput[]
    by: TermScalarFieldEnum[] | TermScalarFieldEnum
    having?: TermScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TermCountAggregateInputType | true
    _min?: TermMinAggregateInputType
    _max?: TermMaxAggregateInputType
  }

  export type TermGroupByOutputType = {
    id: string
    name: string
    schoolId: string
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: TermCountAggregateOutputType | null
    _min: TermMinAggregateOutputType | null
    _max: TermMaxAggregateOutputType | null
  }

  type GetTermGroupByPayload<T extends TermGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TermGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TermGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TermGroupByOutputType[P]>
            : GetScalarType<T[P], TermGroupByOutputType[P]>
        }
      >
    >


  export type TermSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    schoolId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    fees?: boolean | Term$feesArgs<ExtArgs>
    invoices?: boolean | Term$invoicesArgs<ExtArgs>
    _count?: boolean | TermCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["term"]>

  export type TermSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    schoolId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["term"]>

  export type TermSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    schoolId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["term"]>

  export type TermSelectScalar = {
    id?: boolean
    name?: boolean
    schoolId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TermOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "schoolId" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["term"]>
  export type TermInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    fees?: boolean | Term$feesArgs<ExtArgs>
    invoices?: boolean | Term$invoicesArgs<ExtArgs>
    _count?: boolean | TermCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TermIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type TermIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $TermPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Term"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
      fees: Prisma.$FeesPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      schoolId: string
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["term"]>
    composites: {}
  }

  type TermGetPayload<S extends boolean | null | undefined | TermDefaultArgs> = $Result.GetResult<Prisma.$TermPayload, S>

  type TermCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TermFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TermCountAggregateInputType | true
    }

  export interface TermDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Term'], meta: { name: 'Term' } }
    /**
     * Find zero or one Term that matches the filter.
     * @param {TermFindUniqueArgs} args - Arguments to find a Term
     * @example
     * // Get one Term
     * const term = await prisma.term.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TermFindUniqueArgs>(args: SelectSubset<T, TermFindUniqueArgs<ExtArgs>>): Prisma__TermClient<$Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Term that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TermFindUniqueOrThrowArgs} args - Arguments to find a Term
     * @example
     * // Get one Term
     * const term = await prisma.term.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TermFindUniqueOrThrowArgs>(args: SelectSubset<T, TermFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TermClient<$Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Term that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermFindFirstArgs} args - Arguments to find a Term
     * @example
     * // Get one Term
     * const term = await prisma.term.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TermFindFirstArgs>(args?: SelectSubset<T, TermFindFirstArgs<ExtArgs>>): Prisma__TermClient<$Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Term that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermFindFirstOrThrowArgs} args - Arguments to find a Term
     * @example
     * // Get one Term
     * const term = await prisma.term.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TermFindFirstOrThrowArgs>(args?: SelectSubset<T, TermFindFirstOrThrowArgs<ExtArgs>>): Prisma__TermClient<$Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Terms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Terms
     * const terms = await prisma.term.findMany()
     * 
     * // Get first 10 Terms
     * const terms = await prisma.term.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const termWithIdOnly = await prisma.term.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TermFindManyArgs>(args?: SelectSubset<T, TermFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Term.
     * @param {TermCreateArgs} args - Arguments to create a Term.
     * @example
     * // Create one Term
     * const Term = await prisma.term.create({
     *   data: {
     *     // ... data to create a Term
     *   }
     * })
     * 
     */
    create<T extends TermCreateArgs>(args: SelectSubset<T, TermCreateArgs<ExtArgs>>): Prisma__TermClient<$Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Terms.
     * @param {TermCreateManyArgs} args - Arguments to create many Terms.
     * @example
     * // Create many Terms
     * const term = await prisma.term.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TermCreateManyArgs>(args?: SelectSubset<T, TermCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Terms and returns the data saved in the database.
     * @param {TermCreateManyAndReturnArgs} args - Arguments to create many Terms.
     * @example
     * // Create many Terms
     * const term = await prisma.term.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Terms and only return the `id`
     * const termWithIdOnly = await prisma.term.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TermCreateManyAndReturnArgs>(args?: SelectSubset<T, TermCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Term.
     * @param {TermDeleteArgs} args - Arguments to delete one Term.
     * @example
     * // Delete one Term
     * const Term = await prisma.term.delete({
     *   where: {
     *     // ... filter to delete one Term
     *   }
     * })
     * 
     */
    delete<T extends TermDeleteArgs>(args: SelectSubset<T, TermDeleteArgs<ExtArgs>>): Prisma__TermClient<$Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Term.
     * @param {TermUpdateArgs} args - Arguments to update one Term.
     * @example
     * // Update one Term
     * const term = await prisma.term.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TermUpdateArgs>(args: SelectSubset<T, TermUpdateArgs<ExtArgs>>): Prisma__TermClient<$Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Terms.
     * @param {TermDeleteManyArgs} args - Arguments to filter Terms to delete.
     * @example
     * // Delete a few Terms
     * const { count } = await prisma.term.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TermDeleteManyArgs>(args?: SelectSubset<T, TermDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Terms
     * const term = await prisma.term.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TermUpdateManyArgs>(args: SelectSubset<T, TermUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Terms and returns the data updated in the database.
     * @param {TermUpdateManyAndReturnArgs} args - Arguments to update many Terms.
     * @example
     * // Update many Terms
     * const term = await prisma.term.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Terms and only return the `id`
     * const termWithIdOnly = await prisma.term.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TermUpdateManyAndReturnArgs>(args: SelectSubset<T, TermUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Term.
     * @param {TermUpsertArgs} args - Arguments to update or create a Term.
     * @example
     * // Update or create a Term
     * const term = await prisma.term.upsert({
     *   create: {
     *     // ... data to create a Term
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Term we want to update
     *   }
     * })
     */
    upsert<T extends TermUpsertArgs>(args: SelectSubset<T, TermUpsertArgs<ExtArgs>>): Prisma__TermClient<$Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermCountArgs} args - Arguments to filter Terms to count.
     * @example
     * // Count the number of Terms
     * const count = await prisma.term.count({
     *   where: {
     *     // ... the filter for the Terms we want to count
     *   }
     * })
    **/
    count<T extends TermCountArgs>(
      args?: Subset<T, TermCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TermCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Term.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TermAggregateArgs>(args: Subset<T, TermAggregateArgs>): Prisma.PrismaPromise<GetTermAggregateType<T>>

    /**
     * Group by Term.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TermGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TermGroupByArgs['orderBy'] }
        : { orderBy?: TermGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TermGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTermGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Term model
   */
  readonly fields: TermFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Term.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TermClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fees<T extends Term$feesArgs<ExtArgs> = {}>(args?: Subset<T, Term$feesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Term$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Term$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Term model
   */
  interface TermFieldRefs {
    readonly id: FieldRef<"Term", 'String'>
    readonly name: FieldRef<"Term", 'String'>
    readonly schoolId: FieldRef<"Term", 'String'>
    readonly isDeleted: FieldRef<"Term", 'Boolean'>
    readonly createdAt: FieldRef<"Term", 'DateTime'>
    readonly updatedAt: FieldRef<"Term", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Term findUnique
   */
  export type TermFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null
    /**
     * Filter, which Term to fetch.
     */
    where: TermWhereUniqueInput
  }

  /**
   * Term findUniqueOrThrow
   */
  export type TermFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null
    /**
     * Filter, which Term to fetch.
     */
    where: TermWhereUniqueInput
  }

  /**
   * Term findFirst
   */
  export type TermFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null
    /**
     * Filter, which Term to fetch.
     */
    where?: TermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terms to fetch.
     */
    orderBy?: TermOrderByWithRelationInput | TermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Terms.
     */
    cursor?: TermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Terms.
     */
    distinct?: TermScalarFieldEnum | TermScalarFieldEnum[]
  }

  /**
   * Term findFirstOrThrow
   */
  export type TermFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null
    /**
     * Filter, which Term to fetch.
     */
    where?: TermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terms to fetch.
     */
    orderBy?: TermOrderByWithRelationInput | TermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Terms.
     */
    cursor?: TermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Terms.
     */
    distinct?: TermScalarFieldEnum | TermScalarFieldEnum[]
  }

  /**
   * Term findMany
   */
  export type TermFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null
    /**
     * Filter, which Terms to fetch.
     */
    where?: TermWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terms to fetch.
     */
    orderBy?: TermOrderByWithRelationInput | TermOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Terms.
     */
    cursor?: TermWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terms.
     */
    skip?: number
    distinct?: TermScalarFieldEnum | TermScalarFieldEnum[]
  }

  /**
   * Term create
   */
  export type TermCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null
    /**
     * The data needed to create a Term.
     */
    data: XOR<TermCreateInput, TermUncheckedCreateInput>
  }

  /**
   * Term createMany
   */
  export type TermCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Terms.
     */
    data: TermCreateManyInput | TermCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Term createManyAndReturn
   */
  export type TermCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null
    /**
     * The data used to create many Terms.
     */
    data: TermCreateManyInput | TermCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Term update
   */
  export type TermUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null
    /**
     * The data needed to update a Term.
     */
    data: XOR<TermUpdateInput, TermUncheckedUpdateInput>
    /**
     * Choose, which Term to update.
     */
    where: TermWhereUniqueInput
  }

  /**
   * Term updateMany
   */
  export type TermUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Terms.
     */
    data: XOR<TermUpdateManyMutationInput, TermUncheckedUpdateManyInput>
    /**
     * Filter which Terms to update
     */
    where?: TermWhereInput
    /**
     * Limit how many Terms to update.
     */
    limit?: number
  }

  /**
   * Term updateManyAndReturn
   */
  export type TermUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null
    /**
     * The data used to update Terms.
     */
    data: XOR<TermUpdateManyMutationInput, TermUncheckedUpdateManyInput>
    /**
     * Filter which Terms to update
     */
    where?: TermWhereInput
    /**
     * Limit how many Terms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Term upsert
   */
  export type TermUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null
    /**
     * The filter to search for the Term to update in case it exists.
     */
    where: TermWhereUniqueInput
    /**
     * In case the Term found by the `where` argument doesn't exist, create a new Term with this data.
     */
    create: XOR<TermCreateInput, TermUncheckedCreateInput>
    /**
     * In case the Term was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TermUpdateInput, TermUncheckedUpdateInput>
  }

  /**
   * Term delete
   */
  export type TermDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null
    /**
     * Filter which Term to delete.
     */
    where: TermWhereUniqueInput
  }

  /**
   * Term deleteMany
   */
  export type TermDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Terms to delete
     */
    where?: TermWhereInput
    /**
     * Limit how many Terms to delete.
     */
    limit?: number
  }

  /**
   * Term.fees
   */
  export type Term$feesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null
    where?: FeesWhereInput
    orderBy?: FeesOrderByWithRelationInput | FeesOrderByWithRelationInput[]
    cursor?: FeesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeesScalarFieldEnum | FeesScalarFieldEnum[]
  }

  /**
   * Term.invoices
   */
  export type Term$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Term without action
   */
  export type TermDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Term
     */
    select?: TermSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Term
     */
    omit?: TermOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TermInclude<ExtArgs> | null
  }


  /**
   * Model Fees
   */

  export type AggregateFees = {
    _count: FeesCountAggregateOutputType | null
    _avg: FeesAvgAggregateOutputType | null
    _sum: FeesSumAggregateOutputType | null
    _min: FeesMinAggregateOutputType | null
    _max: FeesMaxAggregateOutputType | null
  }

  export type FeesAvgAggregateOutputType = {
    latePaymentFee: Decimal | null
  }

  export type FeesSumAggregateOutputType = {
    latePaymentFee: Decimal | null
  }

  export type FeesMinAggregateOutputType = {
    id: string | null
    dueAt: Date | null
    latePaymentFee: Decimal | null
    schoolId: string | null
    classId: string | null
    sessionId: string | null
    termId: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeesMaxAggregateOutputType = {
    id: string | null
    dueAt: Date | null
    latePaymentFee: Decimal | null
    schoolId: string | null
    classId: string | null
    sessionId: string | null
    termId: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeesCountAggregateOutputType = {
    id: number
    dueAt: number
    latePaymentFee: number
    schoolId: number
    classId: number
    sessionId: number
    termId: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeesAvgAggregateInputType = {
    latePaymentFee?: true
  }

  export type FeesSumAggregateInputType = {
    latePaymentFee?: true
  }

  export type FeesMinAggregateInputType = {
    id?: true
    dueAt?: true
    latePaymentFee?: true
    schoolId?: true
    classId?: true
    sessionId?: true
    termId?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeesMaxAggregateInputType = {
    id?: true
    dueAt?: true
    latePaymentFee?: true
    schoolId?: true
    classId?: true
    sessionId?: true
    termId?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeesCountAggregateInputType = {
    id?: true
    dueAt?: true
    latePaymentFee?: true
    schoolId?: true
    classId?: true
    sessionId?: true
    termId?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fees to aggregate.
     */
    where?: FeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fees to fetch.
     */
    orderBy?: FeesOrderByWithRelationInput | FeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fees
    **/
    _count?: true | FeesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeesMaxAggregateInputType
  }

  export type GetFeesAggregateType<T extends FeesAggregateArgs> = {
        [P in keyof T & keyof AggregateFees]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFees[P]>
      : GetScalarType<T[P], AggregateFees[P]>
  }




  export type FeesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeesWhereInput
    orderBy?: FeesOrderByWithAggregationInput | FeesOrderByWithAggregationInput[]
    by: FeesScalarFieldEnum[] | FeesScalarFieldEnum
    having?: FeesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeesCountAggregateInputType | true
    _avg?: FeesAvgAggregateInputType
    _sum?: FeesSumAggregateInputType
    _min?: FeesMinAggregateInputType
    _max?: FeesMaxAggregateInputType
  }

  export type FeesGroupByOutputType = {
    id: string
    dueAt: Date
    latePaymentFee: Decimal
    schoolId: string
    classId: string
    sessionId: string
    termId: string
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: FeesCountAggregateOutputType | null
    _avg: FeesAvgAggregateOutputType | null
    _sum: FeesSumAggregateOutputType | null
    _min: FeesMinAggregateOutputType | null
    _max: FeesMaxAggregateOutputType | null
  }

  type GetFeesGroupByPayload<T extends FeesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeesGroupByOutputType[P]>
            : GetScalarType<T[P], FeesGroupByOutputType[P]>
        }
      >
    >


  export type FeesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dueAt?: boolean
    latePaymentFee?: boolean
    schoolId?: boolean
    classId?: boolean
    sessionId?: boolean
    termId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicSession?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    term?: boolean | TermDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    feeBreakdowns?: boolean | Fees$feeBreakdownsArgs<ExtArgs>
    _count?: boolean | FeesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fees"]>

  export type FeesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dueAt?: boolean
    latePaymentFee?: boolean
    schoolId?: boolean
    classId?: boolean
    sessionId?: boolean
    termId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicSession?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    term?: boolean | TermDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fees"]>

  export type FeesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dueAt?: boolean
    latePaymentFee?: boolean
    schoolId?: boolean
    classId?: boolean
    sessionId?: boolean
    termId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicSession?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    term?: boolean | TermDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fees"]>

  export type FeesSelectScalar = {
    id?: boolean
    dueAt?: boolean
    latePaymentFee?: boolean
    schoolId?: boolean
    classId?: boolean
    sessionId?: boolean
    termId?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dueAt" | "latePaymentFee" | "schoolId" | "classId" | "sessionId" | "termId" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["fees"]>
  export type FeesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicSession?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    term?: boolean | TermDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
    feeBreakdowns?: boolean | Fees$feeBreakdownsArgs<ExtArgs>
    _count?: boolean | FeesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicSession?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    term?: boolean | TermDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type FeesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicSession?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    term?: boolean | TermDefaultArgs<ExtArgs>
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $FeesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fees"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs>
      academicSession: Prisma.$AcademicSessionPayload<ExtArgs>
      term: Prisma.$TermPayload<ExtArgs>
      school: Prisma.$SchoolPayload<ExtArgs>
      feeBreakdowns: Prisma.$FeeBreakdownPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dueAt: Date
      latePaymentFee: Prisma.Decimal
      schoolId: string
      classId: string
      sessionId: string
      termId: string
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fees"]>
    composites: {}
  }

  type FeesGetPayload<S extends boolean | null | undefined | FeesDefaultArgs> = $Result.GetResult<Prisma.$FeesPayload, S>

  type FeesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeesCountAggregateInputType | true
    }

  export interface FeesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fees'], meta: { name: 'Fees' } }
    /**
     * Find zero or one Fees that matches the filter.
     * @param {FeesFindUniqueArgs} args - Arguments to find a Fees
     * @example
     * // Get one Fees
     * const fees = await prisma.fees.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeesFindUniqueArgs>(args: SelectSubset<T, FeesFindUniqueArgs<ExtArgs>>): Prisma__FeesClient<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fees that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeesFindUniqueOrThrowArgs} args - Arguments to find a Fees
     * @example
     * // Get one Fees
     * const fees = await prisma.fees.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeesFindUniqueOrThrowArgs>(args: SelectSubset<T, FeesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeesClient<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesFindFirstArgs} args - Arguments to find a Fees
     * @example
     * // Get one Fees
     * const fees = await prisma.fees.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeesFindFirstArgs>(args?: SelectSubset<T, FeesFindFirstArgs<ExtArgs>>): Prisma__FeesClient<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fees that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesFindFirstOrThrowArgs} args - Arguments to find a Fees
     * @example
     * // Get one Fees
     * const fees = await prisma.fees.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeesFindFirstOrThrowArgs>(args?: SelectSubset<T, FeesFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeesClient<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fees
     * const fees = await prisma.fees.findMany()
     * 
     * // Get first 10 Fees
     * const fees = await prisma.fees.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feesWithIdOnly = await prisma.fees.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeesFindManyArgs>(args?: SelectSubset<T, FeesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fees.
     * @param {FeesCreateArgs} args - Arguments to create a Fees.
     * @example
     * // Create one Fees
     * const Fees = await prisma.fees.create({
     *   data: {
     *     // ... data to create a Fees
     *   }
     * })
     * 
     */
    create<T extends FeesCreateArgs>(args: SelectSubset<T, FeesCreateArgs<ExtArgs>>): Prisma__FeesClient<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fees.
     * @param {FeesCreateManyArgs} args - Arguments to create many Fees.
     * @example
     * // Create many Fees
     * const fees = await prisma.fees.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeesCreateManyArgs>(args?: SelectSubset<T, FeesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Fees and returns the data saved in the database.
     * @param {FeesCreateManyAndReturnArgs} args - Arguments to create many Fees.
     * @example
     * // Create many Fees
     * const fees = await prisma.fees.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Fees and only return the `id`
     * const feesWithIdOnly = await prisma.fees.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeesCreateManyAndReturnArgs>(args?: SelectSubset<T, FeesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Fees.
     * @param {FeesDeleteArgs} args - Arguments to delete one Fees.
     * @example
     * // Delete one Fees
     * const Fees = await prisma.fees.delete({
     *   where: {
     *     // ... filter to delete one Fees
     *   }
     * })
     * 
     */
    delete<T extends FeesDeleteArgs>(args: SelectSubset<T, FeesDeleteArgs<ExtArgs>>): Prisma__FeesClient<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fees.
     * @param {FeesUpdateArgs} args - Arguments to update one Fees.
     * @example
     * // Update one Fees
     * const fees = await prisma.fees.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeesUpdateArgs>(args: SelectSubset<T, FeesUpdateArgs<ExtArgs>>): Prisma__FeesClient<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fees.
     * @param {FeesDeleteManyArgs} args - Arguments to filter Fees to delete.
     * @example
     * // Delete a few Fees
     * const { count } = await prisma.fees.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeesDeleteManyArgs>(args?: SelectSubset<T, FeesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fees
     * const fees = await prisma.fees.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeesUpdateManyArgs>(args: SelectSubset<T, FeesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fees and returns the data updated in the database.
     * @param {FeesUpdateManyAndReturnArgs} args - Arguments to update many Fees.
     * @example
     * // Update many Fees
     * const fees = await prisma.fees.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Fees and only return the `id`
     * const feesWithIdOnly = await prisma.fees.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeesUpdateManyAndReturnArgs>(args: SelectSubset<T, FeesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Fees.
     * @param {FeesUpsertArgs} args - Arguments to update or create a Fees.
     * @example
     * // Update or create a Fees
     * const fees = await prisma.fees.upsert({
     *   create: {
     *     // ... data to create a Fees
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fees we want to update
     *   }
     * })
     */
    upsert<T extends FeesUpsertArgs>(args: SelectSubset<T, FeesUpsertArgs<ExtArgs>>): Prisma__FeesClient<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Fees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesCountArgs} args - Arguments to filter Fees to count.
     * @example
     * // Count the number of Fees
     * const count = await prisma.fees.count({
     *   where: {
     *     // ... the filter for the Fees we want to count
     *   }
     * })
    **/
    count<T extends FeesCountArgs>(
      args?: Subset<T, FeesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeesAggregateArgs>(args: Subset<T, FeesAggregateArgs>): Prisma.PrismaPromise<GetFeesAggregateType<T>>

    /**
     * Group by Fees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeesGroupByArgs['orderBy'] }
        : { orderBy?: FeesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fees model
   */
  readonly fields: FeesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fees.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicSession<T extends AcademicSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSessionDefaultArgs<ExtArgs>>): Prisma__AcademicSessionClient<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    term<T extends TermDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TermDefaultArgs<ExtArgs>>): Prisma__TermClient<$Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    feeBreakdowns<T extends Fees$feeBreakdownsArgs<ExtArgs> = {}>(args?: Subset<T, Fees$feeBreakdownsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeBreakdownPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Fees model
   */
  interface FeesFieldRefs {
    readonly id: FieldRef<"Fees", 'String'>
    readonly dueAt: FieldRef<"Fees", 'DateTime'>
    readonly latePaymentFee: FieldRef<"Fees", 'Decimal'>
    readonly schoolId: FieldRef<"Fees", 'String'>
    readonly classId: FieldRef<"Fees", 'String'>
    readonly sessionId: FieldRef<"Fees", 'String'>
    readonly termId: FieldRef<"Fees", 'String'>
    readonly isDeleted: FieldRef<"Fees", 'Boolean'>
    readonly createdAt: FieldRef<"Fees", 'DateTime'>
    readonly updatedAt: FieldRef<"Fees", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Fees findUnique
   */
  export type FeesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null
    /**
     * Filter, which Fees to fetch.
     */
    where: FeesWhereUniqueInput
  }

  /**
   * Fees findUniqueOrThrow
   */
  export type FeesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null
    /**
     * Filter, which Fees to fetch.
     */
    where: FeesWhereUniqueInput
  }

  /**
   * Fees findFirst
   */
  export type FeesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null
    /**
     * Filter, which Fees to fetch.
     */
    where?: FeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fees to fetch.
     */
    orderBy?: FeesOrderByWithRelationInput | FeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fees.
     */
    cursor?: FeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fees.
     */
    distinct?: FeesScalarFieldEnum | FeesScalarFieldEnum[]
  }

  /**
   * Fees findFirstOrThrow
   */
  export type FeesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null
    /**
     * Filter, which Fees to fetch.
     */
    where?: FeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fees to fetch.
     */
    orderBy?: FeesOrderByWithRelationInput | FeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fees.
     */
    cursor?: FeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fees.
     */
    distinct?: FeesScalarFieldEnum | FeesScalarFieldEnum[]
  }

  /**
   * Fees findMany
   */
  export type FeesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null
    /**
     * Filter, which Fees to fetch.
     */
    where?: FeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fees to fetch.
     */
    orderBy?: FeesOrderByWithRelationInput | FeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fees.
     */
    cursor?: FeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fees.
     */
    skip?: number
    distinct?: FeesScalarFieldEnum | FeesScalarFieldEnum[]
  }

  /**
   * Fees create
   */
  export type FeesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null
    /**
     * The data needed to create a Fees.
     */
    data: XOR<FeesCreateInput, FeesUncheckedCreateInput>
  }

  /**
   * Fees createMany
   */
  export type FeesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fees.
     */
    data: FeesCreateManyInput | FeesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Fees createManyAndReturn
   */
  export type FeesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * The data used to create many Fees.
     */
    data: FeesCreateManyInput | FeesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Fees update
   */
  export type FeesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null
    /**
     * The data needed to update a Fees.
     */
    data: XOR<FeesUpdateInput, FeesUncheckedUpdateInput>
    /**
     * Choose, which Fees to update.
     */
    where: FeesWhereUniqueInput
  }

  /**
   * Fees updateMany
   */
  export type FeesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fees.
     */
    data: XOR<FeesUpdateManyMutationInput, FeesUncheckedUpdateManyInput>
    /**
     * Filter which Fees to update
     */
    where?: FeesWhereInput
    /**
     * Limit how many Fees to update.
     */
    limit?: number
  }

  /**
   * Fees updateManyAndReturn
   */
  export type FeesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * The data used to update Fees.
     */
    data: XOR<FeesUpdateManyMutationInput, FeesUncheckedUpdateManyInput>
    /**
     * Filter which Fees to update
     */
    where?: FeesWhereInput
    /**
     * Limit how many Fees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Fees upsert
   */
  export type FeesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null
    /**
     * The filter to search for the Fees to update in case it exists.
     */
    where: FeesWhereUniqueInput
    /**
     * In case the Fees found by the `where` argument doesn't exist, create a new Fees with this data.
     */
    create: XOR<FeesCreateInput, FeesUncheckedCreateInput>
    /**
     * In case the Fees was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeesUpdateInput, FeesUncheckedUpdateInput>
  }

  /**
   * Fees delete
   */
  export type FeesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null
    /**
     * Filter which Fees to delete.
     */
    where: FeesWhereUniqueInput
  }

  /**
   * Fees deleteMany
   */
  export type FeesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fees to delete
     */
    where?: FeesWhereInput
    /**
     * Limit how many Fees to delete.
     */
    limit?: number
  }

  /**
   * Fees.feeBreakdowns
   */
  export type Fees$feeBreakdownsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeBreakdown
     */
    select?: FeeBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeBreakdown
     */
    omit?: FeeBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeBreakdownInclude<ExtArgs> | null
    where?: FeeBreakdownWhereInput
    orderBy?: FeeBreakdownOrderByWithRelationInput | FeeBreakdownOrderByWithRelationInput[]
    cursor?: FeeBreakdownWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeeBreakdownScalarFieldEnum | FeeBreakdownScalarFieldEnum[]
  }

  /**
   * Fees without action
   */
  export type FeesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fees
     */
    select?: FeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fees
     */
    omit?: FeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeesInclude<ExtArgs> | null
  }


  /**
   * Model FeeBreakdown
   */

  export type AggregateFeeBreakdown = {
    _count: FeeBreakdownCountAggregateOutputType | null
    _avg: FeeBreakdownAvgAggregateOutputType | null
    _sum: FeeBreakdownSumAggregateOutputType | null
    _min: FeeBreakdownMinAggregateOutputType | null
    _max: FeeBreakdownMaxAggregateOutputType | null
  }

  export type FeeBreakdownAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type FeeBreakdownSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type FeeBreakdownMinAggregateOutputType = {
    id: string | null
    feeId: string | null
    title: string | null
    amount: Decimal | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeeBreakdownMaxAggregateOutputType = {
    id: string | null
    feeId: string | null
    title: string | null
    amount: Decimal | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeeBreakdownCountAggregateOutputType = {
    id: number
    feeId: number
    title: number
    amount: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeeBreakdownAvgAggregateInputType = {
    amount?: true
  }

  export type FeeBreakdownSumAggregateInputType = {
    amount?: true
  }

  export type FeeBreakdownMinAggregateInputType = {
    id?: true
    feeId?: true
    title?: true
    amount?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeeBreakdownMaxAggregateInputType = {
    id?: true
    feeId?: true
    title?: true
    amount?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeeBreakdownCountAggregateInputType = {
    id?: true
    feeId?: true
    title?: true
    amount?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeeBreakdownAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeBreakdown to aggregate.
     */
    where?: FeeBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeBreakdowns to fetch.
     */
    orderBy?: FeeBreakdownOrderByWithRelationInput | FeeBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeeBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeBreakdowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeeBreakdowns
    **/
    _count?: true | FeeBreakdownCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeeBreakdownAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeeBreakdownSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeeBreakdownMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeeBreakdownMaxAggregateInputType
  }

  export type GetFeeBreakdownAggregateType<T extends FeeBreakdownAggregateArgs> = {
        [P in keyof T & keyof AggregateFeeBreakdown]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeeBreakdown[P]>
      : GetScalarType<T[P], AggregateFeeBreakdown[P]>
  }




  export type FeeBreakdownGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeBreakdownWhereInput
    orderBy?: FeeBreakdownOrderByWithAggregationInput | FeeBreakdownOrderByWithAggregationInput[]
    by: FeeBreakdownScalarFieldEnum[] | FeeBreakdownScalarFieldEnum
    having?: FeeBreakdownScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeeBreakdownCountAggregateInputType | true
    _avg?: FeeBreakdownAvgAggregateInputType
    _sum?: FeeBreakdownSumAggregateInputType
    _min?: FeeBreakdownMinAggregateInputType
    _max?: FeeBreakdownMaxAggregateInputType
  }

  export type FeeBreakdownGroupByOutputType = {
    id: string
    feeId: string
    title: string
    amount: Decimal
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: FeeBreakdownCountAggregateOutputType | null
    _avg: FeeBreakdownAvgAggregateOutputType | null
    _sum: FeeBreakdownSumAggregateOutputType | null
    _min: FeeBreakdownMinAggregateOutputType | null
    _max: FeeBreakdownMaxAggregateOutputType | null
  }

  type GetFeeBreakdownGroupByPayload<T extends FeeBreakdownGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeeBreakdownGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeeBreakdownGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeeBreakdownGroupByOutputType[P]>
            : GetScalarType<T[P], FeeBreakdownGroupByOutputType[P]>
        }
      >
    >


  export type FeeBreakdownSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feeId?: boolean
    title?: boolean
    amount?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fee?: boolean | FeesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeBreakdown"]>

  export type FeeBreakdownSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feeId?: boolean
    title?: boolean
    amount?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fee?: boolean | FeesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeBreakdown"]>

  export type FeeBreakdownSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feeId?: boolean
    title?: boolean
    amount?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fee?: boolean | FeesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeBreakdown"]>

  export type FeeBreakdownSelectScalar = {
    id?: boolean
    feeId?: boolean
    title?: boolean
    amount?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeeBreakdownOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "feeId" | "title" | "amount" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["feeBreakdown"]>
  export type FeeBreakdownInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fee?: boolean | FeesDefaultArgs<ExtArgs>
  }
  export type FeeBreakdownIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fee?: boolean | FeesDefaultArgs<ExtArgs>
  }
  export type FeeBreakdownIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fee?: boolean | FeesDefaultArgs<ExtArgs>
  }

  export type $FeeBreakdownPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeeBreakdown"
    objects: {
      fee: Prisma.$FeesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      feeId: string
      title: string
      amount: Prisma.Decimal
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feeBreakdown"]>
    composites: {}
  }

  type FeeBreakdownGetPayload<S extends boolean | null | undefined | FeeBreakdownDefaultArgs> = $Result.GetResult<Prisma.$FeeBreakdownPayload, S>

  type FeeBreakdownCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeeBreakdownFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeeBreakdownCountAggregateInputType | true
    }

  export interface FeeBreakdownDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeeBreakdown'], meta: { name: 'FeeBreakdown' } }
    /**
     * Find zero or one FeeBreakdown that matches the filter.
     * @param {FeeBreakdownFindUniqueArgs} args - Arguments to find a FeeBreakdown
     * @example
     * // Get one FeeBreakdown
     * const feeBreakdown = await prisma.feeBreakdown.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeeBreakdownFindUniqueArgs>(args: SelectSubset<T, FeeBreakdownFindUniqueArgs<ExtArgs>>): Prisma__FeeBreakdownClient<$Result.GetResult<Prisma.$FeeBreakdownPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeeBreakdown that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeeBreakdownFindUniqueOrThrowArgs} args - Arguments to find a FeeBreakdown
     * @example
     * // Get one FeeBreakdown
     * const feeBreakdown = await prisma.feeBreakdown.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeeBreakdownFindUniqueOrThrowArgs>(args: SelectSubset<T, FeeBreakdownFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeeBreakdownClient<$Result.GetResult<Prisma.$FeeBreakdownPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeeBreakdown that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeBreakdownFindFirstArgs} args - Arguments to find a FeeBreakdown
     * @example
     * // Get one FeeBreakdown
     * const feeBreakdown = await prisma.feeBreakdown.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeeBreakdownFindFirstArgs>(args?: SelectSubset<T, FeeBreakdownFindFirstArgs<ExtArgs>>): Prisma__FeeBreakdownClient<$Result.GetResult<Prisma.$FeeBreakdownPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeeBreakdown that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeBreakdownFindFirstOrThrowArgs} args - Arguments to find a FeeBreakdown
     * @example
     * // Get one FeeBreakdown
     * const feeBreakdown = await prisma.feeBreakdown.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeeBreakdownFindFirstOrThrowArgs>(args?: SelectSubset<T, FeeBreakdownFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeeBreakdownClient<$Result.GetResult<Prisma.$FeeBreakdownPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeeBreakdowns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeBreakdownFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeeBreakdowns
     * const feeBreakdowns = await prisma.feeBreakdown.findMany()
     * 
     * // Get first 10 FeeBreakdowns
     * const feeBreakdowns = await prisma.feeBreakdown.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feeBreakdownWithIdOnly = await prisma.feeBreakdown.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeeBreakdownFindManyArgs>(args?: SelectSubset<T, FeeBreakdownFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeBreakdownPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeeBreakdown.
     * @param {FeeBreakdownCreateArgs} args - Arguments to create a FeeBreakdown.
     * @example
     * // Create one FeeBreakdown
     * const FeeBreakdown = await prisma.feeBreakdown.create({
     *   data: {
     *     // ... data to create a FeeBreakdown
     *   }
     * })
     * 
     */
    create<T extends FeeBreakdownCreateArgs>(args: SelectSubset<T, FeeBreakdownCreateArgs<ExtArgs>>): Prisma__FeeBreakdownClient<$Result.GetResult<Prisma.$FeeBreakdownPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeeBreakdowns.
     * @param {FeeBreakdownCreateManyArgs} args - Arguments to create many FeeBreakdowns.
     * @example
     * // Create many FeeBreakdowns
     * const feeBreakdown = await prisma.feeBreakdown.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeeBreakdownCreateManyArgs>(args?: SelectSubset<T, FeeBreakdownCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeeBreakdowns and returns the data saved in the database.
     * @param {FeeBreakdownCreateManyAndReturnArgs} args - Arguments to create many FeeBreakdowns.
     * @example
     * // Create many FeeBreakdowns
     * const feeBreakdown = await prisma.feeBreakdown.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeeBreakdowns and only return the `id`
     * const feeBreakdownWithIdOnly = await prisma.feeBreakdown.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeeBreakdownCreateManyAndReturnArgs>(args?: SelectSubset<T, FeeBreakdownCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeBreakdownPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeeBreakdown.
     * @param {FeeBreakdownDeleteArgs} args - Arguments to delete one FeeBreakdown.
     * @example
     * // Delete one FeeBreakdown
     * const FeeBreakdown = await prisma.feeBreakdown.delete({
     *   where: {
     *     // ... filter to delete one FeeBreakdown
     *   }
     * })
     * 
     */
    delete<T extends FeeBreakdownDeleteArgs>(args: SelectSubset<T, FeeBreakdownDeleteArgs<ExtArgs>>): Prisma__FeeBreakdownClient<$Result.GetResult<Prisma.$FeeBreakdownPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeeBreakdown.
     * @param {FeeBreakdownUpdateArgs} args - Arguments to update one FeeBreakdown.
     * @example
     * // Update one FeeBreakdown
     * const feeBreakdown = await prisma.feeBreakdown.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeeBreakdownUpdateArgs>(args: SelectSubset<T, FeeBreakdownUpdateArgs<ExtArgs>>): Prisma__FeeBreakdownClient<$Result.GetResult<Prisma.$FeeBreakdownPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeeBreakdowns.
     * @param {FeeBreakdownDeleteManyArgs} args - Arguments to filter FeeBreakdowns to delete.
     * @example
     * // Delete a few FeeBreakdowns
     * const { count } = await prisma.feeBreakdown.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeeBreakdownDeleteManyArgs>(args?: SelectSubset<T, FeeBreakdownDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeBreakdowns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeBreakdownUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeeBreakdowns
     * const feeBreakdown = await prisma.feeBreakdown.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeeBreakdownUpdateManyArgs>(args: SelectSubset<T, FeeBreakdownUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeBreakdowns and returns the data updated in the database.
     * @param {FeeBreakdownUpdateManyAndReturnArgs} args - Arguments to update many FeeBreakdowns.
     * @example
     * // Update many FeeBreakdowns
     * const feeBreakdown = await prisma.feeBreakdown.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeeBreakdowns and only return the `id`
     * const feeBreakdownWithIdOnly = await prisma.feeBreakdown.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeeBreakdownUpdateManyAndReturnArgs>(args: SelectSubset<T, FeeBreakdownUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeBreakdownPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeeBreakdown.
     * @param {FeeBreakdownUpsertArgs} args - Arguments to update or create a FeeBreakdown.
     * @example
     * // Update or create a FeeBreakdown
     * const feeBreakdown = await prisma.feeBreakdown.upsert({
     *   create: {
     *     // ... data to create a FeeBreakdown
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeeBreakdown we want to update
     *   }
     * })
     */
    upsert<T extends FeeBreakdownUpsertArgs>(args: SelectSubset<T, FeeBreakdownUpsertArgs<ExtArgs>>): Prisma__FeeBreakdownClient<$Result.GetResult<Prisma.$FeeBreakdownPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeeBreakdowns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeBreakdownCountArgs} args - Arguments to filter FeeBreakdowns to count.
     * @example
     * // Count the number of FeeBreakdowns
     * const count = await prisma.feeBreakdown.count({
     *   where: {
     *     // ... the filter for the FeeBreakdowns we want to count
     *   }
     * })
    **/
    count<T extends FeeBreakdownCountArgs>(
      args?: Subset<T, FeeBreakdownCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeeBreakdownCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeeBreakdown.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeBreakdownAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeeBreakdownAggregateArgs>(args: Subset<T, FeeBreakdownAggregateArgs>): Prisma.PrismaPromise<GetFeeBreakdownAggregateType<T>>

    /**
     * Group by FeeBreakdown.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeBreakdownGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeeBreakdownGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeeBreakdownGroupByArgs['orderBy'] }
        : { orderBy?: FeeBreakdownGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeeBreakdownGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeeBreakdownGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeeBreakdown model
   */
  readonly fields: FeeBreakdownFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeeBreakdown.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeeBreakdownClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fee<T extends FeesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeesDefaultArgs<ExtArgs>>): Prisma__FeesClient<$Result.GetResult<Prisma.$FeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeeBreakdown model
   */
  interface FeeBreakdownFieldRefs {
    readonly id: FieldRef<"FeeBreakdown", 'String'>
    readonly feeId: FieldRef<"FeeBreakdown", 'String'>
    readonly title: FieldRef<"FeeBreakdown", 'String'>
    readonly amount: FieldRef<"FeeBreakdown", 'Decimal'>
    readonly isDeleted: FieldRef<"FeeBreakdown", 'Boolean'>
    readonly createdAt: FieldRef<"FeeBreakdown", 'DateTime'>
    readonly updatedAt: FieldRef<"FeeBreakdown", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeeBreakdown findUnique
   */
  export type FeeBreakdownFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeBreakdown
     */
    select?: FeeBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeBreakdown
     */
    omit?: FeeBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which FeeBreakdown to fetch.
     */
    where: FeeBreakdownWhereUniqueInput
  }

  /**
   * FeeBreakdown findUniqueOrThrow
   */
  export type FeeBreakdownFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeBreakdown
     */
    select?: FeeBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeBreakdown
     */
    omit?: FeeBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which FeeBreakdown to fetch.
     */
    where: FeeBreakdownWhereUniqueInput
  }

  /**
   * FeeBreakdown findFirst
   */
  export type FeeBreakdownFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeBreakdown
     */
    select?: FeeBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeBreakdown
     */
    omit?: FeeBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which FeeBreakdown to fetch.
     */
    where?: FeeBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeBreakdowns to fetch.
     */
    orderBy?: FeeBreakdownOrderByWithRelationInput | FeeBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeBreakdowns.
     */
    cursor?: FeeBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeBreakdowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeBreakdowns.
     */
    distinct?: FeeBreakdownScalarFieldEnum | FeeBreakdownScalarFieldEnum[]
  }

  /**
   * FeeBreakdown findFirstOrThrow
   */
  export type FeeBreakdownFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeBreakdown
     */
    select?: FeeBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeBreakdown
     */
    omit?: FeeBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which FeeBreakdown to fetch.
     */
    where?: FeeBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeBreakdowns to fetch.
     */
    orderBy?: FeeBreakdownOrderByWithRelationInput | FeeBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeBreakdowns.
     */
    cursor?: FeeBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeBreakdowns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeBreakdowns.
     */
    distinct?: FeeBreakdownScalarFieldEnum | FeeBreakdownScalarFieldEnum[]
  }

  /**
   * FeeBreakdown findMany
   */
  export type FeeBreakdownFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeBreakdown
     */
    select?: FeeBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeBreakdown
     */
    omit?: FeeBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeBreakdownInclude<ExtArgs> | null
    /**
     * Filter, which FeeBreakdowns to fetch.
     */
    where?: FeeBreakdownWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeBreakdowns to fetch.
     */
    orderBy?: FeeBreakdownOrderByWithRelationInput | FeeBreakdownOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeeBreakdowns.
     */
    cursor?: FeeBreakdownWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeBreakdowns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeBreakdowns.
     */
    skip?: number
    distinct?: FeeBreakdownScalarFieldEnum | FeeBreakdownScalarFieldEnum[]
  }

  /**
   * FeeBreakdown create
   */
  export type FeeBreakdownCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeBreakdown
     */
    select?: FeeBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeBreakdown
     */
    omit?: FeeBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeBreakdownInclude<ExtArgs> | null
    /**
     * The data needed to create a FeeBreakdown.
     */
    data: XOR<FeeBreakdownCreateInput, FeeBreakdownUncheckedCreateInput>
  }

  /**
   * FeeBreakdown createMany
   */
  export type FeeBreakdownCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeeBreakdowns.
     */
    data: FeeBreakdownCreateManyInput | FeeBreakdownCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeeBreakdown createManyAndReturn
   */
  export type FeeBreakdownCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeBreakdown
     */
    select?: FeeBreakdownSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeeBreakdown
     */
    omit?: FeeBreakdownOmit<ExtArgs> | null
    /**
     * The data used to create many FeeBreakdowns.
     */
    data: FeeBreakdownCreateManyInput | FeeBreakdownCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeBreakdownIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeeBreakdown update
   */
  export type FeeBreakdownUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeBreakdown
     */
    select?: FeeBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeBreakdown
     */
    omit?: FeeBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeBreakdownInclude<ExtArgs> | null
    /**
     * The data needed to update a FeeBreakdown.
     */
    data: XOR<FeeBreakdownUpdateInput, FeeBreakdownUncheckedUpdateInput>
    /**
     * Choose, which FeeBreakdown to update.
     */
    where: FeeBreakdownWhereUniqueInput
  }

  /**
   * FeeBreakdown updateMany
   */
  export type FeeBreakdownUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeeBreakdowns.
     */
    data: XOR<FeeBreakdownUpdateManyMutationInput, FeeBreakdownUncheckedUpdateManyInput>
    /**
     * Filter which FeeBreakdowns to update
     */
    where?: FeeBreakdownWhereInput
    /**
     * Limit how many FeeBreakdowns to update.
     */
    limit?: number
  }

  /**
   * FeeBreakdown updateManyAndReturn
   */
  export type FeeBreakdownUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeBreakdown
     */
    select?: FeeBreakdownSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeeBreakdown
     */
    omit?: FeeBreakdownOmit<ExtArgs> | null
    /**
     * The data used to update FeeBreakdowns.
     */
    data: XOR<FeeBreakdownUpdateManyMutationInput, FeeBreakdownUncheckedUpdateManyInput>
    /**
     * Filter which FeeBreakdowns to update
     */
    where?: FeeBreakdownWhereInput
    /**
     * Limit how many FeeBreakdowns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeBreakdownIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeeBreakdown upsert
   */
  export type FeeBreakdownUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeBreakdown
     */
    select?: FeeBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeBreakdown
     */
    omit?: FeeBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeBreakdownInclude<ExtArgs> | null
    /**
     * The filter to search for the FeeBreakdown to update in case it exists.
     */
    where: FeeBreakdownWhereUniqueInput
    /**
     * In case the FeeBreakdown found by the `where` argument doesn't exist, create a new FeeBreakdown with this data.
     */
    create: XOR<FeeBreakdownCreateInput, FeeBreakdownUncheckedCreateInput>
    /**
     * In case the FeeBreakdown was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeeBreakdownUpdateInput, FeeBreakdownUncheckedUpdateInput>
  }

  /**
   * FeeBreakdown delete
   */
  export type FeeBreakdownDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeBreakdown
     */
    select?: FeeBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeBreakdown
     */
    omit?: FeeBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeBreakdownInclude<ExtArgs> | null
    /**
     * Filter which FeeBreakdown to delete.
     */
    where: FeeBreakdownWhereUniqueInput
  }

  /**
   * FeeBreakdown deleteMany
   */
  export type FeeBreakdownDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeBreakdowns to delete
     */
    where?: FeeBreakdownWhereInput
    /**
     * Limit how many FeeBreakdowns to delete.
     */
    limit?: number
  }

  /**
   * FeeBreakdown without action
   */
  export type FeeBreakdownDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeBreakdown
     */
    select?: FeeBreakdownSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeBreakdown
     */
    omit?: FeeBreakdownOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeBreakdownInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    invoiceNo: string | null
    feeId: string | null
    guardianId: string | null
    classId: string | null
    sessionId: string | null
    termId: string | null
    totalAmount: Decimal | null
    status: $Enums.InvoiceStatus | null
    dueAt: Date | null
    paidAt: Date | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    invoiceNo: string | null
    feeId: string | null
    guardianId: string | null
    classId: string | null
    sessionId: string | null
    termId: string | null
    totalAmount: Decimal | null
    status: $Enums.InvoiceStatus | null
    dueAt: Date | null
    paidAt: Date | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    invoiceNo: number
    feeId: number
    guardianId: number
    classId: number
    sessionId: number
    termId: number
    totalAmount: number
    status: number
    dueAt: number
    paidAt: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    totalAmount?: true
  }

  export type InvoiceSumAggregateInputType = {
    totalAmount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    invoiceNo?: true
    feeId?: true
    guardianId?: true
    classId?: true
    sessionId?: true
    termId?: true
    totalAmount?: true
    status?: true
    dueAt?: true
    paidAt?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    invoiceNo?: true
    feeId?: true
    guardianId?: true
    classId?: true
    sessionId?: true
    termId?: true
    totalAmount?: true
    status?: true
    dueAt?: true
    paidAt?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    invoiceNo?: true
    feeId?: true
    guardianId?: true
    classId?: true
    sessionId?: true
    termId?: true
    totalAmount?: true
    status?: true
    dueAt?: true
    paidAt?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    invoiceNo: string
    feeId: string
    guardianId: string
    classId: string
    sessionId: string
    termId: string
    totalAmount: Decimal
    status: $Enums.InvoiceStatus
    dueAt: Date
    paidAt: Date | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNo?: boolean
    feeId?: boolean
    guardianId?: boolean
    classId?: boolean
    sessionId?: boolean
    termId?: boolean
    totalAmount?: boolean
    status?: boolean
    dueAt?: boolean
    paidAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    guardian?: boolean | GuardianDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicSession?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    term?: boolean | TermDefaultArgs<ExtArgs>
    transactions?: boolean | Invoice$transactionsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNo?: boolean
    feeId?: boolean
    guardianId?: boolean
    classId?: boolean
    sessionId?: boolean
    termId?: boolean
    totalAmount?: boolean
    status?: boolean
    dueAt?: boolean
    paidAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    guardian?: boolean | GuardianDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicSession?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    term?: boolean | TermDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNo?: boolean
    feeId?: boolean
    guardianId?: boolean
    classId?: boolean
    sessionId?: boolean
    termId?: boolean
    totalAmount?: boolean
    status?: boolean
    dueAt?: boolean
    paidAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    guardian?: boolean | GuardianDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicSession?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    term?: boolean | TermDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    invoiceNo?: boolean
    feeId?: boolean
    guardianId?: boolean
    classId?: boolean
    sessionId?: boolean
    termId?: boolean
    totalAmount?: boolean
    status?: boolean
    dueAt?: boolean
    paidAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceNo" | "feeId" | "guardianId" | "classId" | "sessionId" | "termId" | "totalAmount" | "status" | "dueAt" | "paidAt" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guardian?: boolean | GuardianDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicSession?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    term?: boolean | TermDefaultArgs<ExtArgs>
    transactions?: boolean | Invoice$transactionsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guardian?: boolean | GuardianDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicSession?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    term?: boolean | TermDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guardian?: boolean | GuardianDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    academicSession?: boolean | AcademicSessionDefaultArgs<ExtArgs>
    term?: boolean | TermDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      guardian: Prisma.$GuardianPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
      academicSession: Prisma.$AcademicSessionPayload<ExtArgs>
      term: Prisma.$TermPayload<ExtArgs>
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceNo: string
      feeId: string
      guardianId: string
      classId: string
      sessionId: string
      termId: string
      totalAmount: Prisma.Decimal
      status: $Enums.InvoiceStatus
      dueAt: Date
      paidAt: Date | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    guardian<T extends GuardianDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuardianDefaultArgs<ExtArgs>>): Prisma__GuardianClient<$Result.GetResult<Prisma.$GuardianPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    academicSession<T extends AcademicSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademicSessionDefaultArgs<ExtArgs>>): Prisma__AcademicSessionClient<$Result.GetResult<Prisma.$AcademicSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    term<T extends TermDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TermDefaultArgs<ExtArgs>>): Prisma__TermClient<$Result.GetResult<Prisma.$TermPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactions<T extends Invoice$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly invoiceNo: FieldRef<"Invoice", 'String'>
    readonly feeId: FieldRef<"Invoice", 'String'>
    readonly guardianId: FieldRef<"Invoice", 'String'>
    readonly classId: FieldRef<"Invoice", 'String'>
    readonly sessionId: FieldRef<"Invoice", 'String'>
    readonly termId: FieldRef<"Invoice", 'String'>
    readonly totalAmount: FieldRef<"Invoice", 'Decimal'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly dueAt: FieldRef<"Invoice", 'DateTime'>
    readonly paidAt: FieldRef<"Invoice", 'DateTime'>
    readonly isDeleted: FieldRef<"Invoice", 'Boolean'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.transactions
   */
  export type Invoice$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    image: string | null
    classId: string | null
    guardianId: string | null
    registrationNumber: string | null
    status: $Enums.StudentStatus | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    image: string | null
    classId: string | null
    guardianId: string | null
    registrationNumber: string | null
    status: $Enums.StudentStatus | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    image: number
    classId: number
    guardianId: number
    registrationNumber: number
    status: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    image?: true
    classId?: true
    guardianId?: true
    registrationNumber?: true
    status?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    image?: true
    classId?: true
    guardianId?: true
    registrationNumber?: true
    status?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    image?: true
    classId?: true
    guardianId?: true
    registrationNumber?: true
    status?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    image: string | null
    classId: string
    guardianId: string | null
    registrationNumber: string
    status: $Enums.StudentStatus
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    image?: boolean
    classId?: boolean
    guardianId?: boolean
    registrationNumber?: boolean
    status?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    guardian?: boolean | Student$guardianArgs<ExtArgs>
    linkedStudentProfile?: boolean | Student$linkedStudentProfileArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    image?: boolean
    classId?: boolean
    guardianId?: boolean
    registrationNumber?: boolean
    status?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    guardian?: boolean | Student$guardianArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    image?: boolean
    classId?: boolean
    guardianId?: boolean
    registrationNumber?: boolean
    status?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    guardian?: boolean | Student$guardianArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    image?: boolean
    classId?: boolean
    guardianId?: boolean
    registrationNumber?: boolean
    status?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "image" | "classId" | "guardianId" | "registrationNumber" | "status" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["student"]>
  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    guardian?: boolean | Student$guardianArgs<ExtArgs>
    linkedStudentProfile?: boolean | Student$linkedStudentProfileArgs<ExtArgs>
  }
  export type StudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    guardian?: boolean | Student$guardianArgs<ExtArgs>
  }
  export type StudentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    guardian?: boolean | Student$guardianArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs>
      guardian: Prisma.$GuardianPayload<ExtArgs> | null
      linkedStudentProfile: Prisma.$LinkedStudentProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      image: string | null
      classId: string
      guardianId: string | null
      registrationNumber: string
      status: $Enums.StudentStatus
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students and returns the data updated in the database.
     * @param {StudentUpdateManyAndReturnArgs} args - Arguments to update many Students.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    guardian<T extends Student$guardianArgs<ExtArgs> = {}>(args?: Subset<T, Student$guardianArgs<ExtArgs>>): Prisma__GuardianClient<$Result.GetResult<Prisma.$GuardianPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    linkedStudentProfile<T extends Student$linkedStudentProfileArgs<ExtArgs> = {}>(args?: Subset<T, Student$linkedStudentProfileArgs<ExtArgs>>): Prisma__LinkedStudentProfileClient<$Result.GetResult<Prisma.$LinkedStudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly firstName: FieldRef<"Student", 'String'>
    readonly lastName: FieldRef<"Student", 'String'>
    readonly image: FieldRef<"Student", 'String'>
    readonly classId: FieldRef<"Student", 'String'>
    readonly guardianId: FieldRef<"Student", 'String'>
    readonly registrationNumber: FieldRef<"Student", 'String'>
    readonly status: FieldRef<"Student", 'StudentStatus'>
    readonly isDeleted: FieldRef<"Student", 'Boolean'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Student createManyAndReturn
   */
  export type StudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
  }

  /**
   * Student updateManyAndReturn
   */
  export type StudentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to delete.
     */
    limit?: number
  }

  /**
   * Student.guardian
   */
  export type Student$guardianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Guardian
     */
    select?: GuardianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Guardian
     */
    omit?: GuardianOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuardianInclude<ExtArgs> | null
    where?: GuardianWhereInput
  }

  /**
   * Student.linkedStudentProfile
   */
  export type Student$linkedStudentProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedStudentProfile
     */
    select?: LinkedStudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedStudentProfile
     */
    omit?: LinkedStudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedStudentProfileInclude<ExtArgs> | null
    where?: LinkedStudentProfileWhereInput
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model LinkedStudentProfile
   */

  export type AggregateLinkedStudentProfile = {
    _count: LinkedStudentProfileCountAggregateOutputType | null
    _min: LinkedStudentProfileMinAggregateOutputType | null
    _max: LinkedStudentProfileMaxAggregateOutputType | null
  }

  export type LinkedStudentProfileMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    guardianId: string | null
    lastGuardiantChanged: Date | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LinkedStudentProfileMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    guardianId: string | null
    lastGuardiantChanged: Date | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LinkedStudentProfileCountAggregateOutputType = {
    id: number
    studentId: number
    guardianId: number
    lastGuardiantChanged: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LinkedStudentProfileMinAggregateInputType = {
    id?: true
    studentId?: true
    guardianId?: true
    lastGuardiantChanged?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LinkedStudentProfileMaxAggregateInputType = {
    id?: true
    studentId?: true
    guardianId?: true
    lastGuardiantChanged?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LinkedStudentProfileCountAggregateInputType = {
    id?: true
    studentId?: true
    guardianId?: true
    lastGuardiantChanged?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LinkedStudentProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LinkedStudentProfile to aggregate.
     */
    where?: LinkedStudentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkedStudentProfiles to fetch.
     */
    orderBy?: LinkedStudentProfileOrderByWithRelationInput | LinkedStudentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LinkedStudentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkedStudentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkedStudentProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LinkedStudentProfiles
    **/
    _count?: true | LinkedStudentProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LinkedStudentProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LinkedStudentProfileMaxAggregateInputType
  }

  export type GetLinkedStudentProfileAggregateType<T extends LinkedStudentProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateLinkedStudentProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLinkedStudentProfile[P]>
      : GetScalarType<T[P], AggregateLinkedStudentProfile[P]>
  }




  export type LinkedStudentProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinkedStudentProfileWhereInput
    orderBy?: LinkedStudentProfileOrderByWithAggregationInput | LinkedStudentProfileOrderByWithAggregationInput[]
    by: LinkedStudentProfileScalarFieldEnum[] | LinkedStudentProfileScalarFieldEnum
    having?: LinkedStudentProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LinkedStudentProfileCountAggregateInputType | true
    _min?: LinkedStudentProfileMinAggregateInputType
    _max?: LinkedStudentProfileMaxAggregateInputType
  }

  export type LinkedStudentProfileGroupByOutputType = {
    id: string
    studentId: string
    guardianId: string
    lastGuardiantChanged: Date
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: LinkedStudentProfileCountAggregateOutputType | null
    _min: LinkedStudentProfileMinAggregateOutputType | null
    _max: LinkedStudentProfileMaxAggregateOutputType | null
  }

  type GetLinkedStudentProfileGroupByPayload<T extends LinkedStudentProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LinkedStudentProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LinkedStudentProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LinkedStudentProfileGroupByOutputType[P]>
            : GetScalarType<T[P], LinkedStudentProfileGroupByOutputType[P]>
        }
      >
    >


  export type LinkedStudentProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    guardianId?: boolean
    lastGuardiantChanged?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    guardian?: boolean | GuardianDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linkedStudentProfile"]>

  export type LinkedStudentProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    guardianId?: boolean
    lastGuardiantChanged?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    guardian?: boolean | GuardianDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linkedStudentProfile"]>

  export type LinkedStudentProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    guardianId?: boolean
    lastGuardiantChanged?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    guardian?: boolean | GuardianDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linkedStudentProfile"]>

  export type LinkedStudentProfileSelectScalar = {
    id?: boolean
    studentId?: boolean
    guardianId?: boolean
    lastGuardiantChanged?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LinkedStudentProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "guardianId" | "lastGuardiantChanged" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["linkedStudentProfile"]>
  export type LinkedStudentProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    guardian?: boolean | GuardianDefaultArgs<ExtArgs>
  }
  export type LinkedStudentProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    guardian?: boolean | GuardianDefaultArgs<ExtArgs>
  }
  export type LinkedStudentProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    guardian?: boolean | GuardianDefaultArgs<ExtArgs>
  }

  export type $LinkedStudentProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LinkedStudentProfile"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      guardian: Prisma.$GuardianPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      guardianId: string
      lastGuardiantChanged: Date
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["linkedStudentProfile"]>
    composites: {}
  }

  type LinkedStudentProfileGetPayload<S extends boolean | null | undefined | LinkedStudentProfileDefaultArgs> = $Result.GetResult<Prisma.$LinkedStudentProfilePayload, S>

  type LinkedStudentProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LinkedStudentProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LinkedStudentProfileCountAggregateInputType | true
    }

  export interface LinkedStudentProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LinkedStudentProfile'], meta: { name: 'LinkedStudentProfile' } }
    /**
     * Find zero or one LinkedStudentProfile that matches the filter.
     * @param {LinkedStudentProfileFindUniqueArgs} args - Arguments to find a LinkedStudentProfile
     * @example
     * // Get one LinkedStudentProfile
     * const linkedStudentProfile = await prisma.linkedStudentProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LinkedStudentProfileFindUniqueArgs>(args: SelectSubset<T, LinkedStudentProfileFindUniqueArgs<ExtArgs>>): Prisma__LinkedStudentProfileClient<$Result.GetResult<Prisma.$LinkedStudentProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LinkedStudentProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LinkedStudentProfileFindUniqueOrThrowArgs} args - Arguments to find a LinkedStudentProfile
     * @example
     * // Get one LinkedStudentProfile
     * const linkedStudentProfile = await prisma.linkedStudentProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LinkedStudentProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, LinkedStudentProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LinkedStudentProfileClient<$Result.GetResult<Prisma.$LinkedStudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LinkedStudentProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedStudentProfileFindFirstArgs} args - Arguments to find a LinkedStudentProfile
     * @example
     * // Get one LinkedStudentProfile
     * const linkedStudentProfile = await prisma.linkedStudentProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LinkedStudentProfileFindFirstArgs>(args?: SelectSubset<T, LinkedStudentProfileFindFirstArgs<ExtArgs>>): Prisma__LinkedStudentProfileClient<$Result.GetResult<Prisma.$LinkedStudentProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LinkedStudentProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedStudentProfileFindFirstOrThrowArgs} args - Arguments to find a LinkedStudentProfile
     * @example
     * // Get one LinkedStudentProfile
     * const linkedStudentProfile = await prisma.linkedStudentProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LinkedStudentProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, LinkedStudentProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__LinkedStudentProfileClient<$Result.GetResult<Prisma.$LinkedStudentProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LinkedStudentProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedStudentProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LinkedStudentProfiles
     * const linkedStudentProfiles = await prisma.linkedStudentProfile.findMany()
     * 
     * // Get first 10 LinkedStudentProfiles
     * const linkedStudentProfiles = await prisma.linkedStudentProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const linkedStudentProfileWithIdOnly = await prisma.linkedStudentProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LinkedStudentProfileFindManyArgs>(args?: SelectSubset<T, LinkedStudentProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkedStudentProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LinkedStudentProfile.
     * @param {LinkedStudentProfileCreateArgs} args - Arguments to create a LinkedStudentProfile.
     * @example
     * // Create one LinkedStudentProfile
     * const LinkedStudentProfile = await prisma.linkedStudentProfile.create({
     *   data: {
     *     // ... data to create a LinkedStudentProfile
     *   }
     * })
     * 
     */
    create<T extends LinkedStudentProfileCreateArgs>(args: SelectSubset<T, LinkedStudentProfileCreateArgs<ExtArgs>>): Prisma__LinkedStudentProfileClient<$Result.GetResult<Prisma.$LinkedStudentProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LinkedStudentProfiles.
     * @param {LinkedStudentProfileCreateManyArgs} args - Arguments to create many LinkedStudentProfiles.
     * @example
     * // Create many LinkedStudentProfiles
     * const linkedStudentProfile = await prisma.linkedStudentProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LinkedStudentProfileCreateManyArgs>(args?: SelectSubset<T, LinkedStudentProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LinkedStudentProfiles and returns the data saved in the database.
     * @param {LinkedStudentProfileCreateManyAndReturnArgs} args - Arguments to create many LinkedStudentProfiles.
     * @example
     * // Create many LinkedStudentProfiles
     * const linkedStudentProfile = await prisma.linkedStudentProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LinkedStudentProfiles and only return the `id`
     * const linkedStudentProfileWithIdOnly = await prisma.linkedStudentProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LinkedStudentProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, LinkedStudentProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkedStudentProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LinkedStudentProfile.
     * @param {LinkedStudentProfileDeleteArgs} args - Arguments to delete one LinkedStudentProfile.
     * @example
     * // Delete one LinkedStudentProfile
     * const LinkedStudentProfile = await prisma.linkedStudentProfile.delete({
     *   where: {
     *     // ... filter to delete one LinkedStudentProfile
     *   }
     * })
     * 
     */
    delete<T extends LinkedStudentProfileDeleteArgs>(args: SelectSubset<T, LinkedStudentProfileDeleteArgs<ExtArgs>>): Prisma__LinkedStudentProfileClient<$Result.GetResult<Prisma.$LinkedStudentProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LinkedStudentProfile.
     * @param {LinkedStudentProfileUpdateArgs} args - Arguments to update one LinkedStudentProfile.
     * @example
     * // Update one LinkedStudentProfile
     * const linkedStudentProfile = await prisma.linkedStudentProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LinkedStudentProfileUpdateArgs>(args: SelectSubset<T, LinkedStudentProfileUpdateArgs<ExtArgs>>): Prisma__LinkedStudentProfileClient<$Result.GetResult<Prisma.$LinkedStudentProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LinkedStudentProfiles.
     * @param {LinkedStudentProfileDeleteManyArgs} args - Arguments to filter LinkedStudentProfiles to delete.
     * @example
     * // Delete a few LinkedStudentProfiles
     * const { count } = await prisma.linkedStudentProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LinkedStudentProfileDeleteManyArgs>(args?: SelectSubset<T, LinkedStudentProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LinkedStudentProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedStudentProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LinkedStudentProfiles
     * const linkedStudentProfile = await prisma.linkedStudentProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LinkedStudentProfileUpdateManyArgs>(args: SelectSubset<T, LinkedStudentProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LinkedStudentProfiles and returns the data updated in the database.
     * @param {LinkedStudentProfileUpdateManyAndReturnArgs} args - Arguments to update many LinkedStudentProfiles.
     * @example
     * // Update many LinkedStudentProfiles
     * const linkedStudentProfile = await prisma.linkedStudentProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LinkedStudentProfiles and only return the `id`
     * const linkedStudentProfileWithIdOnly = await prisma.linkedStudentProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LinkedStudentProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, LinkedStudentProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkedStudentProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LinkedStudentProfile.
     * @param {LinkedStudentProfileUpsertArgs} args - Arguments to update or create a LinkedStudentProfile.
     * @example
     * // Update or create a LinkedStudentProfile
     * const linkedStudentProfile = await prisma.linkedStudentProfile.upsert({
     *   create: {
     *     // ... data to create a LinkedStudentProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LinkedStudentProfile we want to update
     *   }
     * })
     */
    upsert<T extends LinkedStudentProfileUpsertArgs>(args: SelectSubset<T, LinkedStudentProfileUpsertArgs<ExtArgs>>): Prisma__LinkedStudentProfileClient<$Result.GetResult<Prisma.$LinkedStudentProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LinkedStudentProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedStudentProfileCountArgs} args - Arguments to filter LinkedStudentProfiles to count.
     * @example
     * // Count the number of LinkedStudentProfiles
     * const count = await prisma.linkedStudentProfile.count({
     *   where: {
     *     // ... the filter for the LinkedStudentProfiles we want to count
     *   }
     * })
    **/
    count<T extends LinkedStudentProfileCountArgs>(
      args?: Subset<T, LinkedStudentProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LinkedStudentProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LinkedStudentProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedStudentProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LinkedStudentProfileAggregateArgs>(args: Subset<T, LinkedStudentProfileAggregateArgs>): Prisma.PrismaPromise<GetLinkedStudentProfileAggregateType<T>>

    /**
     * Group by LinkedStudentProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedStudentProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LinkedStudentProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LinkedStudentProfileGroupByArgs['orderBy'] }
        : { orderBy?: LinkedStudentProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LinkedStudentProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLinkedStudentProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LinkedStudentProfile model
   */
  readonly fields: LinkedStudentProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LinkedStudentProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LinkedStudentProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    guardian<T extends GuardianDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuardianDefaultArgs<ExtArgs>>): Prisma__GuardianClient<$Result.GetResult<Prisma.$GuardianPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LinkedStudentProfile model
   */
  interface LinkedStudentProfileFieldRefs {
    readonly id: FieldRef<"LinkedStudentProfile", 'String'>
    readonly studentId: FieldRef<"LinkedStudentProfile", 'String'>
    readonly guardianId: FieldRef<"LinkedStudentProfile", 'String'>
    readonly lastGuardiantChanged: FieldRef<"LinkedStudentProfile", 'DateTime'>
    readonly isDeleted: FieldRef<"LinkedStudentProfile", 'Boolean'>
    readonly createdAt: FieldRef<"LinkedStudentProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"LinkedStudentProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LinkedStudentProfile findUnique
   */
  export type LinkedStudentProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedStudentProfile
     */
    select?: LinkedStudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedStudentProfile
     */
    omit?: LinkedStudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedStudentProfileInclude<ExtArgs> | null
    /**
     * Filter, which LinkedStudentProfile to fetch.
     */
    where: LinkedStudentProfileWhereUniqueInput
  }

  /**
   * LinkedStudentProfile findUniqueOrThrow
   */
  export type LinkedStudentProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedStudentProfile
     */
    select?: LinkedStudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedStudentProfile
     */
    omit?: LinkedStudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedStudentProfileInclude<ExtArgs> | null
    /**
     * Filter, which LinkedStudentProfile to fetch.
     */
    where: LinkedStudentProfileWhereUniqueInput
  }

  /**
   * LinkedStudentProfile findFirst
   */
  export type LinkedStudentProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedStudentProfile
     */
    select?: LinkedStudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedStudentProfile
     */
    omit?: LinkedStudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedStudentProfileInclude<ExtArgs> | null
    /**
     * Filter, which LinkedStudentProfile to fetch.
     */
    where?: LinkedStudentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkedStudentProfiles to fetch.
     */
    orderBy?: LinkedStudentProfileOrderByWithRelationInput | LinkedStudentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LinkedStudentProfiles.
     */
    cursor?: LinkedStudentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkedStudentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkedStudentProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LinkedStudentProfiles.
     */
    distinct?: LinkedStudentProfileScalarFieldEnum | LinkedStudentProfileScalarFieldEnum[]
  }

  /**
   * LinkedStudentProfile findFirstOrThrow
   */
  export type LinkedStudentProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedStudentProfile
     */
    select?: LinkedStudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedStudentProfile
     */
    omit?: LinkedStudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedStudentProfileInclude<ExtArgs> | null
    /**
     * Filter, which LinkedStudentProfile to fetch.
     */
    where?: LinkedStudentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkedStudentProfiles to fetch.
     */
    orderBy?: LinkedStudentProfileOrderByWithRelationInput | LinkedStudentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LinkedStudentProfiles.
     */
    cursor?: LinkedStudentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkedStudentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkedStudentProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LinkedStudentProfiles.
     */
    distinct?: LinkedStudentProfileScalarFieldEnum | LinkedStudentProfileScalarFieldEnum[]
  }

  /**
   * LinkedStudentProfile findMany
   */
  export type LinkedStudentProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedStudentProfile
     */
    select?: LinkedStudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedStudentProfile
     */
    omit?: LinkedStudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedStudentProfileInclude<ExtArgs> | null
    /**
     * Filter, which LinkedStudentProfiles to fetch.
     */
    where?: LinkedStudentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkedStudentProfiles to fetch.
     */
    orderBy?: LinkedStudentProfileOrderByWithRelationInput | LinkedStudentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LinkedStudentProfiles.
     */
    cursor?: LinkedStudentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkedStudentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkedStudentProfiles.
     */
    skip?: number
    distinct?: LinkedStudentProfileScalarFieldEnum | LinkedStudentProfileScalarFieldEnum[]
  }

  /**
   * LinkedStudentProfile create
   */
  export type LinkedStudentProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedStudentProfile
     */
    select?: LinkedStudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedStudentProfile
     */
    omit?: LinkedStudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedStudentProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a LinkedStudentProfile.
     */
    data: XOR<LinkedStudentProfileCreateInput, LinkedStudentProfileUncheckedCreateInput>
  }

  /**
   * LinkedStudentProfile createMany
   */
  export type LinkedStudentProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LinkedStudentProfiles.
     */
    data: LinkedStudentProfileCreateManyInput | LinkedStudentProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LinkedStudentProfile createManyAndReturn
   */
  export type LinkedStudentProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedStudentProfile
     */
    select?: LinkedStudentProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedStudentProfile
     */
    omit?: LinkedStudentProfileOmit<ExtArgs> | null
    /**
     * The data used to create many LinkedStudentProfiles.
     */
    data: LinkedStudentProfileCreateManyInput | LinkedStudentProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedStudentProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LinkedStudentProfile update
   */
  export type LinkedStudentProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedStudentProfile
     */
    select?: LinkedStudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedStudentProfile
     */
    omit?: LinkedStudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedStudentProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a LinkedStudentProfile.
     */
    data: XOR<LinkedStudentProfileUpdateInput, LinkedStudentProfileUncheckedUpdateInput>
    /**
     * Choose, which LinkedStudentProfile to update.
     */
    where: LinkedStudentProfileWhereUniqueInput
  }

  /**
   * LinkedStudentProfile updateMany
   */
  export type LinkedStudentProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LinkedStudentProfiles.
     */
    data: XOR<LinkedStudentProfileUpdateManyMutationInput, LinkedStudentProfileUncheckedUpdateManyInput>
    /**
     * Filter which LinkedStudentProfiles to update
     */
    where?: LinkedStudentProfileWhereInput
    /**
     * Limit how many LinkedStudentProfiles to update.
     */
    limit?: number
  }

  /**
   * LinkedStudentProfile updateManyAndReturn
   */
  export type LinkedStudentProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedStudentProfile
     */
    select?: LinkedStudentProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedStudentProfile
     */
    omit?: LinkedStudentProfileOmit<ExtArgs> | null
    /**
     * The data used to update LinkedStudentProfiles.
     */
    data: XOR<LinkedStudentProfileUpdateManyMutationInput, LinkedStudentProfileUncheckedUpdateManyInput>
    /**
     * Filter which LinkedStudentProfiles to update
     */
    where?: LinkedStudentProfileWhereInput
    /**
     * Limit how many LinkedStudentProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedStudentProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LinkedStudentProfile upsert
   */
  export type LinkedStudentProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedStudentProfile
     */
    select?: LinkedStudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedStudentProfile
     */
    omit?: LinkedStudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedStudentProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the LinkedStudentProfile to update in case it exists.
     */
    where: LinkedStudentProfileWhereUniqueInput
    /**
     * In case the LinkedStudentProfile found by the `where` argument doesn't exist, create a new LinkedStudentProfile with this data.
     */
    create: XOR<LinkedStudentProfileCreateInput, LinkedStudentProfileUncheckedCreateInput>
    /**
     * In case the LinkedStudentProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LinkedStudentProfileUpdateInput, LinkedStudentProfileUncheckedUpdateInput>
  }

  /**
   * LinkedStudentProfile delete
   */
  export type LinkedStudentProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedStudentProfile
     */
    select?: LinkedStudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedStudentProfile
     */
    omit?: LinkedStudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedStudentProfileInclude<ExtArgs> | null
    /**
     * Filter which LinkedStudentProfile to delete.
     */
    where: LinkedStudentProfileWhereUniqueInput
  }

  /**
   * LinkedStudentProfile deleteMany
   */
  export type LinkedStudentProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LinkedStudentProfiles to delete
     */
    where?: LinkedStudentProfileWhereInput
    /**
     * Limit how many LinkedStudentProfiles to delete.
     */
    limit?: number
  }

  /**
   * LinkedStudentProfile without action
   */
  export type LinkedStudentProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedStudentProfile
     */
    select?: LinkedStudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LinkedStudentProfile
     */
    omit?: LinkedStudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedStudentProfileInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: Decimal | null
    fees: Decimal | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: Decimal | null
    fees: Decimal | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    guardianId: string | null
    invoiceId: string | null
    reference: string | null
    amount: Decimal | null
    fees: Decimal | null
    status: $Enums.TransactionStatus | null
    transactionAt: Date | null
    processedAt: Date | null
    description: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    guardianId: string | null
    invoiceId: string | null
    reference: string | null
    amount: Decimal | null
    fees: Decimal | null
    status: $Enums.TransactionStatus | null
    transactionAt: Date | null
    processedAt: Date | null
    description: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    guardianId: number
    invoiceId: number
    reference: number
    amount: number
    fees: number
    status: number
    transactionAt: number
    processedAt: number
    description: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
    fees?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
    fees?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    guardianId?: true
    invoiceId?: true
    reference?: true
    amount?: true
    fees?: true
    status?: true
    transactionAt?: true
    processedAt?: true
    description?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    guardianId?: true
    invoiceId?: true
    reference?: true
    amount?: true
    fees?: true
    status?: true
    transactionAt?: true
    processedAt?: true
    description?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    guardianId?: true
    invoiceId?: true
    reference?: true
    amount?: true
    fees?: true
    status?: true
    transactionAt?: true
    processedAt?: true
    description?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    guardianId: string
    invoiceId: string
    reference: string
    amount: Decimal
    fees: Decimal
    status: $Enums.TransactionStatus
    transactionAt: Date | null
    processedAt: Date | null
    description: string | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    guardianId?: boolean
    invoiceId?: boolean
    reference?: boolean
    amount?: boolean
    fees?: boolean
    status?: boolean
    transactionAt?: boolean
    processedAt?: boolean
    description?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    guardian?: boolean | GuardianDefaultArgs<ExtArgs>
    transactionFee?: boolean | Transaction$transactionFeeArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    guardianId?: boolean
    invoiceId?: boolean
    reference?: boolean
    amount?: boolean
    fees?: boolean
    status?: boolean
    transactionAt?: boolean
    processedAt?: boolean
    description?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    guardian?: boolean | GuardianDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    guardianId?: boolean
    invoiceId?: boolean
    reference?: boolean
    amount?: boolean
    fees?: boolean
    status?: boolean
    transactionAt?: boolean
    processedAt?: boolean
    description?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    guardian?: boolean | GuardianDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    guardianId?: boolean
    invoiceId?: boolean
    reference?: boolean
    amount?: boolean
    fees?: boolean
    status?: boolean
    transactionAt?: boolean
    processedAt?: boolean
    description?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "guardianId" | "invoiceId" | "reference" | "amount" | "fees" | "status" | "transactionAt" | "processedAt" | "description" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    guardian?: boolean | GuardianDefaultArgs<ExtArgs>
    transactionFee?: boolean | Transaction$transactionFeeArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    guardian?: boolean | GuardianDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    guardian?: boolean | GuardianDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
      guardian: Prisma.$GuardianPayload<ExtArgs>
      transactionFee: Prisma.$TransactionFeePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      guardianId: string
      invoiceId: string
      reference: string
      amount: Prisma.Decimal
      fees: Prisma.Decimal
      status: $Enums.TransactionStatus
      transactionAt: Date | null
      processedAt: Date | null
      description: string | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    guardian<T extends GuardianDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GuardianDefaultArgs<ExtArgs>>): Prisma__GuardianClient<$Result.GetResult<Prisma.$GuardianPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactionFee<T extends Transaction$transactionFeeArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$transactionFeeArgs<ExtArgs>>): Prisma__TransactionFeeClient<$Result.GetResult<Prisma.$TransactionFeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly guardianId: FieldRef<"Transaction", 'String'>
    readonly invoiceId: FieldRef<"Transaction", 'String'>
    readonly reference: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Decimal'>
    readonly fees: FieldRef<"Transaction", 'Decimal'>
    readonly status: FieldRef<"Transaction", 'TransactionStatus'>
    readonly transactionAt: FieldRef<"Transaction", 'DateTime'>
    readonly processedAt: FieldRef<"Transaction", 'DateTime'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly isDeleted: FieldRef<"Transaction", 'Boolean'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.transactionFee
   */
  export type Transaction$transactionFeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFee
     */
    select?: TransactionFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionFee
     */
    omit?: TransactionFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFeeInclude<ExtArgs> | null
    where?: TransactionFeeWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model TransactionFee
   */

  export type AggregateTransactionFee = {
    _count: TransactionFeeCountAggregateOutputType | null
    _avg: TransactionFeeAvgAggregateOutputType | null
    _sum: TransactionFeeSumAggregateOutputType | null
    _min: TransactionFeeMinAggregateOutputType | null
    _max: TransactionFeeMaxAggregateOutputType | null
  }

  export type TransactionFeeAvgAggregateOutputType = {
    platformFee: Decimal | null
    latePaymentFee: Decimal | null
    processingFee: Decimal | null
  }

  export type TransactionFeeSumAggregateOutputType = {
    platformFee: Decimal | null
    latePaymentFee: Decimal | null
    processingFee: Decimal | null
  }

  export type TransactionFeeMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    platformFee: Decimal | null
    latePaymentFee: Decimal | null
    processingFee: Decimal | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionFeeMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    platformFee: Decimal | null
    latePaymentFee: Decimal | null
    processingFee: Decimal | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionFeeCountAggregateOutputType = {
    id: number
    transactionId: number
    platformFee: number
    latePaymentFee: number
    processingFee: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionFeeAvgAggregateInputType = {
    platformFee?: true
    latePaymentFee?: true
    processingFee?: true
  }

  export type TransactionFeeSumAggregateInputType = {
    platformFee?: true
    latePaymentFee?: true
    processingFee?: true
  }

  export type TransactionFeeMinAggregateInputType = {
    id?: true
    transactionId?: true
    platformFee?: true
    latePaymentFee?: true
    processingFee?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionFeeMaxAggregateInputType = {
    id?: true
    transactionId?: true
    platformFee?: true
    latePaymentFee?: true
    processingFee?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionFeeCountAggregateInputType = {
    id?: true
    transactionId?: true
    platformFee?: true
    latePaymentFee?: true
    processingFee?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionFeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionFee to aggregate.
     */
    where?: TransactionFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionFees to fetch.
     */
    orderBy?: TransactionFeeOrderByWithRelationInput | TransactionFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionFees
    **/
    _count?: true | TransactionFeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionFeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionFeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionFeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionFeeMaxAggregateInputType
  }

  export type GetTransactionFeeAggregateType<T extends TransactionFeeAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionFee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionFee[P]>
      : GetScalarType<T[P], AggregateTransactionFee[P]>
  }




  export type TransactionFeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionFeeWhereInput
    orderBy?: TransactionFeeOrderByWithAggregationInput | TransactionFeeOrderByWithAggregationInput[]
    by: TransactionFeeScalarFieldEnum[] | TransactionFeeScalarFieldEnum
    having?: TransactionFeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionFeeCountAggregateInputType | true
    _avg?: TransactionFeeAvgAggregateInputType
    _sum?: TransactionFeeSumAggregateInputType
    _min?: TransactionFeeMinAggregateInputType
    _max?: TransactionFeeMaxAggregateInputType
  }

  export type TransactionFeeGroupByOutputType = {
    id: string
    transactionId: string
    platformFee: Decimal
    latePaymentFee: Decimal
    processingFee: Decimal
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: TransactionFeeCountAggregateOutputType | null
    _avg: TransactionFeeAvgAggregateOutputType | null
    _sum: TransactionFeeSumAggregateOutputType | null
    _min: TransactionFeeMinAggregateOutputType | null
    _max: TransactionFeeMaxAggregateOutputType | null
  }

  type GetTransactionFeeGroupByPayload<T extends TransactionFeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionFeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionFeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionFeeGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionFeeGroupByOutputType[P]>
        }
      >
    >


  export type TransactionFeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    platformFee?: boolean
    latePaymentFee?: boolean
    processingFee?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionFee"]>

  export type TransactionFeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    platformFee?: boolean
    latePaymentFee?: boolean
    processingFee?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionFee"]>

  export type TransactionFeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    platformFee?: boolean
    latePaymentFee?: boolean
    processingFee?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionFee"]>

  export type TransactionFeeSelectScalar = {
    id?: boolean
    transactionId?: boolean
    platformFee?: boolean
    latePaymentFee?: boolean
    processingFee?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionFeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "platformFee" | "latePaymentFee" | "processingFee" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["transactionFee"]>
  export type TransactionFeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type TransactionFeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type TransactionFeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }

  export type $TransactionFeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransactionFee"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      platformFee: Prisma.Decimal
      latePaymentFee: Prisma.Decimal
      processingFee: Prisma.Decimal
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transactionFee"]>
    composites: {}
  }

  type TransactionFeeGetPayload<S extends boolean | null | undefined | TransactionFeeDefaultArgs> = $Result.GetResult<Prisma.$TransactionFeePayload, S>

  type TransactionFeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionFeeCountAggregateInputType | true
    }

  export interface TransactionFeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransactionFee'], meta: { name: 'TransactionFee' } }
    /**
     * Find zero or one TransactionFee that matches the filter.
     * @param {TransactionFeeFindUniqueArgs} args - Arguments to find a TransactionFee
     * @example
     * // Get one TransactionFee
     * const transactionFee = await prisma.transactionFee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFeeFindUniqueArgs>(args: SelectSubset<T, TransactionFeeFindUniqueArgs<ExtArgs>>): Prisma__TransactionFeeClient<$Result.GetResult<Prisma.$TransactionFeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransactionFee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFeeFindUniqueOrThrowArgs} args - Arguments to find a TransactionFee
     * @example
     * // Get one TransactionFee
     * const transactionFee = await prisma.transactionFee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFeeFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionFeeClient<$Result.GetResult<Prisma.$TransactionFeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionFee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFeeFindFirstArgs} args - Arguments to find a TransactionFee
     * @example
     * // Get one TransactionFee
     * const transactionFee = await prisma.transactionFee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFeeFindFirstArgs>(args?: SelectSubset<T, TransactionFeeFindFirstArgs<ExtArgs>>): Prisma__TransactionFeeClient<$Result.GetResult<Prisma.$TransactionFeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionFee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFeeFindFirstOrThrowArgs} args - Arguments to find a TransactionFee
     * @example
     * // Get one TransactionFee
     * const transactionFee = await prisma.transactionFee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFeeFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionFeeClient<$Result.GetResult<Prisma.$TransactionFeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransactionFees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionFees
     * const transactionFees = await prisma.transactionFee.findMany()
     * 
     * // Get first 10 TransactionFees
     * const transactionFees = await prisma.transactionFee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionFeeWithIdOnly = await prisma.transactionFee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFeeFindManyArgs>(args?: SelectSubset<T, TransactionFeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionFeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransactionFee.
     * @param {TransactionFeeCreateArgs} args - Arguments to create a TransactionFee.
     * @example
     * // Create one TransactionFee
     * const TransactionFee = await prisma.transactionFee.create({
     *   data: {
     *     // ... data to create a TransactionFee
     *   }
     * })
     * 
     */
    create<T extends TransactionFeeCreateArgs>(args: SelectSubset<T, TransactionFeeCreateArgs<ExtArgs>>): Prisma__TransactionFeeClient<$Result.GetResult<Prisma.$TransactionFeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransactionFees.
     * @param {TransactionFeeCreateManyArgs} args - Arguments to create many TransactionFees.
     * @example
     * // Create many TransactionFees
     * const transactionFee = await prisma.transactionFee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionFeeCreateManyArgs>(args?: SelectSubset<T, TransactionFeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransactionFees and returns the data saved in the database.
     * @param {TransactionFeeCreateManyAndReturnArgs} args - Arguments to create many TransactionFees.
     * @example
     * // Create many TransactionFees
     * const transactionFee = await prisma.transactionFee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransactionFees and only return the `id`
     * const transactionFeeWithIdOnly = await prisma.transactionFee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionFeeCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionFeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionFeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransactionFee.
     * @param {TransactionFeeDeleteArgs} args - Arguments to delete one TransactionFee.
     * @example
     * // Delete one TransactionFee
     * const TransactionFee = await prisma.transactionFee.delete({
     *   where: {
     *     // ... filter to delete one TransactionFee
     *   }
     * })
     * 
     */
    delete<T extends TransactionFeeDeleteArgs>(args: SelectSubset<T, TransactionFeeDeleteArgs<ExtArgs>>): Prisma__TransactionFeeClient<$Result.GetResult<Prisma.$TransactionFeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransactionFee.
     * @param {TransactionFeeUpdateArgs} args - Arguments to update one TransactionFee.
     * @example
     * // Update one TransactionFee
     * const transactionFee = await prisma.transactionFee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionFeeUpdateArgs>(args: SelectSubset<T, TransactionFeeUpdateArgs<ExtArgs>>): Prisma__TransactionFeeClient<$Result.GetResult<Prisma.$TransactionFeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransactionFees.
     * @param {TransactionFeeDeleteManyArgs} args - Arguments to filter TransactionFees to delete.
     * @example
     * // Delete a few TransactionFees
     * const { count } = await prisma.transactionFee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionFeeDeleteManyArgs>(args?: SelectSubset<T, TransactionFeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionFees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionFees
     * const transactionFee = await prisma.transactionFee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionFeeUpdateManyArgs>(args: SelectSubset<T, TransactionFeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionFees and returns the data updated in the database.
     * @param {TransactionFeeUpdateManyAndReturnArgs} args - Arguments to update many TransactionFees.
     * @example
     * // Update many TransactionFees
     * const transactionFee = await prisma.transactionFee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransactionFees and only return the `id`
     * const transactionFeeWithIdOnly = await prisma.transactionFee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionFeeUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionFeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionFeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransactionFee.
     * @param {TransactionFeeUpsertArgs} args - Arguments to update or create a TransactionFee.
     * @example
     * // Update or create a TransactionFee
     * const transactionFee = await prisma.transactionFee.upsert({
     *   create: {
     *     // ... data to create a TransactionFee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionFee we want to update
     *   }
     * })
     */
    upsert<T extends TransactionFeeUpsertArgs>(args: SelectSubset<T, TransactionFeeUpsertArgs<ExtArgs>>): Prisma__TransactionFeeClient<$Result.GetResult<Prisma.$TransactionFeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransactionFees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFeeCountArgs} args - Arguments to filter TransactionFees to count.
     * @example
     * // Count the number of TransactionFees
     * const count = await prisma.transactionFee.count({
     *   where: {
     *     // ... the filter for the TransactionFees we want to count
     *   }
     * })
    **/
    count<T extends TransactionFeeCountArgs>(
      args?: Subset<T, TransactionFeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionFeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionFee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionFeeAggregateArgs>(args: Subset<T, TransactionFeeAggregateArgs>): Prisma.PrismaPromise<GetTransactionFeeAggregateType<T>>

    /**
     * Group by TransactionFee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionFeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionFeeGroupByArgs['orderBy'] }
        : { orderBy?: TransactionFeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionFeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionFeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransactionFee model
   */
  readonly fields: TransactionFeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionFee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionFeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransactionFee model
   */
  interface TransactionFeeFieldRefs {
    readonly id: FieldRef<"TransactionFee", 'String'>
    readonly transactionId: FieldRef<"TransactionFee", 'String'>
    readonly platformFee: FieldRef<"TransactionFee", 'Decimal'>
    readonly latePaymentFee: FieldRef<"TransactionFee", 'Decimal'>
    readonly processingFee: FieldRef<"TransactionFee", 'Decimal'>
    readonly isDeleted: FieldRef<"TransactionFee", 'Boolean'>
    readonly createdAt: FieldRef<"TransactionFee", 'DateTime'>
    readonly updatedAt: FieldRef<"TransactionFee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransactionFee findUnique
   */
  export type TransactionFeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFee
     */
    select?: TransactionFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionFee
     */
    omit?: TransactionFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFeeInclude<ExtArgs> | null
    /**
     * Filter, which TransactionFee to fetch.
     */
    where: TransactionFeeWhereUniqueInput
  }

  /**
   * TransactionFee findUniqueOrThrow
   */
  export type TransactionFeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFee
     */
    select?: TransactionFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionFee
     */
    omit?: TransactionFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFeeInclude<ExtArgs> | null
    /**
     * Filter, which TransactionFee to fetch.
     */
    where: TransactionFeeWhereUniqueInput
  }

  /**
   * TransactionFee findFirst
   */
  export type TransactionFeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFee
     */
    select?: TransactionFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionFee
     */
    omit?: TransactionFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFeeInclude<ExtArgs> | null
    /**
     * Filter, which TransactionFee to fetch.
     */
    where?: TransactionFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionFees to fetch.
     */
    orderBy?: TransactionFeeOrderByWithRelationInput | TransactionFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionFees.
     */
    cursor?: TransactionFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionFees.
     */
    distinct?: TransactionFeeScalarFieldEnum | TransactionFeeScalarFieldEnum[]
  }

  /**
   * TransactionFee findFirstOrThrow
   */
  export type TransactionFeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFee
     */
    select?: TransactionFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionFee
     */
    omit?: TransactionFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFeeInclude<ExtArgs> | null
    /**
     * Filter, which TransactionFee to fetch.
     */
    where?: TransactionFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionFees to fetch.
     */
    orderBy?: TransactionFeeOrderByWithRelationInput | TransactionFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionFees.
     */
    cursor?: TransactionFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionFees.
     */
    distinct?: TransactionFeeScalarFieldEnum | TransactionFeeScalarFieldEnum[]
  }

  /**
   * TransactionFee findMany
   */
  export type TransactionFeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFee
     */
    select?: TransactionFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionFee
     */
    omit?: TransactionFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFeeInclude<ExtArgs> | null
    /**
     * Filter, which TransactionFees to fetch.
     */
    where?: TransactionFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionFees to fetch.
     */
    orderBy?: TransactionFeeOrderByWithRelationInput | TransactionFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionFees.
     */
    cursor?: TransactionFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionFees.
     */
    skip?: number
    distinct?: TransactionFeeScalarFieldEnum | TransactionFeeScalarFieldEnum[]
  }

  /**
   * TransactionFee create
   */
  export type TransactionFeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFee
     */
    select?: TransactionFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionFee
     */
    omit?: TransactionFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFeeInclude<ExtArgs> | null
    /**
     * The data needed to create a TransactionFee.
     */
    data: XOR<TransactionFeeCreateInput, TransactionFeeUncheckedCreateInput>
  }

  /**
   * TransactionFee createMany
   */
  export type TransactionFeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransactionFees.
     */
    data: TransactionFeeCreateManyInput | TransactionFeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransactionFee createManyAndReturn
   */
  export type TransactionFeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFee
     */
    select?: TransactionFeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionFee
     */
    omit?: TransactionFeeOmit<ExtArgs> | null
    /**
     * The data used to create many TransactionFees.
     */
    data: TransactionFeeCreateManyInput | TransactionFeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionFee update
   */
  export type TransactionFeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFee
     */
    select?: TransactionFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionFee
     */
    omit?: TransactionFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFeeInclude<ExtArgs> | null
    /**
     * The data needed to update a TransactionFee.
     */
    data: XOR<TransactionFeeUpdateInput, TransactionFeeUncheckedUpdateInput>
    /**
     * Choose, which TransactionFee to update.
     */
    where: TransactionFeeWhereUniqueInput
  }

  /**
   * TransactionFee updateMany
   */
  export type TransactionFeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransactionFees.
     */
    data: XOR<TransactionFeeUpdateManyMutationInput, TransactionFeeUncheckedUpdateManyInput>
    /**
     * Filter which TransactionFees to update
     */
    where?: TransactionFeeWhereInput
    /**
     * Limit how many TransactionFees to update.
     */
    limit?: number
  }

  /**
   * TransactionFee updateManyAndReturn
   */
  export type TransactionFeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFee
     */
    select?: TransactionFeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionFee
     */
    omit?: TransactionFeeOmit<ExtArgs> | null
    /**
     * The data used to update TransactionFees.
     */
    data: XOR<TransactionFeeUpdateManyMutationInput, TransactionFeeUncheckedUpdateManyInput>
    /**
     * Filter which TransactionFees to update
     */
    where?: TransactionFeeWhereInput
    /**
     * Limit how many TransactionFees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionFee upsert
   */
  export type TransactionFeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFee
     */
    select?: TransactionFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionFee
     */
    omit?: TransactionFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFeeInclude<ExtArgs> | null
    /**
     * The filter to search for the TransactionFee to update in case it exists.
     */
    where: TransactionFeeWhereUniqueInput
    /**
     * In case the TransactionFee found by the `where` argument doesn't exist, create a new TransactionFee with this data.
     */
    create: XOR<TransactionFeeCreateInput, TransactionFeeUncheckedCreateInput>
    /**
     * In case the TransactionFee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionFeeUpdateInput, TransactionFeeUncheckedUpdateInput>
  }

  /**
   * TransactionFee delete
   */
  export type TransactionFeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFee
     */
    select?: TransactionFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionFee
     */
    omit?: TransactionFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFeeInclude<ExtArgs> | null
    /**
     * Filter which TransactionFee to delete.
     */
    where: TransactionFeeWhereUniqueInput
  }

  /**
   * TransactionFee deleteMany
   */
  export type TransactionFeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionFees to delete
     */
    where?: TransactionFeeWhereInput
    /**
     * Limit how many TransactionFees to delete.
     */
    limit?: number
  }

  /**
   * TransactionFee without action
   */
  export type TransactionFeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFee
     */
    select?: TransactionFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionFee
     */
    omit?: TransactionFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFeeInclude<ExtArgs> | null
  }


  /**
   * Model Payout
   */

  export type AggregatePayout = {
    _count: PayoutCountAggregateOutputType | null
    _avg: PayoutAvgAggregateOutputType | null
    _sum: PayoutSumAggregateOutputType | null
    _min: PayoutMinAggregateOutputType | null
    _max: PayoutMaxAggregateOutputType | null
  }

  export type PayoutAvgAggregateOutputType = {
    amount: Decimal | null
    processingFee: Decimal | null
  }

  export type PayoutSumAggregateOutputType = {
    amount: Decimal | null
    processingFee: Decimal | null
  }

  export type PayoutMinAggregateOutputType = {
    id: string | null
    schoolId: string | null
    amount: Decimal | null
    processingFee: Decimal | null
    status: $Enums.PayoutStatus | null
    initiatedAt: Date | null
    completedAt: Date | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayoutMaxAggregateOutputType = {
    id: string | null
    schoolId: string | null
    amount: Decimal | null
    processingFee: Decimal | null
    status: $Enums.PayoutStatus | null
    initiatedAt: Date | null
    completedAt: Date | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayoutCountAggregateOutputType = {
    id: number
    schoolId: number
    amount: number
    processingFee: number
    status: number
    initiatedAt: number
    completedAt: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PayoutAvgAggregateInputType = {
    amount?: true
    processingFee?: true
  }

  export type PayoutSumAggregateInputType = {
    amount?: true
    processingFee?: true
  }

  export type PayoutMinAggregateInputType = {
    id?: true
    schoolId?: true
    amount?: true
    processingFee?: true
    status?: true
    initiatedAt?: true
    completedAt?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayoutMaxAggregateInputType = {
    id?: true
    schoolId?: true
    amount?: true
    processingFee?: true
    status?: true
    initiatedAt?: true
    completedAt?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayoutCountAggregateInputType = {
    id?: true
    schoolId?: true
    amount?: true
    processingFee?: true
    status?: true
    initiatedAt?: true
    completedAt?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PayoutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payout to aggregate.
     */
    where?: PayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payouts to fetch.
     */
    orderBy?: PayoutOrderByWithRelationInput | PayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payouts
    **/
    _count?: true | PayoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayoutAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayoutSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayoutMaxAggregateInputType
  }

  export type GetPayoutAggregateType<T extends PayoutAggregateArgs> = {
        [P in keyof T & keyof AggregatePayout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayout[P]>
      : GetScalarType<T[P], AggregatePayout[P]>
  }




  export type PayoutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayoutWhereInput
    orderBy?: PayoutOrderByWithAggregationInput | PayoutOrderByWithAggregationInput[]
    by: PayoutScalarFieldEnum[] | PayoutScalarFieldEnum
    having?: PayoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayoutCountAggregateInputType | true
    _avg?: PayoutAvgAggregateInputType
    _sum?: PayoutSumAggregateInputType
    _min?: PayoutMinAggregateInputType
    _max?: PayoutMaxAggregateInputType
  }

  export type PayoutGroupByOutputType = {
    id: string
    schoolId: string
    amount: Decimal
    processingFee: Decimal
    status: $Enums.PayoutStatus
    initiatedAt: Date
    completedAt: Date | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: PayoutCountAggregateOutputType | null
    _avg: PayoutAvgAggregateOutputType | null
    _sum: PayoutSumAggregateOutputType | null
    _min: PayoutMinAggregateOutputType | null
    _max: PayoutMaxAggregateOutputType | null
  }

  type GetPayoutGroupByPayload<T extends PayoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayoutGroupByOutputType[P]>
            : GetScalarType<T[P], PayoutGroupByOutputType[P]>
        }
      >
    >


  export type PayoutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    amount?: boolean
    processingFee?: boolean
    status?: boolean
    initiatedAt?: boolean
    completedAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payout"]>

  export type PayoutSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    amount?: boolean
    processingFee?: boolean
    status?: boolean
    initiatedAt?: boolean
    completedAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payout"]>

  export type PayoutSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    amount?: boolean
    processingFee?: boolean
    status?: boolean
    initiatedAt?: boolean
    completedAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payout"]>

  export type PayoutSelectScalar = {
    id?: boolean
    schoolId?: boolean
    amount?: boolean
    processingFee?: boolean
    status?: boolean
    initiatedAt?: boolean
    completedAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PayoutOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "schoolId" | "amount" | "processingFee" | "status" | "initiatedAt" | "completedAt" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["payout"]>
  export type PayoutInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type PayoutIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }
  export type PayoutIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolDefaultArgs<ExtArgs>
  }

  export type $PayoutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payout"
    objects: {
      school: Prisma.$SchoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schoolId: string
      amount: Prisma.Decimal
      processingFee: Prisma.Decimal
      status: $Enums.PayoutStatus
      initiatedAt: Date
      completedAt: Date | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payout"]>
    composites: {}
  }

  type PayoutGetPayload<S extends boolean | null | undefined | PayoutDefaultArgs> = $Result.GetResult<Prisma.$PayoutPayload, S>

  type PayoutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PayoutFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayoutCountAggregateInputType | true
    }

  export interface PayoutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payout'], meta: { name: 'Payout' } }
    /**
     * Find zero or one Payout that matches the filter.
     * @param {PayoutFindUniqueArgs} args - Arguments to find a Payout
     * @example
     * // Get one Payout
     * const payout = await prisma.payout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayoutFindUniqueArgs>(args: SelectSubset<T, PayoutFindUniqueArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payout that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PayoutFindUniqueOrThrowArgs} args - Arguments to find a Payout
     * @example
     * // Get one Payout
     * const payout = await prisma.payout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayoutFindUniqueOrThrowArgs>(args: SelectSubset<T, PayoutFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutFindFirstArgs} args - Arguments to find a Payout
     * @example
     * // Get one Payout
     * const payout = await prisma.payout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayoutFindFirstArgs>(args?: SelectSubset<T, PayoutFindFirstArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payout that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutFindFirstOrThrowArgs} args - Arguments to find a Payout
     * @example
     * // Get one Payout
     * const payout = await prisma.payout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayoutFindFirstOrThrowArgs>(args?: SelectSubset<T, PayoutFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payouts
     * const payouts = await prisma.payout.findMany()
     * 
     * // Get first 10 Payouts
     * const payouts = await prisma.payout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payoutWithIdOnly = await prisma.payout.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayoutFindManyArgs>(args?: SelectSubset<T, PayoutFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payout.
     * @param {PayoutCreateArgs} args - Arguments to create a Payout.
     * @example
     * // Create one Payout
     * const Payout = await prisma.payout.create({
     *   data: {
     *     // ... data to create a Payout
     *   }
     * })
     * 
     */
    create<T extends PayoutCreateArgs>(args: SelectSubset<T, PayoutCreateArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payouts.
     * @param {PayoutCreateManyArgs} args - Arguments to create many Payouts.
     * @example
     * // Create many Payouts
     * const payout = await prisma.payout.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayoutCreateManyArgs>(args?: SelectSubset<T, PayoutCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payouts and returns the data saved in the database.
     * @param {PayoutCreateManyAndReturnArgs} args - Arguments to create many Payouts.
     * @example
     * // Create many Payouts
     * const payout = await prisma.payout.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payouts and only return the `id`
     * const payoutWithIdOnly = await prisma.payout.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayoutCreateManyAndReturnArgs>(args?: SelectSubset<T, PayoutCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payout.
     * @param {PayoutDeleteArgs} args - Arguments to delete one Payout.
     * @example
     * // Delete one Payout
     * const Payout = await prisma.payout.delete({
     *   where: {
     *     // ... filter to delete one Payout
     *   }
     * })
     * 
     */
    delete<T extends PayoutDeleteArgs>(args: SelectSubset<T, PayoutDeleteArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payout.
     * @param {PayoutUpdateArgs} args - Arguments to update one Payout.
     * @example
     * // Update one Payout
     * const payout = await prisma.payout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayoutUpdateArgs>(args: SelectSubset<T, PayoutUpdateArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payouts.
     * @param {PayoutDeleteManyArgs} args - Arguments to filter Payouts to delete.
     * @example
     * // Delete a few Payouts
     * const { count } = await prisma.payout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayoutDeleteManyArgs>(args?: SelectSubset<T, PayoutDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payouts
     * const payout = await prisma.payout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayoutUpdateManyArgs>(args: SelectSubset<T, PayoutUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payouts and returns the data updated in the database.
     * @param {PayoutUpdateManyAndReturnArgs} args - Arguments to update many Payouts.
     * @example
     * // Update many Payouts
     * const payout = await prisma.payout.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payouts and only return the `id`
     * const payoutWithIdOnly = await prisma.payout.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PayoutUpdateManyAndReturnArgs>(args: SelectSubset<T, PayoutUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payout.
     * @param {PayoutUpsertArgs} args - Arguments to update or create a Payout.
     * @example
     * // Update or create a Payout
     * const payout = await prisma.payout.upsert({
     *   create: {
     *     // ... data to create a Payout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payout we want to update
     *   }
     * })
     */
    upsert<T extends PayoutUpsertArgs>(args: SelectSubset<T, PayoutUpsertArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutCountArgs} args - Arguments to filter Payouts to count.
     * @example
     * // Count the number of Payouts
     * const count = await prisma.payout.count({
     *   where: {
     *     // ... the filter for the Payouts we want to count
     *   }
     * })
    **/
    count<T extends PayoutCountArgs>(
      args?: Subset<T, PayoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayoutAggregateArgs>(args: Subset<T, PayoutAggregateArgs>): Prisma.PrismaPromise<GetPayoutAggregateType<T>>

    /**
     * Group by Payout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayoutGroupByArgs['orderBy'] }
        : { orderBy?: PayoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payout model
   */
  readonly fields: PayoutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayoutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    school<T extends SchoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SchoolDefaultArgs<ExtArgs>>): Prisma__SchoolClient<$Result.GetResult<Prisma.$SchoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payout model
   */
  interface PayoutFieldRefs {
    readonly id: FieldRef<"Payout", 'String'>
    readonly schoolId: FieldRef<"Payout", 'String'>
    readonly amount: FieldRef<"Payout", 'Decimal'>
    readonly processingFee: FieldRef<"Payout", 'Decimal'>
    readonly status: FieldRef<"Payout", 'PayoutStatus'>
    readonly initiatedAt: FieldRef<"Payout", 'DateTime'>
    readonly completedAt: FieldRef<"Payout", 'DateTime'>
    readonly isDeleted: FieldRef<"Payout", 'Boolean'>
    readonly createdAt: FieldRef<"Payout", 'DateTime'>
    readonly updatedAt: FieldRef<"Payout", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payout findUnique
   */
  export type PayoutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payout
     */
    omit?: PayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * Filter, which Payout to fetch.
     */
    where: PayoutWhereUniqueInput
  }

  /**
   * Payout findUniqueOrThrow
   */
  export type PayoutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payout
     */
    omit?: PayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * Filter, which Payout to fetch.
     */
    where: PayoutWhereUniqueInput
  }

  /**
   * Payout findFirst
   */
  export type PayoutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payout
     */
    omit?: PayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * Filter, which Payout to fetch.
     */
    where?: PayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payouts to fetch.
     */
    orderBy?: PayoutOrderByWithRelationInput | PayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payouts.
     */
    cursor?: PayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payouts.
     */
    distinct?: PayoutScalarFieldEnum | PayoutScalarFieldEnum[]
  }

  /**
   * Payout findFirstOrThrow
   */
  export type PayoutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payout
     */
    omit?: PayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * Filter, which Payout to fetch.
     */
    where?: PayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payouts to fetch.
     */
    orderBy?: PayoutOrderByWithRelationInput | PayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payouts.
     */
    cursor?: PayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payouts.
     */
    distinct?: PayoutScalarFieldEnum | PayoutScalarFieldEnum[]
  }

  /**
   * Payout findMany
   */
  export type PayoutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payout
     */
    omit?: PayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * Filter, which Payouts to fetch.
     */
    where?: PayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payouts to fetch.
     */
    orderBy?: PayoutOrderByWithRelationInput | PayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payouts.
     */
    cursor?: PayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payouts.
     */
    skip?: number
    distinct?: PayoutScalarFieldEnum | PayoutScalarFieldEnum[]
  }

  /**
   * Payout create
   */
  export type PayoutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payout
     */
    omit?: PayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * The data needed to create a Payout.
     */
    data: XOR<PayoutCreateInput, PayoutUncheckedCreateInput>
  }

  /**
   * Payout createMany
   */
  export type PayoutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payouts.
     */
    data: PayoutCreateManyInput | PayoutCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payout createManyAndReturn
   */
  export type PayoutCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payout
     */
    omit?: PayoutOmit<ExtArgs> | null
    /**
     * The data used to create many Payouts.
     */
    data: PayoutCreateManyInput | PayoutCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payout update
   */
  export type PayoutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payout
     */
    omit?: PayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * The data needed to update a Payout.
     */
    data: XOR<PayoutUpdateInput, PayoutUncheckedUpdateInput>
    /**
     * Choose, which Payout to update.
     */
    where: PayoutWhereUniqueInput
  }

  /**
   * Payout updateMany
   */
  export type PayoutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payouts.
     */
    data: XOR<PayoutUpdateManyMutationInput, PayoutUncheckedUpdateManyInput>
    /**
     * Filter which Payouts to update
     */
    where?: PayoutWhereInput
    /**
     * Limit how many Payouts to update.
     */
    limit?: number
  }

  /**
   * Payout updateManyAndReturn
   */
  export type PayoutUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payout
     */
    omit?: PayoutOmit<ExtArgs> | null
    /**
     * The data used to update Payouts.
     */
    data: XOR<PayoutUpdateManyMutationInput, PayoutUncheckedUpdateManyInput>
    /**
     * Filter which Payouts to update
     */
    where?: PayoutWhereInput
    /**
     * Limit how many Payouts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payout upsert
   */
  export type PayoutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payout
     */
    omit?: PayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * The filter to search for the Payout to update in case it exists.
     */
    where: PayoutWhereUniqueInput
    /**
     * In case the Payout found by the `where` argument doesn't exist, create a new Payout with this data.
     */
    create: XOR<PayoutCreateInput, PayoutUncheckedCreateInput>
    /**
     * In case the Payout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayoutUpdateInput, PayoutUncheckedUpdateInput>
  }

  /**
   * Payout delete
   */
  export type PayoutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payout
     */
    omit?: PayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * Filter which Payout to delete.
     */
    where: PayoutWhereUniqueInput
  }

  /**
   * Payout deleteMany
   */
  export type PayoutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payouts to delete
     */
    where?: PayoutWhereInput
    /**
     * Limit how many Payouts to delete.
     */
    limit?: number
  }

  /**
   * Payout without action
   */
  export type PayoutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payout
     */
    omit?: PayoutOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    status: $Enums.NotificationStatus | null
    sentAt: Date | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    status: $Enums.NotificationStatus | null
    sentAt: Date | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    status: number
    sentAt: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    status?: true
    sentAt?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    status?: true
    sentAt?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    status?: true
    sentAt?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    title: string
    message: string
    status: $Enums.NotificationStatus
    sentAt: Date
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    status?: boolean
    sentAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    status?: boolean
    sentAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    status?: boolean
    sentAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    status?: boolean
    sentAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "message" | "status" | "sentAt" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      message: string
      status: $Enums.NotificationStatus
      sentAt: Date
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly status: FieldRef<"Notification", 'NotificationStatus'>
    readonly sentAt: FieldRef<"Notification", 'DateTime'>
    readonly isDeleted: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Wallet
   */

  export type AggregateWallet = {
    _count: WalletCountAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  export type WalletMinAggregateOutputType = {
    id: string | null
    userId: string | null
    address: string | null
    name: string | null
    tag: string | null
    routingNumber: string | null
    balance: string | null
    status: $Enums.WalletStatus | null
    isDeleted: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type WalletMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    address: string | null
    name: string | null
    tag: string | null
    routingNumber: string | null
    balance: string | null
    status: $Enums.WalletStatus | null
    isDeleted: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type WalletCountAggregateOutputType = {
    id: number
    userId: number
    address: number
    name: number
    tag: number
    routingNumber: number
    balance: number
    status: number
    isDeleted: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type WalletMinAggregateInputType = {
    id?: true
    userId?: true
    address?: true
    name?: true
    tag?: true
    routingNumber?: true
    balance?: true
    status?: true
    isDeleted?: true
    updatedAt?: true
    createdAt?: true
  }

  export type WalletMaxAggregateInputType = {
    id?: true
    userId?: true
    address?: true
    name?: true
    tag?: true
    routingNumber?: true
    balance?: true
    status?: true
    isDeleted?: true
    updatedAt?: true
    createdAt?: true
  }

  export type WalletCountAggregateInputType = {
    id?: true
    userId?: true
    address?: true
    name?: true
    tag?: true
    routingNumber?: true
    balance?: true
    status?: true
    isDeleted?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type WalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallet to aggregate.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wallets
    **/
    _count?: true | WalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletMaxAggregateInputType
  }

  export type GetWalletAggregateType<T extends WalletAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet[P]>
      : GetScalarType<T[P], AggregateWallet[P]>
  }




  export type WalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletWhereInput
    orderBy?: WalletOrderByWithAggregationInput | WalletOrderByWithAggregationInput[]
    by: WalletScalarFieldEnum[] | WalletScalarFieldEnum
    having?: WalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletCountAggregateInputType | true
    _min?: WalletMinAggregateInputType
    _max?: WalletMaxAggregateInputType
  }

  export type WalletGroupByOutputType = {
    id: string
    userId: string
    address: string
    name: string
    tag: string
    routingNumber: string
    balance: string
    status: $Enums.WalletStatus
    isDeleted: boolean
    updatedAt: Date
    createdAt: Date
    _count: WalletCountAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  type GetWalletGroupByPayload<T extends WalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletGroupByOutputType[P]>
            : GetScalarType<T[P], WalletGroupByOutputType[P]>
        }
      >
    >


  export type WalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    address?: boolean
    name?: boolean
    tag?: boolean
    routingNumber?: boolean
    balance?: boolean
    status?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    Ledger?: boolean | Wallet$LedgerArgs<ExtArgs>
    Transaction?: boolean | Wallet$TransactionArgs<ExtArgs>
    _count?: boolean | WalletCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    address?: boolean
    name?: boolean
    tag?: boolean
    routingNumber?: boolean
    balance?: boolean
    status?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    address?: boolean
    name?: boolean
    tag?: boolean
    routingNumber?: boolean
    balance?: boolean
    status?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectScalar = {
    id?: boolean
    userId?: boolean
    address?: boolean
    name?: boolean
    tag?: boolean
    routingNumber?: boolean
    balance?: boolean
    status?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type WalletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "address" | "name" | "tag" | "routingNumber" | "balance" | "status" | "isDeleted" | "updatedAt" | "createdAt", ExtArgs["result"]["wallet"]>
  export type WalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    Ledger?: boolean | Wallet$LedgerArgs<ExtArgs>
    Transaction?: boolean | Wallet$TransactionArgs<ExtArgs>
    _count?: boolean | WalletCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WalletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WalletIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wallet"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      Ledger: Prisma.$LedgerPayload<ExtArgs>[]
      Transaction: Prisma.$WalletTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      address: string
      name: string
      tag: string
      routingNumber: string
      balance: string
      status: $Enums.WalletStatus
      isDeleted: boolean
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["wallet"]>
    composites: {}
  }

  type WalletGetPayload<S extends boolean | null | undefined | WalletDefaultArgs> = $Result.GetResult<Prisma.$WalletPayload, S>

  type WalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WalletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletCountAggregateInputType | true
    }

  export interface WalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wallet'], meta: { name: 'Wallet' } }
    /**
     * Find zero or one Wallet that matches the filter.
     * @param {WalletFindUniqueArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletFindUniqueArgs>(args: SelectSubset<T, WalletFindUniqueArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Wallet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WalletFindUniqueOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletFindFirstArgs>(args?: SelectSubset<T, WalletFindFirstArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallet.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletWithIdOnly = await prisma.wallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletFindManyArgs>(args?: SelectSubset<T, WalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Wallet.
     * @param {WalletCreateArgs} args - Arguments to create a Wallet.
     * @example
     * // Create one Wallet
     * const Wallet = await prisma.wallet.create({
     *   data: {
     *     // ... data to create a Wallet
     *   }
     * })
     * 
     */
    create<T extends WalletCreateArgs>(args: SelectSubset<T, WalletCreateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wallets.
     * @param {WalletCreateManyArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletCreateManyArgs>(args?: SelectSubset<T, WalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wallets and returns the data saved in the database.
     * @param {WalletCreateManyAndReturnArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wallets and only return the `id`
     * const walletWithIdOnly = await prisma.wallet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WalletCreateManyAndReturnArgs>(args?: SelectSubset<T, WalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Wallet.
     * @param {WalletDeleteArgs} args - Arguments to delete one Wallet.
     * @example
     * // Delete one Wallet
     * const Wallet = await prisma.wallet.delete({
     *   where: {
     *     // ... filter to delete one Wallet
     *   }
     * })
     * 
     */
    delete<T extends WalletDeleteArgs>(args: SelectSubset<T, WalletDeleteArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Wallet.
     * @param {WalletUpdateArgs} args - Arguments to update one Wallet.
     * @example
     * // Update one Wallet
     * const wallet = await prisma.wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletUpdateArgs>(args: SelectSubset<T, WalletUpdateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wallets.
     * @param {WalletDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletDeleteManyArgs>(args?: SelectSubset<T, WalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletUpdateManyArgs>(args: SelectSubset<T, WalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets and returns the data updated in the database.
     * @param {WalletUpdateManyAndReturnArgs} args - Arguments to update many Wallets.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Wallets and only return the `id`
     * const walletWithIdOnly = await prisma.wallet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WalletUpdateManyAndReturnArgs>(args: SelectSubset<T, WalletUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Wallet.
     * @param {WalletUpsertArgs} args - Arguments to update or create a Wallet.
     * @example
     * // Update or create a Wallet
     * const wallet = await prisma.wallet.upsert({
     *   create: {
     *     // ... data to create a Wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet we want to update
     *   }
     * })
     */
    upsert<T extends WalletUpsertArgs>(args: SelectSubset<T, WalletUpsertArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallet.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends WalletCountArgs>(
      args?: Subset<T, WalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAggregateArgs>(args: Subset<T, WalletAggregateArgs>): Prisma.PrismaPromise<GetWalletAggregateType<T>>

    /**
     * Group by Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletGroupByArgs['orderBy'] }
        : { orderBy?: WalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Wallet model
   */
  readonly fields: WalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Ledger<T extends Wallet$LedgerArgs<ExtArgs> = {}>(args?: Subset<T, Wallet$LedgerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Transaction<T extends Wallet$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, Wallet$TransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Wallet model
   */
  interface WalletFieldRefs {
    readonly id: FieldRef<"Wallet", 'String'>
    readonly userId: FieldRef<"Wallet", 'String'>
    readonly address: FieldRef<"Wallet", 'String'>
    readonly name: FieldRef<"Wallet", 'String'>
    readonly tag: FieldRef<"Wallet", 'String'>
    readonly routingNumber: FieldRef<"Wallet", 'String'>
    readonly balance: FieldRef<"Wallet", 'String'>
    readonly status: FieldRef<"Wallet", 'WalletStatus'>
    readonly isDeleted: FieldRef<"Wallet", 'Boolean'>
    readonly updatedAt: FieldRef<"Wallet", 'DateTime'>
    readonly createdAt: FieldRef<"Wallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Wallet findUnique
   */
  export type WalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findUniqueOrThrow
   */
  export type WalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findFirst
   */
  export type WalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findFirstOrThrow
   */
  export type WalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findMany
   */
  export type WalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallets to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet create
   */
  export type WalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to create a Wallet.
     */
    data: XOR<WalletCreateInput, WalletUncheckedCreateInput>
  }

  /**
   * Wallet createMany
   */
  export type WalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Wallet createManyAndReturn
   */
  export type WalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wallet update
   */
  export type WalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to update a Wallet.
     */
    data: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
    /**
     * Choose, which Wallet to update.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet updateMany
   */
  export type WalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to update.
     */
    limit?: number
  }

  /**
   * Wallet updateManyAndReturn
   */
  export type WalletUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wallet upsert
   */
  export type WalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The filter to search for the Wallet to update in case it exists.
     */
    where: WalletWhereUniqueInput
    /**
     * In case the Wallet found by the `where` argument doesn't exist, create a new Wallet with this data.
     */
    create: XOR<WalletCreateInput, WalletUncheckedCreateInput>
    /**
     * In case the Wallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
  }

  /**
   * Wallet delete
   */
  export type WalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter which Wallet to delete.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet deleteMany
   */
  export type WalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallets to delete
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to delete.
     */
    limit?: number
  }

  /**
   * Wallet.Ledger
   */
  export type Wallet$LedgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ledger
     */
    omit?: LedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerInclude<ExtArgs> | null
    where?: LedgerWhereInput
    orderBy?: LedgerOrderByWithRelationInput | LedgerOrderByWithRelationInput[]
    cursor?: LedgerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerScalarFieldEnum | LedgerScalarFieldEnum[]
  }

  /**
   * Wallet.Transaction
   */
  export type Wallet$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    where?: WalletTransactionWhereInput
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    cursor?: WalletTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * Wallet without action
   */
  export type WalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
  }


  /**
   * Model WalletTransaction
   */

  export type AggregateWalletTransaction = {
    _count: WalletTransactionCountAggregateOutputType | null
    _avg: WalletTransactionAvgAggregateOutputType | null
    _sum: WalletTransactionSumAggregateOutputType | null
    _min: WalletTransactionMinAggregateOutputType | null
    _max: WalletTransactionMaxAggregateOutputType | null
  }

  export type WalletTransactionAvgAggregateOutputType = {
    amount: Decimal | null
    fees: Decimal | null
    netAmount: Decimal | null
  }

  export type WalletTransactionSumAggregateOutputType = {
    amount: Decimal | null
    fees: Decimal | null
    netAmount: Decimal | null
  }

  export type WalletTransactionMinAggregateOutputType = {
    id: string | null
    walletId: string | null
    amount: Decimal | null
    fees: Decimal | null
    netAmount: Decimal | null
    reference: string | null
    type: $Enums.TransactionType | null
    flow: $Enums.TransactionFlow | null
    transactionAt: Date | null
    processedAt: Date | null
    desc: string | null
    status: $Enums.TransactionStatus | null
    isDeleted: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type WalletTransactionMaxAggregateOutputType = {
    id: string | null
    walletId: string | null
    amount: Decimal | null
    fees: Decimal | null
    netAmount: Decimal | null
    reference: string | null
    type: $Enums.TransactionType | null
    flow: $Enums.TransactionFlow | null
    transactionAt: Date | null
    processedAt: Date | null
    desc: string | null
    status: $Enums.TransactionStatus | null
    isDeleted: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type WalletTransactionCountAggregateOutputType = {
    id: number
    walletId: number
    amount: number
    fees: number
    netAmount: number
    reference: number
    type: number
    flow: number
    transactionAt: number
    processedAt: number
    desc: number
    status: number
    isDeleted: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type WalletTransactionAvgAggregateInputType = {
    amount?: true
    fees?: true
    netAmount?: true
  }

  export type WalletTransactionSumAggregateInputType = {
    amount?: true
    fees?: true
    netAmount?: true
  }

  export type WalletTransactionMinAggregateInputType = {
    id?: true
    walletId?: true
    amount?: true
    fees?: true
    netAmount?: true
    reference?: true
    type?: true
    flow?: true
    transactionAt?: true
    processedAt?: true
    desc?: true
    status?: true
    isDeleted?: true
    updatedAt?: true
    createdAt?: true
  }

  export type WalletTransactionMaxAggregateInputType = {
    id?: true
    walletId?: true
    amount?: true
    fees?: true
    netAmount?: true
    reference?: true
    type?: true
    flow?: true
    transactionAt?: true
    processedAt?: true
    desc?: true
    status?: true
    isDeleted?: true
    updatedAt?: true
    createdAt?: true
  }

  export type WalletTransactionCountAggregateInputType = {
    id?: true
    walletId?: true
    amount?: true
    fees?: true
    netAmount?: true
    reference?: true
    type?: true
    flow?: true
    transactionAt?: true
    processedAt?: true
    desc?: true
    status?: true
    isDeleted?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type WalletTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletTransaction to aggregate.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WalletTransactions
    **/
    _count?: true | WalletTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletTransactionMaxAggregateInputType
  }

  export type GetWalletTransactionAggregateType<T extends WalletTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateWalletTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWalletTransaction[P]>
      : GetScalarType<T[P], AggregateWalletTransaction[P]>
  }




  export type WalletTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletTransactionWhereInput
    orderBy?: WalletTransactionOrderByWithAggregationInput | WalletTransactionOrderByWithAggregationInput[]
    by: WalletTransactionScalarFieldEnum[] | WalletTransactionScalarFieldEnum
    having?: WalletTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletTransactionCountAggregateInputType | true
    _avg?: WalletTransactionAvgAggregateInputType
    _sum?: WalletTransactionSumAggregateInputType
    _min?: WalletTransactionMinAggregateInputType
    _max?: WalletTransactionMaxAggregateInputType
  }

  export type WalletTransactionGroupByOutputType = {
    id: string
    walletId: string
    amount: Decimal
    fees: Decimal
    netAmount: Decimal
    reference: string
    type: $Enums.TransactionType
    flow: $Enums.TransactionFlow
    transactionAt: Date | null
    processedAt: Date | null
    desc: string | null
    status: $Enums.TransactionStatus
    isDeleted: boolean
    updatedAt: Date
    createdAt: Date
    _count: WalletTransactionCountAggregateOutputType | null
    _avg: WalletTransactionAvgAggregateOutputType | null
    _sum: WalletTransactionSumAggregateOutputType | null
    _min: WalletTransactionMinAggregateOutputType | null
    _max: WalletTransactionMaxAggregateOutputType | null
  }

  type GetWalletTransactionGroupByPayload<T extends WalletTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], WalletTransactionGroupByOutputType[P]>
        }
      >
    >


  export type WalletTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    amount?: boolean
    fees?: boolean
    netAmount?: boolean
    reference?: boolean
    type?: boolean
    flow?: boolean
    transactionAt?: boolean
    processedAt?: boolean
    desc?: boolean
    status?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
    ledger?: boolean | WalletTransaction$ledgerArgs<ExtArgs>
  }, ExtArgs["result"]["walletTransaction"]>

  export type WalletTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    amount?: boolean
    fees?: boolean
    netAmount?: boolean
    reference?: boolean
    type?: boolean
    flow?: boolean
    transactionAt?: boolean
    processedAt?: boolean
    desc?: boolean
    status?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["walletTransaction"]>

  export type WalletTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    amount?: boolean
    fees?: boolean
    netAmount?: boolean
    reference?: boolean
    type?: boolean
    flow?: boolean
    transactionAt?: boolean
    processedAt?: boolean
    desc?: boolean
    status?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["walletTransaction"]>

  export type WalletTransactionSelectScalar = {
    id?: boolean
    walletId?: boolean
    amount?: boolean
    fees?: boolean
    netAmount?: boolean
    reference?: boolean
    type?: boolean
    flow?: boolean
    transactionAt?: boolean
    processedAt?: boolean
    desc?: boolean
    status?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type WalletTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "walletId" | "amount" | "fees" | "netAmount" | "reference" | "type" | "flow" | "transactionAt" | "processedAt" | "desc" | "status" | "isDeleted" | "updatedAt" | "createdAt", ExtArgs["result"]["walletTransaction"]>
  export type WalletTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
    ledger?: boolean | WalletTransaction$ledgerArgs<ExtArgs>
  }
  export type WalletTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }
  export type WalletTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }

  export type $WalletTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WalletTransaction"
    objects: {
      wallet: Prisma.$WalletPayload<ExtArgs>
      ledger: Prisma.$LedgerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      walletId: string
      amount: Prisma.Decimal
      fees: Prisma.Decimal
      netAmount: Prisma.Decimal
      reference: string
      type: $Enums.TransactionType
      flow: $Enums.TransactionFlow
      transactionAt: Date | null
      processedAt: Date | null
      desc: string | null
      status: $Enums.TransactionStatus
      isDeleted: boolean
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["walletTransaction"]>
    composites: {}
  }

  type WalletTransactionGetPayload<S extends boolean | null | undefined | WalletTransactionDefaultArgs> = $Result.GetResult<Prisma.$WalletTransactionPayload, S>

  type WalletTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WalletTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletTransactionCountAggregateInputType | true
    }

  export interface WalletTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WalletTransaction'], meta: { name: 'WalletTransaction' } }
    /**
     * Find zero or one WalletTransaction that matches the filter.
     * @param {WalletTransactionFindUniqueArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletTransactionFindUniqueArgs>(args: SelectSubset<T, WalletTransactionFindUniqueArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WalletTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WalletTransactionFindUniqueOrThrowArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WalletTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindFirstArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletTransactionFindFirstArgs>(args?: SelectSubset<T, WalletTransactionFindFirstArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WalletTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindFirstOrThrowArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WalletTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WalletTransactions
     * const walletTransactions = await prisma.walletTransaction.findMany()
     * 
     * // Get first 10 WalletTransactions
     * const walletTransactions = await prisma.walletTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletTransactionWithIdOnly = await prisma.walletTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletTransactionFindManyArgs>(args?: SelectSubset<T, WalletTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WalletTransaction.
     * @param {WalletTransactionCreateArgs} args - Arguments to create a WalletTransaction.
     * @example
     * // Create one WalletTransaction
     * const WalletTransaction = await prisma.walletTransaction.create({
     *   data: {
     *     // ... data to create a WalletTransaction
     *   }
     * })
     * 
     */
    create<T extends WalletTransactionCreateArgs>(args: SelectSubset<T, WalletTransactionCreateArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WalletTransactions.
     * @param {WalletTransactionCreateManyArgs} args - Arguments to create many WalletTransactions.
     * @example
     * // Create many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletTransactionCreateManyArgs>(args?: SelectSubset<T, WalletTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WalletTransactions and returns the data saved in the database.
     * @param {WalletTransactionCreateManyAndReturnArgs} args - Arguments to create many WalletTransactions.
     * @example
     * // Create many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WalletTransactions and only return the `id`
     * const walletTransactionWithIdOnly = await prisma.walletTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WalletTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, WalletTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WalletTransaction.
     * @param {WalletTransactionDeleteArgs} args - Arguments to delete one WalletTransaction.
     * @example
     * // Delete one WalletTransaction
     * const WalletTransaction = await prisma.walletTransaction.delete({
     *   where: {
     *     // ... filter to delete one WalletTransaction
     *   }
     * })
     * 
     */
    delete<T extends WalletTransactionDeleteArgs>(args: SelectSubset<T, WalletTransactionDeleteArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WalletTransaction.
     * @param {WalletTransactionUpdateArgs} args - Arguments to update one WalletTransaction.
     * @example
     * // Update one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletTransactionUpdateArgs>(args: SelectSubset<T, WalletTransactionUpdateArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WalletTransactions.
     * @param {WalletTransactionDeleteManyArgs} args - Arguments to filter WalletTransactions to delete.
     * @example
     * // Delete a few WalletTransactions
     * const { count } = await prisma.walletTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletTransactionDeleteManyArgs>(args?: SelectSubset<T, WalletTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WalletTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletTransactionUpdateManyArgs>(args: SelectSubset<T, WalletTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WalletTransactions and returns the data updated in the database.
     * @param {WalletTransactionUpdateManyAndReturnArgs} args - Arguments to update many WalletTransactions.
     * @example
     * // Update many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WalletTransactions and only return the `id`
     * const walletTransactionWithIdOnly = await prisma.walletTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WalletTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, WalletTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WalletTransaction.
     * @param {WalletTransactionUpsertArgs} args - Arguments to update or create a WalletTransaction.
     * @example
     * // Update or create a WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.upsert({
     *   create: {
     *     // ... data to create a WalletTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WalletTransaction we want to update
     *   }
     * })
     */
    upsert<T extends WalletTransactionUpsertArgs>(args: SelectSubset<T, WalletTransactionUpsertArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WalletTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionCountArgs} args - Arguments to filter WalletTransactions to count.
     * @example
     * // Count the number of WalletTransactions
     * const count = await prisma.walletTransaction.count({
     *   where: {
     *     // ... the filter for the WalletTransactions we want to count
     *   }
     * })
    **/
    count<T extends WalletTransactionCountArgs>(
      args?: Subset<T, WalletTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WalletTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletTransactionAggregateArgs>(args: Subset<T, WalletTransactionAggregateArgs>): Prisma.PrismaPromise<GetWalletTransactionAggregateType<T>>

    /**
     * Group by WalletTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletTransactionGroupByArgs['orderBy'] }
        : { orderBy?: WalletTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WalletTransaction model
   */
  readonly fields: WalletTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WalletTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wallet<T extends WalletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WalletDefaultArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ledger<T extends WalletTransaction$ledgerArgs<ExtArgs> = {}>(args?: Subset<T, WalletTransaction$ledgerArgs<ExtArgs>>): Prisma__LedgerClient<$Result.GetResult<Prisma.$LedgerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WalletTransaction model
   */
  interface WalletTransactionFieldRefs {
    readonly id: FieldRef<"WalletTransaction", 'String'>
    readonly walletId: FieldRef<"WalletTransaction", 'String'>
    readonly amount: FieldRef<"WalletTransaction", 'Decimal'>
    readonly fees: FieldRef<"WalletTransaction", 'Decimal'>
    readonly netAmount: FieldRef<"WalletTransaction", 'Decimal'>
    readonly reference: FieldRef<"WalletTransaction", 'String'>
    readonly type: FieldRef<"WalletTransaction", 'TransactionType'>
    readonly flow: FieldRef<"WalletTransaction", 'TransactionFlow'>
    readonly transactionAt: FieldRef<"WalletTransaction", 'DateTime'>
    readonly processedAt: FieldRef<"WalletTransaction", 'DateTime'>
    readonly desc: FieldRef<"WalletTransaction", 'String'>
    readonly status: FieldRef<"WalletTransaction", 'TransactionStatus'>
    readonly isDeleted: FieldRef<"WalletTransaction", 'Boolean'>
    readonly updatedAt: FieldRef<"WalletTransaction", 'DateTime'>
    readonly createdAt: FieldRef<"WalletTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WalletTransaction findUnique
   */
  export type WalletTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction findUniqueOrThrow
   */
  export type WalletTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction findFirst
   */
  export type WalletTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletTransactions.
     */
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction findFirstOrThrow
   */
  export type WalletTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletTransactions.
     */
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction findMany
   */
  export type WalletTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransactions to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction create
   */
  export type WalletTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a WalletTransaction.
     */
    data: XOR<WalletTransactionCreateInput, WalletTransactionUncheckedCreateInput>
  }

  /**
   * WalletTransaction createMany
   */
  export type WalletTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WalletTransactions.
     */
    data: WalletTransactionCreateManyInput | WalletTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WalletTransaction createManyAndReturn
   */
  export type WalletTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many WalletTransactions.
     */
    data: WalletTransactionCreateManyInput | WalletTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WalletTransaction update
   */
  export type WalletTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a WalletTransaction.
     */
    data: XOR<WalletTransactionUpdateInput, WalletTransactionUncheckedUpdateInput>
    /**
     * Choose, which WalletTransaction to update.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction updateMany
   */
  export type WalletTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WalletTransactions.
     */
    data: XOR<WalletTransactionUpdateManyMutationInput, WalletTransactionUncheckedUpdateManyInput>
    /**
     * Filter which WalletTransactions to update
     */
    where?: WalletTransactionWhereInput
    /**
     * Limit how many WalletTransactions to update.
     */
    limit?: number
  }

  /**
   * WalletTransaction updateManyAndReturn
   */
  export type WalletTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * The data used to update WalletTransactions.
     */
    data: XOR<WalletTransactionUpdateManyMutationInput, WalletTransactionUncheckedUpdateManyInput>
    /**
     * Filter which WalletTransactions to update
     */
    where?: WalletTransactionWhereInput
    /**
     * Limit how many WalletTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WalletTransaction upsert
   */
  export type WalletTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the WalletTransaction to update in case it exists.
     */
    where: WalletTransactionWhereUniqueInput
    /**
     * In case the WalletTransaction found by the `where` argument doesn't exist, create a new WalletTransaction with this data.
     */
    create: XOR<WalletTransactionCreateInput, WalletTransactionUncheckedCreateInput>
    /**
     * In case the WalletTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletTransactionUpdateInput, WalletTransactionUncheckedUpdateInput>
  }

  /**
   * WalletTransaction delete
   */
  export type WalletTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter which WalletTransaction to delete.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction deleteMany
   */
  export type WalletTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletTransactions to delete
     */
    where?: WalletTransactionWhereInput
    /**
     * Limit how many WalletTransactions to delete.
     */
    limit?: number
  }

  /**
   * WalletTransaction.ledger
   */
  export type WalletTransaction$ledgerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ledger
     */
    omit?: LedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerInclude<ExtArgs> | null
    where?: LedgerWhereInput
  }

  /**
   * WalletTransaction without action
   */
  export type WalletTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletTransaction
     */
    omit?: WalletTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
  }


  /**
   * Model Ledger
   */

  export type AggregateLedger = {
    _count: LedgerCountAggregateOutputType | null
    _avg: LedgerAvgAggregateOutputType | null
    _sum: LedgerSumAggregateOutputType | null
    _min: LedgerMinAggregateOutputType | null
    _max: LedgerMaxAggregateOutputType | null
  }

  export type LedgerAvgAggregateOutputType = {
    debit: Decimal | null
    credit: Decimal | null
    balanceBefore: Decimal | null
    balanceAfter: Decimal | null
  }

  export type LedgerSumAggregateOutputType = {
    debit: Decimal | null
    credit: Decimal | null
    balanceBefore: Decimal | null
    balanceAfter: Decimal | null
  }

  export type LedgerMinAggregateOutputType = {
    id: string | null
    walletId: string | null
    transactionId: string | null
    debit: Decimal | null
    credit: Decimal | null
    balanceBefore: Decimal | null
    balanceAfter: Decimal | null
    description: string | null
    isDeleted: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type LedgerMaxAggregateOutputType = {
    id: string | null
    walletId: string | null
    transactionId: string | null
    debit: Decimal | null
    credit: Decimal | null
    balanceBefore: Decimal | null
    balanceAfter: Decimal | null
    description: string | null
    isDeleted: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type LedgerCountAggregateOutputType = {
    id: number
    walletId: number
    transactionId: number
    debit: number
    credit: number
    balanceBefore: number
    balanceAfter: number
    description: number
    isDeleted: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type LedgerAvgAggregateInputType = {
    debit?: true
    credit?: true
    balanceBefore?: true
    balanceAfter?: true
  }

  export type LedgerSumAggregateInputType = {
    debit?: true
    credit?: true
    balanceBefore?: true
    balanceAfter?: true
  }

  export type LedgerMinAggregateInputType = {
    id?: true
    walletId?: true
    transactionId?: true
    debit?: true
    credit?: true
    balanceBefore?: true
    balanceAfter?: true
    description?: true
    isDeleted?: true
    updatedAt?: true
    createdAt?: true
  }

  export type LedgerMaxAggregateInputType = {
    id?: true
    walletId?: true
    transactionId?: true
    debit?: true
    credit?: true
    balanceBefore?: true
    balanceAfter?: true
    description?: true
    isDeleted?: true
    updatedAt?: true
    createdAt?: true
  }

  export type LedgerCountAggregateInputType = {
    id?: true
    walletId?: true
    transactionId?: true
    debit?: true
    credit?: true
    balanceBefore?: true
    balanceAfter?: true
    description?: true
    isDeleted?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type LedgerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ledger to aggregate.
     */
    where?: LedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ledgers to fetch.
     */
    orderBy?: LedgerOrderByWithRelationInput | LedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ledgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ledgers
    **/
    _count?: true | LedgerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LedgerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LedgerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LedgerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LedgerMaxAggregateInputType
  }

  export type GetLedgerAggregateType<T extends LedgerAggregateArgs> = {
        [P in keyof T & keyof AggregateLedger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLedger[P]>
      : GetScalarType<T[P], AggregateLedger[P]>
  }




  export type LedgerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerWhereInput
    orderBy?: LedgerOrderByWithAggregationInput | LedgerOrderByWithAggregationInput[]
    by: LedgerScalarFieldEnum[] | LedgerScalarFieldEnum
    having?: LedgerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LedgerCountAggregateInputType | true
    _avg?: LedgerAvgAggregateInputType
    _sum?: LedgerSumAggregateInputType
    _min?: LedgerMinAggregateInputType
    _max?: LedgerMaxAggregateInputType
  }

  export type LedgerGroupByOutputType = {
    id: string
    walletId: string
    transactionId: string
    debit: Decimal
    credit: Decimal
    balanceBefore: Decimal
    balanceAfter: Decimal
    description: string | null
    isDeleted: boolean
    updatedAt: Date
    createdAt: Date
    _count: LedgerCountAggregateOutputType | null
    _avg: LedgerAvgAggregateOutputType | null
    _sum: LedgerSumAggregateOutputType | null
    _min: LedgerMinAggregateOutputType | null
    _max: LedgerMaxAggregateOutputType | null
  }

  type GetLedgerGroupByPayload<T extends LedgerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LedgerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LedgerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LedgerGroupByOutputType[P]>
            : GetScalarType<T[P], LedgerGroupByOutputType[P]>
        }
      >
    >


  export type LedgerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    transactionId?: boolean
    debit?: boolean
    credit?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    description?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
    transaction?: boolean | WalletTransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ledger"]>

  export type LedgerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    transactionId?: boolean
    debit?: boolean
    credit?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    description?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
    transaction?: boolean | WalletTransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ledger"]>

  export type LedgerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    transactionId?: boolean
    debit?: boolean
    credit?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    description?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
    transaction?: boolean | WalletTransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ledger"]>

  export type LedgerSelectScalar = {
    id?: boolean
    walletId?: boolean
    transactionId?: boolean
    debit?: boolean
    credit?: boolean
    balanceBefore?: boolean
    balanceAfter?: boolean
    description?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type LedgerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "walletId" | "transactionId" | "debit" | "credit" | "balanceBefore" | "balanceAfter" | "description" | "isDeleted" | "updatedAt" | "createdAt", ExtArgs["result"]["ledger"]>
  export type LedgerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
    transaction?: boolean | WalletTransactionDefaultArgs<ExtArgs>
  }
  export type LedgerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
    transaction?: boolean | WalletTransactionDefaultArgs<ExtArgs>
  }
  export type LedgerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
    transaction?: boolean | WalletTransactionDefaultArgs<ExtArgs>
  }

  export type $LedgerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ledger"
    objects: {
      wallet: Prisma.$WalletPayload<ExtArgs>
      transaction: Prisma.$WalletTransactionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      walletId: string
      transactionId: string
      debit: Prisma.Decimal
      credit: Prisma.Decimal
      balanceBefore: Prisma.Decimal
      balanceAfter: Prisma.Decimal
      description: string | null
      isDeleted: boolean
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["ledger"]>
    composites: {}
  }

  type LedgerGetPayload<S extends boolean | null | undefined | LedgerDefaultArgs> = $Result.GetResult<Prisma.$LedgerPayload, S>

  type LedgerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LedgerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LedgerCountAggregateInputType | true
    }

  export interface LedgerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ledger'], meta: { name: 'Ledger' } }
    /**
     * Find zero or one Ledger that matches the filter.
     * @param {LedgerFindUniqueArgs} args - Arguments to find a Ledger
     * @example
     * // Get one Ledger
     * const ledger = await prisma.ledger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LedgerFindUniqueArgs>(args: SelectSubset<T, LedgerFindUniqueArgs<ExtArgs>>): Prisma__LedgerClient<$Result.GetResult<Prisma.$LedgerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ledger that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LedgerFindUniqueOrThrowArgs} args - Arguments to find a Ledger
     * @example
     * // Get one Ledger
     * const ledger = await prisma.ledger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LedgerFindUniqueOrThrowArgs>(args: SelectSubset<T, LedgerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LedgerClient<$Result.GetResult<Prisma.$LedgerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ledger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerFindFirstArgs} args - Arguments to find a Ledger
     * @example
     * // Get one Ledger
     * const ledger = await prisma.ledger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LedgerFindFirstArgs>(args?: SelectSubset<T, LedgerFindFirstArgs<ExtArgs>>): Prisma__LedgerClient<$Result.GetResult<Prisma.$LedgerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ledger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerFindFirstOrThrowArgs} args - Arguments to find a Ledger
     * @example
     * // Get one Ledger
     * const ledger = await prisma.ledger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LedgerFindFirstOrThrowArgs>(args?: SelectSubset<T, LedgerFindFirstOrThrowArgs<ExtArgs>>): Prisma__LedgerClient<$Result.GetResult<Prisma.$LedgerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ledgers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ledgers
     * const ledgers = await prisma.ledger.findMany()
     * 
     * // Get first 10 Ledgers
     * const ledgers = await prisma.ledger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ledgerWithIdOnly = await prisma.ledger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LedgerFindManyArgs>(args?: SelectSubset<T, LedgerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ledger.
     * @param {LedgerCreateArgs} args - Arguments to create a Ledger.
     * @example
     * // Create one Ledger
     * const Ledger = await prisma.ledger.create({
     *   data: {
     *     // ... data to create a Ledger
     *   }
     * })
     * 
     */
    create<T extends LedgerCreateArgs>(args: SelectSubset<T, LedgerCreateArgs<ExtArgs>>): Prisma__LedgerClient<$Result.GetResult<Prisma.$LedgerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ledgers.
     * @param {LedgerCreateManyArgs} args - Arguments to create many Ledgers.
     * @example
     * // Create many Ledgers
     * const ledger = await prisma.ledger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LedgerCreateManyArgs>(args?: SelectSubset<T, LedgerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ledgers and returns the data saved in the database.
     * @param {LedgerCreateManyAndReturnArgs} args - Arguments to create many Ledgers.
     * @example
     * // Create many Ledgers
     * const ledger = await prisma.ledger.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ledgers and only return the `id`
     * const ledgerWithIdOnly = await prisma.ledger.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LedgerCreateManyAndReturnArgs>(args?: SelectSubset<T, LedgerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ledger.
     * @param {LedgerDeleteArgs} args - Arguments to delete one Ledger.
     * @example
     * // Delete one Ledger
     * const Ledger = await prisma.ledger.delete({
     *   where: {
     *     // ... filter to delete one Ledger
     *   }
     * })
     * 
     */
    delete<T extends LedgerDeleteArgs>(args: SelectSubset<T, LedgerDeleteArgs<ExtArgs>>): Prisma__LedgerClient<$Result.GetResult<Prisma.$LedgerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ledger.
     * @param {LedgerUpdateArgs} args - Arguments to update one Ledger.
     * @example
     * // Update one Ledger
     * const ledger = await prisma.ledger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LedgerUpdateArgs>(args: SelectSubset<T, LedgerUpdateArgs<ExtArgs>>): Prisma__LedgerClient<$Result.GetResult<Prisma.$LedgerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ledgers.
     * @param {LedgerDeleteManyArgs} args - Arguments to filter Ledgers to delete.
     * @example
     * // Delete a few Ledgers
     * const { count } = await prisma.ledger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LedgerDeleteManyArgs>(args?: SelectSubset<T, LedgerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ledgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ledgers
     * const ledger = await prisma.ledger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LedgerUpdateManyArgs>(args: SelectSubset<T, LedgerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ledgers and returns the data updated in the database.
     * @param {LedgerUpdateManyAndReturnArgs} args - Arguments to update many Ledgers.
     * @example
     * // Update many Ledgers
     * const ledger = await prisma.ledger.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ledgers and only return the `id`
     * const ledgerWithIdOnly = await prisma.ledger.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LedgerUpdateManyAndReturnArgs>(args: SelectSubset<T, LedgerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ledger.
     * @param {LedgerUpsertArgs} args - Arguments to update or create a Ledger.
     * @example
     * // Update or create a Ledger
     * const ledger = await prisma.ledger.upsert({
     *   create: {
     *     // ... data to create a Ledger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ledger we want to update
     *   }
     * })
     */
    upsert<T extends LedgerUpsertArgs>(args: SelectSubset<T, LedgerUpsertArgs<ExtArgs>>): Prisma__LedgerClient<$Result.GetResult<Prisma.$LedgerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ledgers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerCountArgs} args - Arguments to filter Ledgers to count.
     * @example
     * // Count the number of Ledgers
     * const count = await prisma.ledger.count({
     *   where: {
     *     // ... the filter for the Ledgers we want to count
     *   }
     * })
    **/
    count<T extends LedgerCountArgs>(
      args?: Subset<T, LedgerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LedgerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ledger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LedgerAggregateArgs>(args: Subset<T, LedgerAggregateArgs>): Prisma.PrismaPromise<GetLedgerAggregateType<T>>

    /**
     * Group by Ledger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LedgerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LedgerGroupByArgs['orderBy'] }
        : { orderBy?: LedgerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LedgerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLedgerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ledger model
   */
  readonly fields: LedgerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ledger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LedgerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wallet<T extends WalletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WalletDefaultArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transaction<T extends WalletTransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WalletTransactionDefaultArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ledger model
   */
  interface LedgerFieldRefs {
    readonly id: FieldRef<"Ledger", 'String'>
    readonly walletId: FieldRef<"Ledger", 'String'>
    readonly transactionId: FieldRef<"Ledger", 'String'>
    readonly debit: FieldRef<"Ledger", 'Decimal'>
    readonly credit: FieldRef<"Ledger", 'Decimal'>
    readonly balanceBefore: FieldRef<"Ledger", 'Decimal'>
    readonly balanceAfter: FieldRef<"Ledger", 'Decimal'>
    readonly description: FieldRef<"Ledger", 'String'>
    readonly isDeleted: FieldRef<"Ledger", 'Boolean'>
    readonly updatedAt: FieldRef<"Ledger", 'DateTime'>
    readonly createdAt: FieldRef<"Ledger", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ledger findUnique
   */
  export type LedgerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ledger
     */
    omit?: LedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * Filter, which Ledger to fetch.
     */
    where: LedgerWhereUniqueInput
  }

  /**
   * Ledger findUniqueOrThrow
   */
  export type LedgerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ledger
     */
    omit?: LedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * Filter, which Ledger to fetch.
     */
    where: LedgerWhereUniqueInput
  }

  /**
   * Ledger findFirst
   */
  export type LedgerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ledger
     */
    omit?: LedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * Filter, which Ledger to fetch.
     */
    where?: LedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ledgers to fetch.
     */
    orderBy?: LedgerOrderByWithRelationInput | LedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ledgers.
     */
    cursor?: LedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ledgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ledgers.
     */
    distinct?: LedgerScalarFieldEnum | LedgerScalarFieldEnum[]
  }

  /**
   * Ledger findFirstOrThrow
   */
  export type LedgerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ledger
     */
    omit?: LedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * Filter, which Ledger to fetch.
     */
    where?: LedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ledgers to fetch.
     */
    orderBy?: LedgerOrderByWithRelationInput | LedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ledgers.
     */
    cursor?: LedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ledgers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ledgers.
     */
    distinct?: LedgerScalarFieldEnum | LedgerScalarFieldEnum[]
  }

  /**
   * Ledger findMany
   */
  export type LedgerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ledger
     */
    omit?: LedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * Filter, which Ledgers to fetch.
     */
    where?: LedgerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ledgers to fetch.
     */
    orderBy?: LedgerOrderByWithRelationInput | LedgerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ledgers.
     */
    cursor?: LedgerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ledgers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ledgers.
     */
    skip?: number
    distinct?: LedgerScalarFieldEnum | LedgerScalarFieldEnum[]
  }

  /**
   * Ledger create
   */
  export type LedgerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ledger
     */
    omit?: LedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * The data needed to create a Ledger.
     */
    data: XOR<LedgerCreateInput, LedgerUncheckedCreateInput>
  }

  /**
   * Ledger createMany
   */
  export type LedgerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ledgers.
     */
    data: LedgerCreateManyInput | LedgerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ledger createManyAndReturn
   */
  export type LedgerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ledger
     */
    omit?: LedgerOmit<ExtArgs> | null
    /**
     * The data used to create many Ledgers.
     */
    data: LedgerCreateManyInput | LedgerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ledger update
   */
  export type LedgerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ledger
     */
    omit?: LedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * The data needed to update a Ledger.
     */
    data: XOR<LedgerUpdateInput, LedgerUncheckedUpdateInput>
    /**
     * Choose, which Ledger to update.
     */
    where: LedgerWhereUniqueInput
  }

  /**
   * Ledger updateMany
   */
  export type LedgerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ledgers.
     */
    data: XOR<LedgerUpdateManyMutationInput, LedgerUncheckedUpdateManyInput>
    /**
     * Filter which Ledgers to update
     */
    where?: LedgerWhereInput
    /**
     * Limit how many Ledgers to update.
     */
    limit?: number
  }

  /**
   * Ledger updateManyAndReturn
   */
  export type LedgerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ledger
     */
    omit?: LedgerOmit<ExtArgs> | null
    /**
     * The data used to update Ledgers.
     */
    data: XOR<LedgerUpdateManyMutationInput, LedgerUncheckedUpdateManyInput>
    /**
     * Filter which Ledgers to update
     */
    where?: LedgerWhereInput
    /**
     * Limit how many Ledgers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ledger upsert
   */
  export type LedgerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ledger
     */
    omit?: LedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * The filter to search for the Ledger to update in case it exists.
     */
    where: LedgerWhereUniqueInput
    /**
     * In case the Ledger found by the `where` argument doesn't exist, create a new Ledger with this data.
     */
    create: XOR<LedgerCreateInput, LedgerUncheckedCreateInput>
    /**
     * In case the Ledger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LedgerUpdateInput, LedgerUncheckedUpdateInput>
  }

  /**
   * Ledger delete
   */
  export type LedgerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ledger
     */
    omit?: LedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerInclude<ExtArgs> | null
    /**
     * Filter which Ledger to delete.
     */
    where: LedgerWhereUniqueInput
  }

  /**
   * Ledger deleteMany
   */
  export type LedgerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ledgers to delete
     */
    where?: LedgerWhereInput
    /**
     * Limit how many Ledgers to delete.
     */
    limit?: number
  }

  /**
   * Ledger without action
   */
  export type LedgerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ledger
     */
    select?: LedgerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ledger
     */
    omit?: LedgerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerInclude<ExtArgs> | null
  }


  /**
   * Model FirebaseToken
   */

  export type AggregateFirebaseToken = {
    _count: FirebaseTokenCountAggregateOutputType | null
    _min: FirebaseTokenMinAggregateOutputType | null
    _max: FirebaseTokenMaxAggregateOutputType | null
  }

  export type FirebaseTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    isDeleted: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type FirebaseTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    isDeleted: boolean | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type FirebaseTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    isDeleted: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type FirebaseTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    isDeleted?: true
    updatedAt?: true
    createdAt?: true
  }

  export type FirebaseTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    isDeleted?: true
    updatedAt?: true
    createdAt?: true
  }

  export type FirebaseTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    isDeleted?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type FirebaseTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FirebaseToken to aggregate.
     */
    where?: FirebaseTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FirebaseTokens to fetch.
     */
    orderBy?: FirebaseTokenOrderByWithRelationInput | FirebaseTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FirebaseTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FirebaseTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FirebaseTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FirebaseTokens
    **/
    _count?: true | FirebaseTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FirebaseTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FirebaseTokenMaxAggregateInputType
  }

  export type GetFirebaseTokenAggregateType<T extends FirebaseTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateFirebaseToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFirebaseToken[P]>
      : GetScalarType<T[P], AggregateFirebaseToken[P]>
  }




  export type FirebaseTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FirebaseTokenWhereInput
    orderBy?: FirebaseTokenOrderByWithAggregationInput | FirebaseTokenOrderByWithAggregationInput[]
    by: FirebaseTokenScalarFieldEnum[] | FirebaseTokenScalarFieldEnum
    having?: FirebaseTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FirebaseTokenCountAggregateInputType | true
    _min?: FirebaseTokenMinAggregateInputType
    _max?: FirebaseTokenMaxAggregateInputType
  }

  export type FirebaseTokenGroupByOutputType = {
    id: string
    userId: string
    token: string | null
    isDeleted: boolean
    updatedAt: Date
    createdAt: Date
    _count: FirebaseTokenCountAggregateOutputType | null
    _min: FirebaseTokenMinAggregateOutputType | null
    _max: FirebaseTokenMaxAggregateOutputType | null
  }

  type GetFirebaseTokenGroupByPayload<T extends FirebaseTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FirebaseTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FirebaseTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FirebaseTokenGroupByOutputType[P]>
            : GetScalarType<T[P], FirebaseTokenGroupByOutputType[P]>
        }
      >
    >


  export type FirebaseTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["firebaseToken"]>

  export type FirebaseTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["firebaseToken"]>

  export type FirebaseTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["firebaseToken"]>

  export type FirebaseTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    isDeleted?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type FirebaseTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "isDeleted" | "updatedAt" | "createdAt", ExtArgs["result"]["firebaseToken"]>
  export type FirebaseTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FirebaseTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FirebaseTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FirebaseTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FirebaseToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string | null
      isDeleted: boolean
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["firebaseToken"]>
    composites: {}
  }

  type FirebaseTokenGetPayload<S extends boolean | null | undefined | FirebaseTokenDefaultArgs> = $Result.GetResult<Prisma.$FirebaseTokenPayload, S>

  type FirebaseTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FirebaseTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FirebaseTokenCountAggregateInputType | true
    }

  export interface FirebaseTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FirebaseToken'], meta: { name: 'FirebaseToken' } }
    /**
     * Find zero or one FirebaseToken that matches the filter.
     * @param {FirebaseTokenFindUniqueArgs} args - Arguments to find a FirebaseToken
     * @example
     * // Get one FirebaseToken
     * const firebaseToken = await prisma.firebaseToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FirebaseTokenFindUniqueArgs>(args: SelectSubset<T, FirebaseTokenFindUniqueArgs<ExtArgs>>): Prisma__FirebaseTokenClient<$Result.GetResult<Prisma.$FirebaseTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FirebaseToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FirebaseTokenFindUniqueOrThrowArgs} args - Arguments to find a FirebaseToken
     * @example
     * // Get one FirebaseToken
     * const firebaseToken = await prisma.firebaseToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FirebaseTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, FirebaseTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FirebaseTokenClient<$Result.GetResult<Prisma.$FirebaseTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FirebaseToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirebaseTokenFindFirstArgs} args - Arguments to find a FirebaseToken
     * @example
     * // Get one FirebaseToken
     * const firebaseToken = await prisma.firebaseToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FirebaseTokenFindFirstArgs>(args?: SelectSubset<T, FirebaseTokenFindFirstArgs<ExtArgs>>): Prisma__FirebaseTokenClient<$Result.GetResult<Prisma.$FirebaseTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FirebaseToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirebaseTokenFindFirstOrThrowArgs} args - Arguments to find a FirebaseToken
     * @example
     * // Get one FirebaseToken
     * const firebaseToken = await prisma.firebaseToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FirebaseTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, FirebaseTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__FirebaseTokenClient<$Result.GetResult<Prisma.$FirebaseTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FirebaseTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirebaseTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FirebaseTokens
     * const firebaseTokens = await prisma.firebaseToken.findMany()
     * 
     * // Get first 10 FirebaseTokens
     * const firebaseTokens = await prisma.firebaseToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const firebaseTokenWithIdOnly = await prisma.firebaseToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FirebaseTokenFindManyArgs>(args?: SelectSubset<T, FirebaseTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FirebaseTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FirebaseToken.
     * @param {FirebaseTokenCreateArgs} args - Arguments to create a FirebaseToken.
     * @example
     * // Create one FirebaseToken
     * const FirebaseToken = await prisma.firebaseToken.create({
     *   data: {
     *     // ... data to create a FirebaseToken
     *   }
     * })
     * 
     */
    create<T extends FirebaseTokenCreateArgs>(args: SelectSubset<T, FirebaseTokenCreateArgs<ExtArgs>>): Prisma__FirebaseTokenClient<$Result.GetResult<Prisma.$FirebaseTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FirebaseTokens.
     * @param {FirebaseTokenCreateManyArgs} args - Arguments to create many FirebaseTokens.
     * @example
     * // Create many FirebaseTokens
     * const firebaseToken = await prisma.firebaseToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FirebaseTokenCreateManyArgs>(args?: SelectSubset<T, FirebaseTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FirebaseTokens and returns the data saved in the database.
     * @param {FirebaseTokenCreateManyAndReturnArgs} args - Arguments to create many FirebaseTokens.
     * @example
     * // Create many FirebaseTokens
     * const firebaseToken = await prisma.firebaseToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FirebaseTokens and only return the `id`
     * const firebaseTokenWithIdOnly = await prisma.firebaseToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FirebaseTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, FirebaseTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FirebaseTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FirebaseToken.
     * @param {FirebaseTokenDeleteArgs} args - Arguments to delete one FirebaseToken.
     * @example
     * // Delete one FirebaseToken
     * const FirebaseToken = await prisma.firebaseToken.delete({
     *   where: {
     *     // ... filter to delete one FirebaseToken
     *   }
     * })
     * 
     */
    delete<T extends FirebaseTokenDeleteArgs>(args: SelectSubset<T, FirebaseTokenDeleteArgs<ExtArgs>>): Prisma__FirebaseTokenClient<$Result.GetResult<Prisma.$FirebaseTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FirebaseToken.
     * @param {FirebaseTokenUpdateArgs} args - Arguments to update one FirebaseToken.
     * @example
     * // Update one FirebaseToken
     * const firebaseToken = await prisma.firebaseToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FirebaseTokenUpdateArgs>(args: SelectSubset<T, FirebaseTokenUpdateArgs<ExtArgs>>): Prisma__FirebaseTokenClient<$Result.GetResult<Prisma.$FirebaseTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FirebaseTokens.
     * @param {FirebaseTokenDeleteManyArgs} args - Arguments to filter FirebaseTokens to delete.
     * @example
     * // Delete a few FirebaseTokens
     * const { count } = await prisma.firebaseToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FirebaseTokenDeleteManyArgs>(args?: SelectSubset<T, FirebaseTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FirebaseTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirebaseTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FirebaseTokens
     * const firebaseToken = await prisma.firebaseToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FirebaseTokenUpdateManyArgs>(args: SelectSubset<T, FirebaseTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FirebaseTokens and returns the data updated in the database.
     * @param {FirebaseTokenUpdateManyAndReturnArgs} args - Arguments to update many FirebaseTokens.
     * @example
     * // Update many FirebaseTokens
     * const firebaseToken = await prisma.firebaseToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FirebaseTokens and only return the `id`
     * const firebaseTokenWithIdOnly = await prisma.firebaseToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FirebaseTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, FirebaseTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FirebaseTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FirebaseToken.
     * @param {FirebaseTokenUpsertArgs} args - Arguments to update or create a FirebaseToken.
     * @example
     * // Update or create a FirebaseToken
     * const firebaseToken = await prisma.firebaseToken.upsert({
     *   create: {
     *     // ... data to create a FirebaseToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FirebaseToken we want to update
     *   }
     * })
     */
    upsert<T extends FirebaseTokenUpsertArgs>(args: SelectSubset<T, FirebaseTokenUpsertArgs<ExtArgs>>): Prisma__FirebaseTokenClient<$Result.GetResult<Prisma.$FirebaseTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FirebaseTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirebaseTokenCountArgs} args - Arguments to filter FirebaseTokens to count.
     * @example
     * // Count the number of FirebaseTokens
     * const count = await prisma.firebaseToken.count({
     *   where: {
     *     // ... the filter for the FirebaseTokens we want to count
     *   }
     * })
    **/
    count<T extends FirebaseTokenCountArgs>(
      args?: Subset<T, FirebaseTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FirebaseTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FirebaseToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirebaseTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FirebaseTokenAggregateArgs>(args: Subset<T, FirebaseTokenAggregateArgs>): Prisma.PrismaPromise<GetFirebaseTokenAggregateType<T>>

    /**
     * Group by FirebaseToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirebaseTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FirebaseTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FirebaseTokenGroupByArgs['orderBy'] }
        : { orderBy?: FirebaseTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FirebaseTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFirebaseTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FirebaseToken model
   */
  readonly fields: FirebaseTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FirebaseToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FirebaseTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FirebaseToken model
   */
  interface FirebaseTokenFieldRefs {
    readonly id: FieldRef<"FirebaseToken", 'String'>
    readonly userId: FieldRef<"FirebaseToken", 'String'>
    readonly token: FieldRef<"FirebaseToken", 'String'>
    readonly isDeleted: FieldRef<"FirebaseToken", 'Boolean'>
    readonly updatedAt: FieldRef<"FirebaseToken", 'DateTime'>
    readonly createdAt: FieldRef<"FirebaseToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FirebaseToken findUnique
   */
  export type FirebaseTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirebaseToken
     */
    select?: FirebaseTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirebaseToken
     */
    omit?: FirebaseTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirebaseTokenInclude<ExtArgs> | null
    /**
     * Filter, which FirebaseToken to fetch.
     */
    where: FirebaseTokenWhereUniqueInput
  }

  /**
   * FirebaseToken findUniqueOrThrow
   */
  export type FirebaseTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirebaseToken
     */
    select?: FirebaseTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirebaseToken
     */
    omit?: FirebaseTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirebaseTokenInclude<ExtArgs> | null
    /**
     * Filter, which FirebaseToken to fetch.
     */
    where: FirebaseTokenWhereUniqueInput
  }

  /**
   * FirebaseToken findFirst
   */
  export type FirebaseTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirebaseToken
     */
    select?: FirebaseTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirebaseToken
     */
    omit?: FirebaseTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirebaseTokenInclude<ExtArgs> | null
    /**
     * Filter, which FirebaseToken to fetch.
     */
    where?: FirebaseTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FirebaseTokens to fetch.
     */
    orderBy?: FirebaseTokenOrderByWithRelationInput | FirebaseTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FirebaseTokens.
     */
    cursor?: FirebaseTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FirebaseTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FirebaseTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FirebaseTokens.
     */
    distinct?: FirebaseTokenScalarFieldEnum | FirebaseTokenScalarFieldEnum[]
  }

  /**
   * FirebaseToken findFirstOrThrow
   */
  export type FirebaseTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirebaseToken
     */
    select?: FirebaseTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirebaseToken
     */
    omit?: FirebaseTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirebaseTokenInclude<ExtArgs> | null
    /**
     * Filter, which FirebaseToken to fetch.
     */
    where?: FirebaseTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FirebaseTokens to fetch.
     */
    orderBy?: FirebaseTokenOrderByWithRelationInput | FirebaseTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FirebaseTokens.
     */
    cursor?: FirebaseTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FirebaseTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FirebaseTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FirebaseTokens.
     */
    distinct?: FirebaseTokenScalarFieldEnum | FirebaseTokenScalarFieldEnum[]
  }

  /**
   * FirebaseToken findMany
   */
  export type FirebaseTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirebaseToken
     */
    select?: FirebaseTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirebaseToken
     */
    omit?: FirebaseTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirebaseTokenInclude<ExtArgs> | null
    /**
     * Filter, which FirebaseTokens to fetch.
     */
    where?: FirebaseTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FirebaseTokens to fetch.
     */
    orderBy?: FirebaseTokenOrderByWithRelationInput | FirebaseTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FirebaseTokens.
     */
    cursor?: FirebaseTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FirebaseTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FirebaseTokens.
     */
    skip?: number
    distinct?: FirebaseTokenScalarFieldEnum | FirebaseTokenScalarFieldEnum[]
  }

  /**
   * FirebaseToken create
   */
  export type FirebaseTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirebaseToken
     */
    select?: FirebaseTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirebaseToken
     */
    omit?: FirebaseTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirebaseTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a FirebaseToken.
     */
    data: XOR<FirebaseTokenCreateInput, FirebaseTokenUncheckedCreateInput>
  }

  /**
   * FirebaseToken createMany
   */
  export type FirebaseTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FirebaseTokens.
     */
    data: FirebaseTokenCreateManyInput | FirebaseTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FirebaseToken createManyAndReturn
   */
  export type FirebaseTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirebaseToken
     */
    select?: FirebaseTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FirebaseToken
     */
    omit?: FirebaseTokenOmit<ExtArgs> | null
    /**
     * The data used to create many FirebaseTokens.
     */
    data: FirebaseTokenCreateManyInput | FirebaseTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirebaseTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FirebaseToken update
   */
  export type FirebaseTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirebaseToken
     */
    select?: FirebaseTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirebaseToken
     */
    omit?: FirebaseTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirebaseTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a FirebaseToken.
     */
    data: XOR<FirebaseTokenUpdateInput, FirebaseTokenUncheckedUpdateInput>
    /**
     * Choose, which FirebaseToken to update.
     */
    where: FirebaseTokenWhereUniqueInput
  }

  /**
   * FirebaseToken updateMany
   */
  export type FirebaseTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FirebaseTokens.
     */
    data: XOR<FirebaseTokenUpdateManyMutationInput, FirebaseTokenUncheckedUpdateManyInput>
    /**
     * Filter which FirebaseTokens to update
     */
    where?: FirebaseTokenWhereInput
    /**
     * Limit how many FirebaseTokens to update.
     */
    limit?: number
  }

  /**
   * FirebaseToken updateManyAndReturn
   */
  export type FirebaseTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirebaseToken
     */
    select?: FirebaseTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FirebaseToken
     */
    omit?: FirebaseTokenOmit<ExtArgs> | null
    /**
     * The data used to update FirebaseTokens.
     */
    data: XOR<FirebaseTokenUpdateManyMutationInput, FirebaseTokenUncheckedUpdateManyInput>
    /**
     * Filter which FirebaseTokens to update
     */
    where?: FirebaseTokenWhereInput
    /**
     * Limit how many FirebaseTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirebaseTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FirebaseToken upsert
   */
  export type FirebaseTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirebaseToken
     */
    select?: FirebaseTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirebaseToken
     */
    omit?: FirebaseTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirebaseTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the FirebaseToken to update in case it exists.
     */
    where: FirebaseTokenWhereUniqueInput
    /**
     * In case the FirebaseToken found by the `where` argument doesn't exist, create a new FirebaseToken with this data.
     */
    create: XOR<FirebaseTokenCreateInput, FirebaseTokenUncheckedCreateInput>
    /**
     * In case the FirebaseToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FirebaseTokenUpdateInput, FirebaseTokenUncheckedUpdateInput>
  }

  /**
   * FirebaseToken delete
   */
  export type FirebaseTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirebaseToken
     */
    select?: FirebaseTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirebaseToken
     */
    omit?: FirebaseTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirebaseTokenInclude<ExtArgs> | null
    /**
     * Filter which FirebaseToken to delete.
     */
    where: FirebaseTokenWhereUniqueInput
  }

  /**
   * FirebaseToken deleteMany
   */
  export type FirebaseTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FirebaseTokens to delete
     */
    where?: FirebaseTokenWhereInput
    /**
     * Limit how many FirebaseTokens to delete.
     */
    limit?: number
  }

  /**
   * FirebaseToken without action
   */
  export type FirebaseTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirebaseToken
     */
    select?: FirebaseTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FirebaseToken
     */
    omit?: FirebaseTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FirebaseTokenInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    profileImage: 'profileImage',
    email: 'email',
    type: 'type',
    phone: 'phone',
    accountStatus: 'accountStatus',
    verifiedAt: 'verifiedAt',
    lastSeenAt: 'lastSeenAt',
    isTermsAccepted: 'isTermsAccepted',
    isPrivacyAccepted: 'isPrivacyAccepted',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CredentialScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    password: 'password',
    pinCode: 'pinCode',
    lastResetAt: 'lastResetAt',
    lastUsedAt: 'lastUsedAt',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CredentialScalarFieldEnum = (typeof CredentialScalarFieldEnum)[keyof typeof CredentialScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    revoked: 'revoked',
    isDeleted: 'isDeleted',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const AdministratorScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdministratorScalarFieldEnum = (typeof AdministratorScalarFieldEnum)[keyof typeof AdministratorScalarFieldEnum]


  export const GuardianScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    address: 'address',
    city: 'city',
    state: 'state',
    country: 'country',
    postalCode: 'postalCode',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GuardianScalarFieldEnum = (typeof GuardianScalarFieldEnum)[keyof typeof GuardianScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    code: 'code',
    expiresAt: 'expiresAt',
    resendCount: 'resendCount',
    used: 'used',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const SchoolScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    name: 'name',
    address: 'address',
    city: 'city',
    state: 'state',
    country: 'country',
    lga: 'lga',
    postalCode: 'postalCode',
    email: 'email',
    phoneNumber: 'phoneNumber',
    establishedYear: 'establishedYear',
    website: 'website',
    logo: 'logo',
    schoolType: 'schoolType',
    ownership: 'ownership',
    status: 'status',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolScalarFieldEnum = (typeof SchoolScalarFieldEnum)[keyof typeof SchoolScalarFieldEnum]


  export const SchoolDirectorVerificationScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    directorFullName: 'directorFullName',
    directorIDType: 'directorIDType',
    directorIDNumber: 'directorIDNumber',
    document: 'document',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolDirectorVerificationScalarFieldEnum = (typeof SchoolDirectorVerificationScalarFieldEnum)[keyof typeof SchoolDirectorVerificationScalarFieldEnum]


  export const SchoolOwnershipVerificationScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    cacform7: 'cacform7',
    cacShareAllotmentForm: 'cacShareAllotmentForm',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolOwnershipVerificationScalarFieldEnum = (typeof SchoolOwnershipVerificationScalarFieldEnum)[keyof typeof SchoolOwnershipVerificationScalarFieldEnum]


  export const SchoolVerificationScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    cacCertificate: 'cacCertificate',
    accreditationDocument: 'accreditationDocument',
    taxIdentificationNumber: 'taxIdentificationNumber',
    licenseDocument: 'licenseDocument',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolVerificationScalarFieldEnum = (typeof SchoolVerificationScalarFieldEnum)[keyof typeof SchoolVerificationScalarFieldEnum]


  export const SchoolPayoutDetailScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    bankName: 'bankName',
    bankCode: 'bankCode',
    accountNumber: 'accountNumber',
    accountName: 'accountName',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolPayoutDetailScalarFieldEnum = (typeof SchoolPayoutDetailScalarFieldEnum)[keyof typeof SchoolPayoutDetailScalarFieldEnum]


  export const SchoolAndPlatformLegalAgreementScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    signedById: 'signedById',
    signature: 'signature',
    signedAt: 'signedAt',
    legalDocumentRef: 'legalDocumentRef',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolAndPlatformLegalAgreementScalarFieldEnum = (typeof SchoolAndPlatformLegalAgreementScalarFieldEnum)[keyof typeof SchoolAndPlatformLegalAgreementScalarFieldEnum]


  export const KYCVerificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    schoolId: 'schoolId',
    status: 'status',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KYCVerificationScalarFieldEnum = (typeof KYCVerificationScalarFieldEnum)[keyof typeof KYCVerificationScalarFieldEnum]


  export const ClassScalarFieldEnum: {
    id: 'id',
    name: 'name',
    schoolId: 'schoolId',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClassScalarFieldEnum = (typeof ClassScalarFieldEnum)[keyof typeof ClassScalarFieldEnum]


  export const AcademicSessionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    schoolId: 'schoolId',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AcademicSessionScalarFieldEnum = (typeof AcademicSessionScalarFieldEnum)[keyof typeof AcademicSessionScalarFieldEnum]


  export const TermScalarFieldEnum: {
    id: 'id',
    name: 'name',
    schoolId: 'schoolId',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TermScalarFieldEnum = (typeof TermScalarFieldEnum)[keyof typeof TermScalarFieldEnum]


  export const FeesScalarFieldEnum: {
    id: 'id',
    dueAt: 'dueAt',
    latePaymentFee: 'latePaymentFee',
    schoolId: 'schoolId',
    classId: 'classId',
    sessionId: 'sessionId',
    termId: 'termId',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeesScalarFieldEnum = (typeof FeesScalarFieldEnum)[keyof typeof FeesScalarFieldEnum]


  export const FeeBreakdownScalarFieldEnum: {
    id: 'id',
    feeId: 'feeId',
    title: 'title',
    amount: 'amount',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeeBreakdownScalarFieldEnum = (typeof FeeBreakdownScalarFieldEnum)[keyof typeof FeeBreakdownScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    invoiceNo: 'invoiceNo',
    feeId: 'feeId',
    guardianId: 'guardianId',
    classId: 'classId',
    sessionId: 'sessionId',
    termId: 'termId',
    totalAmount: 'totalAmount',
    status: 'status',
    dueAt: 'dueAt',
    paidAt: 'paidAt',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    image: 'image',
    classId: 'classId',
    guardianId: 'guardianId',
    registrationNumber: 'registrationNumber',
    status: 'status',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const LinkedStudentProfileScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    guardianId: 'guardianId',
    lastGuardiantChanged: 'lastGuardiantChanged',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LinkedStudentProfileScalarFieldEnum = (typeof LinkedStudentProfileScalarFieldEnum)[keyof typeof LinkedStudentProfileScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    guardianId: 'guardianId',
    invoiceId: 'invoiceId',
    reference: 'reference',
    amount: 'amount',
    fees: 'fees',
    status: 'status',
    transactionAt: 'transactionAt',
    processedAt: 'processedAt',
    description: 'description',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const TransactionFeeScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    platformFee: 'platformFee',
    latePaymentFee: 'latePaymentFee',
    processingFee: 'processingFee',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionFeeScalarFieldEnum = (typeof TransactionFeeScalarFieldEnum)[keyof typeof TransactionFeeScalarFieldEnum]


  export const PayoutScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    amount: 'amount',
    processingFee: 'processingFee',
    status: 'status',
    initiatedAt: 'initiatedAt',
    completedAt: 'completedAt',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PayoutScalarFieldEnum = (typeof PayoutScalarFieldEnum)[keyof typeof PayoutScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    status: 'status',
    sentAt: 'sentAt',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const WalletScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    address: 'address',
    name: 'name',
    tag: 'tag',
    routingNumber: 'routingNumber',
    balance: 'balance',
    status: 'status',
    isDeleted: 'isDeleted',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


  export const WalletTransactionScalarFieldEnum: {
    id: 'id',
    walletId: 'walletId',
    amount: 'amount',
    fees: 'fees',
    netAmount: 'netAmount',
    reference: 'reference',
    type: 'type',
    flow: 'flow',
    transactionAt: 'transactionAt',
    processedAt: 'processedAt',
    desc: 'desc',
    status: 'status',
    isDeleted: 'isDeleted',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type WalletTransactionScalarFieldEnum = (typeof WalletTransactionScalarFieldEnum)[keyof typeof WalletTransactionScalarFieldEnum]


  export const LedgerScalarFieldEnum: {
    id: 'id',
    walletId: 'walletId',
    transactionId: 'transactionId',
    debit: 'debit',
    credit: 'credit',
    balanceBefore: 'balanceBefore',
    balanceAfter: 'balanceAfter',
    description: 'description',
    isDeleted: 'isDeleted',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type LedgerScalarFieldEnum = (typeof LedgerScalarFieldEnum)[keyof typeof LedgerScalarFieldEnum]


  export const FirebaseTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    isDeleted: 'isDeleted',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type FirebaseTokenScalarFieldEnum = (typeof FirebaseTokenScalarFieldEnum)[keyof typeof FirebaseTokenScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserType'
   */
  export type EnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType'>
    


  /**
   * Reference to a field of type 'UserType[]'
   */
  export type ListEnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType[]'>
    


  /**
   * Reference to a field of type 'AccountStatus'
   */
  export type EnumAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountStatus'>
    


  /**
   * Reference to a field of type 'AccountStatus[]'
   */
  export type ListEnumAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'VerificationType'
   */
  export type EnumVerificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationType'>
    


  /**
   * Reference to a field of type 'VerificationType[]'
   */
  export type ListEnumVerificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'SchoolType'
   */
  export type EnumSchoolTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SchoolType'>
    


  /**
   * Reference to a field of type 'SchoolType[]'
   */
  export type ListEnumSchoolTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SchoolType[]'>
    


  /**
   * Reference to a field of type 'SchoolOwnership'
   */
  export type EnumSchoolOwnershipFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SchoolOwnership'>
    


  /**
   * Reference to a field of type 'SchoolOwnership[]'
   */
  export type ListEnumSchoolOwnershipFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SchoolOwnership[]'>
    


  /**
   * Reference to a field of type 'SchoolStatus'
   */
  export type EnumSchoolStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SchoolStatus'>
    


  /**
   * Reference to a field of type 'SchoolStatus[]'
   */
  export type ListEnumSchoolStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SchoolStatus[]'>
    


  /**
   * Reference to a field of type 'DirectorIDType'
   */
  export type EnumDirectorIDTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DirectorIDType'>
    


  /**
   * Reference to a field of type 'DirectorIDType[]'
   */
  export type ListEnumDirectorIDTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DirectorIDType[]'>
    


  /**
   * Reference to a field of type 'KYCVerificationStatus'
   */
  export type EnumKYCVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KYCVerificationStatus'>
    


  /**
   * Reference to a field of type 'KYCVerificationStatus[]'
   */
  export type ListEnumKYCVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KYCVerificationStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'StudentStatus'
   */
  export type EnumStudentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudentStatus'>
    


  /**
   * Reference to a field of type 'StudentStatus[]'
   */
  export type ListEnumStudentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudentStatus[]'>
    


  /**
   * Reference to a field of type 'TransactionStatus'
   */
  export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


  /**
   * Reference to a field of type 'TransactionStatus[]'
   */
  export type ListEnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus[]'>
    


  /**
   * Reference to a field of type 'PayoutStatus'
   */
  export type EnumPayoutStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayoutStatus'>
    


  /**
   * Reference to a field of type 'PayoutStatus[]'
   */
  export type ListEnumPayoutStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayoutStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationStatus'
   */
  export type EnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus'>
    


  /**
   * Reference to a field of type 'NotificationStatus[]'
   */
  export type ListEnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus[]'>
    


  /**
   * Reference to a field of type 'WalletStatus'
   */
  export type EnumWalletStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WalletStatus'>
    


  /**
   * Reference to a field of type 'WalletStatus[]'
   */
  export type ListEnumWalletStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WalletStatus[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'TransactionFlow'
   */
  export type EnumTransactionFlowFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionFlow'>
    


  /**
   * Reference to a field of type 'TransactionFlow[]'
   */
  export type ListEnumTransactionFlowFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionFlow[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    profileImage?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    type?: EnumUserTypeFilter<"User"> | $Enums.UserType
    phone?: StringNullableFilter<"User"> | string | null
    accountStatus?: EnumAccountStatusFilter<"User"> | $Enums.AccountStatus
    verifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastSeenAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isTermsAccepted?: BoolFilter<"User"> | boolean
    isPrivacyAccepted?: BoolFilter<"User"> | boolean
    isDeleted?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    administrator?: XOR<AdministratorNullableScalarRelationFilter, AdministratorWhereInput> | null
    guardian?: XOR<GuardianNullableScalarRelationFilter, GuardianWhereInput> | null
    verifications?: VerificationListRelationFilter
    school?: XOR<SchoolNullableScalarRelationFilter, SchoolWhereInput> | null
    schoolAndPlatformLegalAgreement?: XOR<SchoolAndPlatformLegalAgreementNullableScalarRelationFilter, SchoolAndPlatformLegalAgreementWhereInput> | null
    notifications?: NotificationListRelationFilter
    credential?: XOR<CredentialNullableScalarRelationFilter, CredentialWhereInput> | null
    wallet?: XOR<WalletNullableScalarRelationFilter, WalletWhereInput> | null
    refreshTokens?: RefreshTokenListRelationFilter
    firebaseToken?: XOR<FirebaseTokenNullableScalarRelationFilter, FirebaseTokenWhereInput> | null
    kycverification?: XOR<KYCVerificationNullableScalarRelationFilter, KYCVerificationWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    email?: SortOrder
    type?: SortOrder
    phone?: SortOrderInput | SortOrder
    accountStatus?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    lastSeenAt?: SortOrderInput | SortOrder
    isTermsAccepted?: SortOrder
    isPrivacyAccepted?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    administrator?: AdministratorOrderByWithRelationInput
    guardian?: GuardianOrderByWithRelationInput
    verifications?: VerificationOrderByRelationAggregateInput
    school?: SchoolOrderByWithRelationInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
    credential?: CredentialOrderByWithRelationInput
    wallet?: WalletOrderByWithRelationInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    firebaseToken?: FirebaseTokenOrderByWithRelationInput
    kycverification?: KYCVerificationOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    profileImage?: StringNullableFilter<"User"> | string | null
    type?: EnumUserTypeFilter<"User"> | $Enums.UserType
    phone?: StringNullableFilter<"User"> | string | null
    accountStatus?: EnumAccountStatusFilter<"User"> | $Enums.AccountStatus
    verifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastSeenAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isTermsAccepted?: BoolFilter<"User"> | boolean
    isPrivacyAccepted?: BoolFilter<"User"> | boolean
    isDeleted?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    administrator?: XOR<AdministratorNullableScalarRelationFilter, AdministratorWhereInput> | null
    guardian?: XOR<GuardianNullableScalarRelationFilter, GuardianWhereInput> | null
    verifications?: VerificationListRelationFilter
    school?: XOR<SchoolNullableScalarRelationFilter, SchoolWhereInput> | null
    schoolAndPlatformLegalAgreement?: XOR<SchoolAndPlatformLegalAgreementNullableScalarRelationFilter, SchoolAndPlatformLegalAgreementWhereInput> | null
    notifications?: NotificationListRelationFilter
    credential?: XOR<CredentialNullableScalarRelationFilter, CredentialWhereInput> | null
    wallet?: XOR<WalletNullableScalarRelationFilter, WalletWhereInput> | null
    refreshTokens?: RefreshTokenListRelationFilter
    firebaseToken?: XOR<FirebaseTokenNullableScalarRelationFilter, FirebaseTokenWhereInput> | null
    kycverification?: XOR<KYCVerificationNullableScalarRelationFilter, KYCVerificationWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    email?: SortOrder
    type?: SortOrder
    phone?: SortOrderInput | SortOrder
    accountStatus?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    lastSeenAt?: SortOrderInput | SortOrder
    isTermsAccepted?: SortOrder
    isPrivacyAccepted?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    profileImage?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    type?: EnumUserTypeWithAggregatesFilter<"User"> | $Enums.UserType
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    accountStatus?: EnumAccountStatusWithAggregatesFilter<"User"> | $Enums.AccountStatus
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastSeenAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isTermsAccepted?: BoolWithAggregatesFilter<"User"> | boolean
    isPrivacyAccepted?: BoolWithAggregatesFilter<"User"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CredentialWhereInput = {
    AND?: CredentialWhereInput | CredentialWhereInput[]
    OR?: CredentialWhereInput[]
    NOT?: CredentialWhereInput | CredentialWhereInput[]
    id?: StringFilter<"Credential"> | string
    userId?: StringFilter<"Credential"> | string
    password?: StringNullableFilter<"Credential"> | string | null
    pinCode?: StringNullableFilter<"Credential"> | string | null
    lastResetAt?: DateTimeNullableFilter<"Credential"> | Date | string | null
    lastUsedAt?: DateTimeNullableFilter<"Credential"> | Date | string | null
    isDeleted?: BoolFilter<"Credential"> | boolean
    createdAt?: DateTimeFilter<"Credential"> | Date | string
    updatedAt?: DateTimeFilter<"Credential"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CredentialOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    password?: SortOrderInput | SortOrder
    pinCode?: SortOrderInput | SortOrder
    lastResetAt?: SortOrderInput | SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CredentialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: CredentialWhereInput | CredentialWhereInput[]
    OR?: CredentialWhereInput[]
    NOT?: CredentialWhereInput | CredentialWhereInput[]
    password?: StringNullableFilter<"Credential"> | string | null
    pinCode?: StringNullableFilter<"Credential"> | string | null
    lastResetAt?: DateTimeNullableFilter<"Credential"> | Date | string | null
    lastUsedAt?: DateTimeNullableFilter<"Credential"> | Date | string | null
    isDeleted?: BoolFilter<"Credential"> | boolean
    createdAt?: DateTimeFilter<"Credential"> | Date | string
    updatedAt?: DateTimeFilter<"Credential"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type CredentialOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    password?: SortOrderInput | SortOrder
    pinCode?: SortOrderInput | SortOrder
    lastResetAt?: SortOrderInput | SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CredentialCountOrderByAggregateInput
    _max?: CredentialMaxOrderByAggregateInput
    _min?: CredentialMinOrderByAggregateInput
  }

  export type CredentialScalarWhereWithAggregatesInput = {
    AND?: CredentialScalarWhereWithAggregatesInput | CredentialScalarWhereWithAggregatesInput[]
    OR?: CredentialScalarWhereWithAggregatesInput[]
    NOT?: CredentialScalarWhereWithAggregatesInput | CredentialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Credential"> | string
    userId?: StringWithAggregatesFilter<"Credential"> | string
    password?: StringNullableWithAggregatesFilter<"Credential"> | string | null
    pinCode?: StringNullableWithAggregatesFilter<"Credential"> | string | null
    lastResetAt?: DateTimeNullableWithAggregatesFilter<"Credential"> | Date | string | null
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"Credential"> | Date | string | null
    isDeleted?: BoolWithAggregatesFilter<"Credential"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Credential"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Credential"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revoked?: BoolFilter<"RefreshToken"> | boolean
    isDeleted?: BoolFilter<"RefreshToken"> | boolean
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revoked?: BoolFilter<"RefreshToken"> | boolean
    isDeleted?: BoolFilter<"RefreshToken"> | boolean
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    revoked?: BoolWithAggregatesFilter<"RefreshToken"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"RefreshToken"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type AdministratorWhereInput = {
    AND?: AdministratorWhereInput | AdministratorWhereInput[]
    OR?: AdministratorWhereInput[]
    NOT?: AdministratorWhereInput | AdministratorWhereInput[]
    id?: StringFilter<"Administrator"> | string
    userId?: StringFilter<"Administrator"> | string
    isDeleted?: BoolFilter<"Administrator"> | boolean
    createdAt?: DateTimeFilter<"Administrator"> | Date | string
    updatedAt?: DateTimeFilter<"Administrator"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AdministratorOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AdministratorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AdministratorWhereInput | AdministratorWhereInput[]
    OR?: AdministratorWhereInput[]
    NOT?: AdministratorWhereInput | AdministratorWhereInput[]
    isDeleted?: BoolFilter<"Administrator"> | boolean
    createdAt?: DateTimeFilter<"Administrator"> | Date | string
    updatedAt?: DateTimeFilter<"Administrator"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type AdministratorOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdministratorCountOrderByAggregateInput
    _max?: AdministratorMaxOrderByAggregateInput
    _min?: AdministratorMinOrderByAggregateInput
  }

  export type AdministratorScalarWhereWithAggregatesInput = {
    AND?: AdministratorScalarWhereWithAggregatesInput | AdministratorScalarWhereWithAggregatesInput[]
    OR?: AdministratorScalarWhereWithAggregatesInput[]
    NOT?: AdministratorScalarWhereWithAggregatesInput | AdministratorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Administrator"> | string
    userId?: StringWithAggregatesFilter<"Administrator"> | string
    isDeleted?: BoolWithAggregatesFilter<"Administrator"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Administrator"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Administrator"> | Date | string
  }

  export type GuardianWhereInput = {
    AND?: GuardianWhereInput | GuardianWhereInput[]
    OR?: GuardianWhereInput[]
    NOT?: GuardianWhereInput | GuardianWhereInput[]
    id?: StringFilter<"Guardian"> | string
    userId?: StringFilter<"Guardian"> | string
    address?: StringNullableFilter<"Guardian"> | string | null
    city?: StringNullableFilter<"Guardian"> | string | null
    state?: StringNullableFilter<"Guardian"> | string | null
    country?: StringNullableFilter<"Guardian"> | string | null
    postalCode?: StringNullableFilter<"Guardian"> | string | null
    isDeleted?: BoolFilter<"Guardian"> | boolean
    createdAt?: DateTimeFilter<"Guardian"> | Date | string
    updatedAt?: DateTimeFilter<"Guardian"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    invoices?: InvoiceListRelationFilter
    students?: StudentListRelationFilter
    linkedStudentProfiles?: LinkedStudentProfileListRelationFilter
    transactions?: TransactionListRelationFilter
  }

  export type GuardianOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    invoices?: InvoiceOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
    linkedStudentProfiles?: LinkedStudentProfileOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type GuardianWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: GuardianWhereInput | GuardianWhereInput[]
    OR?: GuardianWhereInput[]
    NOT?: GuardianWhereInput | GuardianWhereInput[]
    address?: StringNullableFilter<"Guardian"> | string | null
    city?: StringNullableFilter<"Guardian"> | string | null
    state?: StringNullableFilter<"Guardian"> | string | null
    country?: StringNullableFilter<"Guardian"> | string | null
    postalCode?: StringNullableFilter<"Guardian"> | string | null
    isDeleted?: BoolFilter<"Guardian"> | boolean
    createdAt?: DateTimeFilter<"Guardian"> | Date | string
    updatedAt?: DateTimeFilter<"Guardian"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    invoices?: InvoiceListRelationFilter
    students?: StudentListRelationFilter
    linkedStudentProfiles?: LinkedStudentProfileListRelationFilter
    transactions?: TransactionListRelationFilter
  }, "id" | "userId">

  export type GuardianOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GuardianCountOrderByAggregateInput
    _max?: GuardianMaxOrderByAggregateInput
    _min?: GuardianMinOrderByAggregateInput
  }

  export type GuardianScalarWhereWithAggregatesInput = {
    AND?: GuardianScalarWhereWithAggregatesInput | GuardianScalarWhereWithAggregatesInput[]
    OR?: GuardianScalarWhereWithAggregatesInput[]
    NOT?: GuardianScalarWhereWithAggregatesInput | GuardianScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Guardian"> | string
    userId?: StringWithAggregatesFilter<"Guardian"> | string
    address?: StringNullableWithAggregatesFilter<"Guardian"> | string | null
    city?: StringNullableWithAggregatesFilter<"Guardian"> | string | null
    state?: StringNullableWithAggregatesFilter<"Guardian"> | string | null
    country?: StringNullableWithAggregatesFilter<"Guardian"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"Guardian"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Guardian"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Guardian"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Guardian"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    userId?: StringFilter<"Verification"> | string
    type?: EnumVerificationTypeFilter<"Verification"> | $Enums.VerificationType
    code?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    resendCount?: IntFilter<"Verification"> | number
    used?: BoolFilter<"Verification"> | boolean
    isDeleted?: BoolFilter<"Verification"> | boolean
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    resendCount?: SortOrder
    used?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    userId?: StringFilter<"Verification"> | string
    type?: EnumVerificationTypeFilter<"Verification"> | $Enums.VerificationType
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    resendCount?: IntFilter<"Verification"> | number
    used?: BoolFilter<"Verification"> | boolean
    isDeleted?: BoolFilter<"Verification"> | boolean
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "code">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    resendCount?: SortOrder
    used?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _avg?: VerificationAvgOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
    _sum?: VerificationSumOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    userId?: StringWithAggregatesFilter<"Verification"> | string
    type?: EnumVerificationTypeWithAggregatesFilter<"Verification"> | $Enums.VerificationType
    code?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    resendCount?: IntWithAggregatesFilter<"Verification"> | number
    used?: BoolWithAggregatesFilter<"Verification"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"Verification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
  }

  export type SchoolWhereInput = {
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    id?: StringFilter<"School"> | string
    ownerId?: StringFilter<"School"> | string
    name?: StringFilter<"School"> | string
    address?: StringNullableFilter<"School"> | string | null
    city?: StringNullableFilter<"School"> | string | null
    state?: StringNullableFilter<"School"> | string | null
    country?: StringNullableFilter<"School"> | string | null
    lga?: StringNullableFilter<"School"> | string | null
    postalCode?: StringNullableFilter<"School"> | string | null
    email?: StringFilter<"School"> | string
    phoneNumber?: StringNullableFilter<"School"> | string | null
    establishedYear?: IntNullableFilter<"School"> | number | null
    website?: StringNullableFilter<"School"> | string | null
    logo?: StringNullableFilter<"School"> | string | null
    schoolType?: EnumSchoolTypeFilter<"School"> | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFilter<"School"> | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFilter<"School"> | $Enums.SchoolStatus
    isDeleted?: BoolFilter<"School"> | boolean
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    schoolDirectorVerification?: XOR<SchoolDirectorVerificationNullableScalarRelationFilter, SchoolDirectorVerificationWhereInput> | null
    schoolOwnershipVerification?: XOR<SchoolOwnershipVerificationNullableScalarRelationFilter, SchoolOwnershipVerificationWhereInput> | null
    schoolVerification?: XOR<SchoolVerificationNullableScalarRelationFilter, SchoolVerificationWhereInput> | null
    schoolPayoutDetail?: XOR<SchoolPayoutDetailNullableScalarRelationFilter, SchoolPayoutDetailWhereInput> | null
    schoolAndPlatformLegalAgreement?: XOR<SchoolAndPlatformLegalAgreementNullableScalarRelationFilter, SchoolAndPlatformLegalAgreementWhereInput> | null
    classes?: ClassListRelationFilter
    academicSessions?: AcademicSessionListRelationFilter
    terms?: TermListRelationFilter
    fees?: FeesListRelationFilter
    payouts?: PayoutListRelationFilter
    kycverification?: XOR<KYCVerificationNullableScalarRelationFilter, KYCVerificationWhereInput> | null
  }

  export type SchoolOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    lga?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    email?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    establishedYear?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    schoolType?: SortOrder
    ownership?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    schoolDirectorVerification?: SchoolDirectorVerificationOrderByWithRelationInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationOrderByWithRelationInput
    schoolVerification?: SchoolVerificationOrderByWithRelationInput
    schoolPayoutDetail?: SchoolPayoutDetailOrderByWithRelationInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementOrderByWithRelationInput
    classes?: ClassOrderByRelationAggregateInput
    academicSessions?: AcademicSessionOrderByRelationAggregateInput
    terms?: TermOrderByRelationAggregateInput
    fees?: FeesOrderByRelationAggregateInput
    payouts?: PayoutOrderByRelationAggregateInput
    kycverification?: KYCVerificationOrderByWithRelationInput
  }

  export type SchoolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ownerId?: string
    email?: string
    AND?: SchoolWhereInput | SchoolWhereInput[]
    OR?: SchoolWhereInput[]
    NOT?: SchoolWhereInput | SchoolWhereInput[]
    name?: StringFilter<"School"> | string
    address?: StringNullableFilter<"School"> | string | null
    city?: StringNullableFilter<"School"> | string | null
    state?: StringNullableFilter<"School"> | string | null
    country?: StringNullableFilter<"School"> | string | null
    lga?: StringNullableFilter<"School"> | string | null
    postalCode?: StringNullableFilter<"School"> | string | null
    phoneNumber?: StringNullableFilter<"School"> | string | null
    establishedYear?: IntNullableFilter<"School"> | number | null
    website?: StringNullableFilter<"School"> | string | null
    logo?: StringNullableFilter<"School"> | string | null
    schoolType?: EnumSchoolTypeFilter<"School"> | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFilter<"School"> | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFilter<"School"> | $Enums.SchoolStatus
    isDeleted?: BoolFilter<"School"> | boolean
    createdAt?: DateTimeFilter<"School"> | Date | string
    updatedAt?: DateTimeFilter<"School"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    schoolDirectorVerification?: XOR<SchoolDirectorVerificationNullableScalarRelationFilter, SchoolDirectorVerificationWhereInput> | null
    schoolOwnershipVerification?: XOR<SchoolOwnershipVerificationNullableScalarRelationFilter, SchoolOwnershipVerificationWhereInput> | null
    schoolVerification?: XOR<SchoolVerificationNullableScalarRelationFilter, SchoolVerificationWhereInput> | null
    schoolPayoutDetail?: XOR<SchoolPayoutDetailNullableScalarRelationFilter, SchoolPayoutDetailWhereInput> | null
    schoolAndPlatformLegalAgreement?: XOR<SchoolAndPlatformLegalAgreementNullableScalarRelationFilter, SchoolAndPlatformLegalAgreementWhereInput> | null
    classes?: ClassListRelationFilter
    academicSessions?: AcademicSessionListRelationFilter
    terms?: TermListRelationFilter
    fees?: FeesListRelationFilter
    payouts?: PayoutListRelationFilter
    kycverification?: XOR<KYCVerificationNullableScalarRelationFilter, KYCVerificationWhereInput> | null
  }, "id" | "ownerId" | "email">

  export type SchoolOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    lga?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    email?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    establishedYear?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    schoolType?: SortOrder
    ownership?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolCountOrderByAggregateInput
    _avg?: SchoolAvgOrderByAggregateInput
    _max?: SchoolMaxOrderByAggregateInput
    _min?: SchoolMinOrderByAggregateInput
    _sum?: SchoolSumOrderByAggregateInput
  }

  export type SchoolScalarWhereWithAggregatesInput = {
    AND?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    OR?: SchoolScalarWhereWithAggregatesInput[]
    NOT?: SchoolScalarWhereWithAggregatesInput | SchoolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"School"> | string
    ownerId?: StringWithAggregatesFilter<"School"> | string
    name?: StringWithAggregatesFilter<"School"> | string
    address?: StringNullableWithAggregatesFilter<"School"> | string | null
    city?: StringNullableWithAggregatesFilter<"School"> | string | null
    state?: StringNullableWithAggregatesFilter<"School"> | string | null
    country?: StringNullableWithAggregatesFilter<"School"> | string | null
    lga?: StringNullableWithAggregatesFilter<"School"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"School"> | string | null
    email?: StringWithAggregatesFilter<"School"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"School"> | string | null
    establishedYear?: IntNullableWithAggregatesFilter<"School"> | number | null
    website?: StringNullableWithAggregatesFilter<"School"> | string | null
    logo?: StringNullableWithAggregatesFilter<"School"> | string | null
    schoolType?: EnumSchoolTypeWithAggregatesFilter<"School"> | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipWithAggregatesFilter<"School"> | $Enums.SchoolOwnership
    status?: EnumSchoolStatusWithAggregatesFilter<"School"> | $Enums.SchoolStatus
    isDeleted?: BoolWithAggregatesFilter<"School"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"School"> | Date | string
  }

  export type SchoolDirectorVerificationWhereInput = {
    AND?: SchoolDirectorVerificationWhereInput | SchoolDirectorVerificationWhereInput[]
    OR?: SchoolDirectorVerificationWhereInput[]
    NOT?: SchoolDirectorVerificationWhereInput | SchoolDirectorVerificationWhereInput[]
    id?: StringFilter<"SchoolDirectorVerification"> | string
    schoolId?: StringFilter<"SchoolDirectorVerification"> | string
    directorFullName?: StringFilter<"SchoolDirectorVerification"> | string
    directorIDType?: EnumDirectorIDTypeFilter<"SchoolDirectorVerification"> | $Enums.DirectorIDType
    directorIDNumber?: StringFilter<"SchoolDirectorVerification"> | string
    document?: StringFilter<"SchoolDirectorVerification"> | string
    isDeleted?: BoolFilter<"SchoolDirectorVerification"> | boolean
    createdAt?: DateTimeFilter<"SchoolDirectorVerification"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolDirectorVerification"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
  }

  export type SchoolDirectorVerificationOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    directorFullName?: SortOrder
    directorIDType?: SortOrder
    directorIDNumber?: SortOrder
    document?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type SchoolDirectorVerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId?: string
    AND?: SchoolDirectorVerificationWhereInput | SchoolDirectorVerificationWhereInput[]
    OR?: SchoolDirectorVerificationWhereInput[]
    NOT?: SchoolDirectorVerificationWhereInput | SchoolDirectorVerificationWhereInput[]
    directorFullName?: StringFilter<"SchoolDirectorVerification"> | string
    directorIDType?: EnumDirectorIDTypeFilter<"SchoolDirectorVerification"> | $Enums.DirectorIDType
    directorIDNumber?: StringFilter<"SchoolDirectorVerification"> | string
    document?: StringFilter<"SchoolDirectorVerification"> | string
    isDeleted?: BoolFilter<"SchoolDirectorVerification"> | boolean
    createdAt?: DateTimeFilter<"SchoolDirectorVerification"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolDirectorVerification"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
  }, "id" | "schoolId">

  export type SchoolDirectorVerificationOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    directorFullName?: SortOrder
    directorIDType?: SortOrder
    directorIDNumber?: SortOrder
    document?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolDirectorVerificationCountOrderByAggregateInput
    _max?: SchoolDirectorVerificationMaxOrderByAggregateInput
    _min?: SchoolDirectorVerificationMinOrderByAggregateInput
  }

  export type SchoolDirectorVerificationScalarWhereWithAggregatesInput = {
    AND?: SchoolDirectorVerificationScalarWhereWithAggregatesInput | SchoolDirectorVerificationScalarWhereWithAggregatesInput[]
    OR?: SchoolDirectorVerificationScalarWhereWithAggregatesInput[]
    NOT?: SchoolDirectorVerificationScalarWhereWithAggregatesInput | SchoolDirectorVerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SchoolDirectorVerification"> | string
    schoolId?: StringWithAggregatesFilter<"SchoolDirectorVerification"> | string
    directorFullName?: StringWithAggregatesFilter<"SchoolDirectorVerification"> | string
    directorIDType?: EnumDirectorIDTypeWithAggregatesFilter<"SchoolDirectorVerification"> | $Enums.DirectorIDType
    directorIDNumber?: StringWithAggregatesFilter<"SchoolDirectorVerification"> | string
    document?: StringWithAggregatesFilter<"SchoolDirectorVerification"> | string
    isDeleted?: BoolWithAggregatesFilter<"SchoolDirectorVerification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SchoolDirectorVerification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SchoolDirectorVerification"> | Date | string
  }

  export type SchoolOwnershipVerificationWhereInput = {
    AND?: SchoolOwnershipVerificationWhereInput | SchoolOwnershipVerificationWhereInput[]
    OR?: SchoolOwnershipVerificationWhereInput[]
    NOT?: SchoolOwnershipVerificationWhereInput | SchoolOwnershipVerificationWhereInput[]
    id?: StringFilter<"SchoolOwnershipVerification"> | string
    schoolId?: StringFilter<"SchoolOwnershipVerification"> | string
    cacform7?: StringFilter<"SchoolOwnershipVerification"> | string
    cacShareAllotmentForm?: StringFilter<"SchoolOwnershipVerification"> | string
    isDeleted?: BoolFilter<"SchoolOwnershipVerification"> | boolean
    createdAt?: DateTimeFilter<"SchoolOwnershipVerification"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolOwnershipVerification"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
  }

  export type SchoolOwnershipVerificationOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    cacform7?: SortOrder
    cacShareAllotmentForm?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type SchoolOwnershipVerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId?: string
    AND?: SchoolOwnershipVerificationWhereInput | SchoolOwnershipVerificationWhereInput[]
    OR?: SchoolOwnershipVerificationWhereInput[]
    NOT?: SchoolOwnershipVerificationWhereInput | SchoolOwnershipVerificationWhereInput[]
    cacform7?: StringFilter<"SchoolOwnershipVerification"> | string
    cacShareAllotmentForm?: StringFilter<"SchoolOwnershipVerification"> | string
    isDeleted?: BoolFilter<"SchoolOwnershipVerification"> | boolean
    createdAt?: DateTimeFilter<"SchoolOwnershipVerification"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolOwnershipVerification"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
  }, "id" | "schoolId">

  export type SchoolOwnershipVerificationOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    cacform7?: SortOrder
    cacShareAllotmentForm?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolOwnershipVerificationCountOrderByAggregateInput
    _max?: SchoolOwnershipVerificationMaxOrderByAggregateInput
    _min?: SchoolOwnershipVerificationMinOrderByAggregateInput
  }

  export type SchoolOwnershipVerificationScalarWhereWithAggregatesInput = {
    AND?: SchoolOwnershipVerificationScalarWhereWithAggregatesInput | SchoolOwnershipVerificationScalarWhereWithAggregatesInput[]
    OR?: SchoolOwnershipVerificationScalarWhereWithAggregatesInput[]
    NOT?: SchoolOwnershipVerificationScalarWhereWithAggregatesInput | SchoolOwnershipVerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SchoolOwnershipVerification"> | string
    schoolId?: StringWithAggregatesFilter<"SchoolOwnershipVerification"> | string
    cacform7?: StringWithAggregatesFilter<"SchoolOwnershipVerification"> | string
    cacShareAllotmentForm?: StringWithAggregatesFilter<"SchoolOwnershipVerification"> | string
    isDeleted?: BoolWithAggregatesFilter<"SchoolOwnershipVerification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SchoolOwnershipVerification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SchoolOwnershipVerification"> | Date | string
  }

  export type SchoolVerificationWhereInput = {
    AND?: SchoolVerificationWhereInput | SchoolVerificationWhereInput[]
    OR?: SchoolVerificationWhereInput[]
    NOT?: SchoolVerificationWhereInput | SchoolVerificationWhereInput[]
    id?: StringFilter<"SchoolVerification"> | string
    schoolId?: StringFilter<"SchoolVerification"> | string
    cacCertificate?: StringFilter<"SchoolVerification"> | string
    accreditationDocument?: StringFilter<"SchoolVerification"> | string
    taxIdentificationNumber?: StringFilter<"SchoolVerification"> | string
    licenseDocument?: StringFilter<"SchoolVerification"> | string
    isDeleted?: BoolFilter<"SchoolVerification"> | boolean
    createdAt?: DateTimeFilter<"SchoolVerification"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolVerification"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
  }

  export type SchoolVerificationOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    cacCertificate?: SortOrder
    accreditationDocument?: SortOrder
    taxIdentificationNumber?: SortOrder
    licenseDocument?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type SchoolVerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId?: string
    AND?: SchoolVerificationWhereInput | SchoolVerificationWhereInput[]
    OR?: SchoolVerificationWhereInput[]
    NOT?: SchoolVerificationWhereInput | SchoolVerificationWhereInput[]
    cacCertificate?: StringFilter<"SchoolVerification"> | string
    accreditationDocument?: StringFilter<"SchoolVerification"> | string
    taxIdentificationNumber?: StringFilter<"SchoolVerification"> | string
    licenseDocument?: StringFilter<"SchoolVerification"> | string
    isDeleted?: BoolFilter<"SchoolVerification"> | boolean
    createdAt?: DateTimeFilter<"SchoolVerification"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolVerification"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
  }, "id" | "schoolId">

  export type SchoolVerificationOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    cacCertificate?: SortOrder
    accreditationDocument?: SortOrder
    taxIdentificationNumber?: SortOrder
    licenseDocument?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolVerificationCountOrderByAggregateInput
    _max?: SchoolVerificationMaxOrderByAggregateInput
    _min?: SchoolVerificationMinOrderByAggregateInput
  }

  export type SchoolVerificationScalarWhereWithAggregatesInput = {
    AND?: SchoolVerificationScalarWhereWithAggregatesInput | SchoolVerificationScalarWhereWithAggregatesInput[]
    OR?: SchoolVerificationScalarWhereWithAggregatesInput[]
    NOT?: SchoolVerificationScalarWhereWithAggregatesInput | SchoolVerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SchoolVerification"> | string
    schoolId?: StringWithAggregatesFilter<"SchoolVerification"> | string
    cacCertificate?: StringWithAggregatesFilter<"SchoolVerification"> | string
    accreditationDocument?: StringWithAggregatesFilter<"SchoolVerification"> | string
    taxIdentificationNumber?: StringWithAggregatesFilter<"SchoolVerification"> | string
    licenseDocument?: StringWithAggregatesFilter<"SchoolVerification"> | string
    isDeleted?: BoolWithAggregatesFilter<"SchoolVerification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SchoolVerification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SchoolVerification"> | Date | string
  }

  export type SchoolPayoutDetailWhereInput = {
    AND?: SchoolPayoutDetailWhereInput | SchoolPayoutDetailWhereInput[]
    OR?: SchoolPayoutDetailWhereInput[]
    NOT?: SchoolPayoutDetailWhereInput | SchoolPayoutDetailWhereInput[]
    id?: StringFilter<"SchoolPayoutDetail"> | string
    schoolId?: StringFilter<"SchoolPayoutDetail"> | string
    bankName?: StringFilter<"SchoolPayoutDetail"> | string
    bankCode?: StringFilter<"SchoolPayoutDetail"> | string
    accountNumber?: StringFilter<"SchoolPayoutDetail"> | string
    accountName?: StringFilter<"SchoolPayoutDetail"> | string
    isDeleted?: BoolFilter<"SchoolPayoutDetail"> | boolean
    createdAt?: DateTimeFilter<"SchoolPayoutDetail"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolPayoutDetail"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
  }

  export type SchoolPayoutDetailOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    bankName?: SortOrder
    bankCode?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type SchoolPayoutDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId?: string
    AND?: SchoolPayoutDetailWhereInput | SchoolPayoutDetailWhereInput[]
    OR?: SchoolPayoutDetailWhereInput[]
    NOT?: SchoolPayoutDetailWhereInput | SchoolPayoutDetailWhereInput[]
    bankName?: StringFilter<"SchoolPayoutDetail"> | string
    bankCode?: StringFilter<"SchoolPayoutDetail"> | string
    accountNumber?: StringFilter<"SchoolPayoutDetail"> | string
    accountName?: StringFilter<"SchoolPayoutDetail"> | string
    isDeleted?: BoolFilter<"SchoolPayoutDetail"> | boolean
    createdAt?: DateTimeFilter<"SchoolPayoutDetail"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolPayoutDetail"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
  }, "id" | "schoolId">

  export type SchoolPayoutDetailOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    bankName?: SortOrder
    bankCode?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolPayoutDetailCountOrderByAggregateInput
    _max?: SchoolPayoutDetailMaxOrderByAggregateInput
    _min?: SchoolPayoutDetailMinOrderByAggregateInput
  }

  export type SchoolPayoutDetailScalarWhereWithAggregatesInput = {
    AND?: SchoolPayoutDetailScalarWhereWithAggregatesInput | SchoolPayoutDetailScalarWhereWithAggregatesInput[]
    OR?: SchoolPayoutDetailScalarWhereWithAggregatesInput[]
    NOT?: SchoolPayoutDetailScalarWhereWithAggregatesInput | SchoolPayoutDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SchoolPayoutDetail"> | string
    schoolId?: StringWithAggregatesFilter<"SchoolPayoutDetail"> | string
    bankName?: StringWithAggregatesFilter<"SchoolPayoutDetail"> | string
    bankCode?: StringWithAggregatesFilter<"SchoolPayoutDetail"> | string
    accountNumber?: StringWithAggregatesFilter<"SchoolPayoutDetail"> | string
    accountName?: StringWithAggregatesFilter<"SchoolPayoutDetail"> | string
    isDeleted?: BoolWithAggregatesFilter<"SchoolPayoutDetail"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SchoolPayoutDetail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SchoolPayoutDetail"> | Date | string
  }

  export type SchoolAndPlatformLegalAgreementWhereInput = {
    AND?: SchoolAndPlatformLegalAgreementWhereInput | SchoolAndPlatformLegalAgreementWhereInput[]
    OR?: SchoolAndPlatformLegalAgreementWhereInput[]
    NOT?: SchoolAndPlatformLegalAgreementWhereInput | SchoolAndPlatformLegalAgreementWhereInput[]
    id?: StringFilter<"SchoolAndPlatformLegalAgreement"> | string
    schoolId?: StringFilter<"SchoolAndPlatformLegalAgreement"> | string
    signedById?: StringFilter<"SchoolAndPlatformLegalAgreement"> | string
    signature?: StringFilter<"SchoolAndPlatformLegalAgreement"> | string
    signedAt?: DateTimeFilter<"SchoolAndPlatformLegalAgreement"> | Date | string
    legalDocumentRef?: StringFilter<"SchoolAndPlatformLegalAgreement"> | string
    isDeleted?: BoolFilter<"SchoolAndPlatformLegalAgreement"> | boolean
    createdAt?: DateTimeFilter<"SchoolAndPlatformLegalAgreement"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolAndPlatformLegalAgreement"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    signedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SchoolAndPlatformLegalAgreementOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    signedById?: SortOrder
    signature?: SortOrder
    signedAt?: SortOrder
    legalDocumentRef?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    signedBy?: UserOrderByWithRelationInput
  }

  export type SchoolAndPlatformLegalAgreementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schoolId?: string
    signedById?: string
    AND?: SchoolAndPlatformLegalAgreementWhereInput | SchoolAndPlatformLegalAgreementWhereInput[]
    OR?: SchoolAndPlatformLegalAgreementWhereInput[]
    NOT?: SchoolAndPlatformLegalAgreementWhereInput | SchoolAndPlatformLegalAgreementWhereInput[]
    signature?: StringFilter<"SchoolAndPlatformLegalAgreement"> | string
    signedAt?: DateTimeFilter<"SchoolAndPlatformLegalAgreement"> | Date | string
    legalDocumentRef?: StringFilter<"SchoolAndPlatformLegalAgreement"> | string
    isDeleted?: BoolFilter<"SchoolAndPlatformLegalAgreement"> | boolean
    createdAt?: DateTimeFilter<"SchoolAndPlatformLegalAgreement"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolAndPlatformLegalAgreement"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    signedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "schoolId" | "signedById">

  export type SchoolAndPlatformLegalAgreementOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    signedById?: SortOrder
    signature?: SortOrder
    signedAt?: SortOrder
    legalDocumentRef?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolAndPlatformLegalAgreementCountOrderByAggregateInput
    _max?: SchoolAndPlatformLegalAgreementMaxOrderByAggregateInput
    _min?: SchoolAndPlatformLegalAgreementMinOrderByAggregateInput
  }

  export type SchoolAndPlatformLegalAgreementScalarWhereWithAggregatesInput = {
    AND?: SchoolAndPlatformLegalAgreementScalarWhereWithAggregatesInput | SchoolAndPlatformLegalAgreementScalarWhereWithAggregatesInput[]
    OR?: SchoolAndPlatformLegalAgreementScalarWhereWithAggregatesInput[]
    NOT?: SchoolAndPlatformLegalAgreementScalarWhereWithAggregatesInput | SchoolAndPlatformLegalAgreementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SchoolAndPlatformLegalAgreement"> | string
    schoolId?: StringWithAggregatesFilter<"SchoolAndPlatformLegalAgreement"> | string
    signedById?: StringWithAggregatesFilter<"SchoolAndPlatformLegalAgreement"> | string
    signature?: StringWithAggregatesFilter<"SchoolAndPlatformLegalAgreement"> | string
    signedAt?: DateTimeWithAggregatesFilter<"SchoolAndPlatformLegalAgreement"> | Date | string
    legalDocumentRef?: StringWithAggregatesFilter<"SchoolAndPlatformLegalAgreement"> | string
    isDeleted?: BoolWithAggregatesFilter<"SchoolAndPlatformLegalAgreement"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SchoolAndPlatformLegalAgreement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SchoolAndPlatformLegalAgreement"> | Date | string
  }

  export type KYCVerificationWhereInput = {
    AND?: KYCVerificationWhereInput | KYCVerificationWhereInput[]
    OR?: KYCVerificationWhereInput[]
    NOT?: KYCVerificationWhereInput | KYCVerificationWhereInput[]
    id?: StringFilter<"KYCVerification"> | string
    userId?: StringFilter<"KYCVerification"> | string
    schoolId?: StringFilter<"KYCVerification"> | string
    status?: EnumKYCVerificationStatusFilter<"KYCVerification"> | $Enums.KYCVerificationStatus
    isDeleted?: BoolFilter<"KYCVerification"> | boolean
    createdAt?: DateTimeFilter<"KYCVerification"> | Date | string
    updatedAt?: DateTimeFilter<"KYCVerification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
  }

  export type KYCVerificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    schoolId?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
  }

  export type KYCVerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    schoolId?: string
    AND?: KYCVerificationWhereInput | KYCVerificationWhereInput[]
    OR?: KYCVerificationWhereInput[]
    NOT?: KYCVerificationWhereInput | KYCVerificationWhereInput[]
    status?: EnumKYCVerificationStatusFilter<"KYCVerification"> | $Enums.KYCVerificationStatus
    isDeleted?: BoolFilter<"KYCVerification"> | boolean
    createdAt?: DateTimeFilter<"KYCVerification"> | Date | string
    updatedAt?: DateTimeFilter<"KYCVerification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
  }, "id" | "userId" | "schoolId">

  export type KYCVerificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    schoolId?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KYCVerificationCountOrderByAggregateInput
    _max?: KYCVerificationMaxOrderByAggregateInput
    _min?: KYCVerificationMinOrderByAggregateInput
  }

  export type KYCVerificationScalarWhereWithAggregatesInput = {
    AND?: KYCVerificationScalarWhereWithAggregatesInput | KYCVerificationScalarWhereWithAggregatesInput[]
    OR?: KYCVerificationScalarWhereWithAggregatesInput[]
    NOT?: KYCVerificationScalarWhereWithAggregatesInput | KYCVerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KYCVerification"> | string
    userId?: StringWithAggregatesFilter<"KYCVerification"> | string
    schoolId?: StringWithAggregatesFilter<"KYCVerification"> | string
    status?: EnumKYCVerificationStatusWithAggregatesFilter<"KYCVerification"> | $Enums.KYCVerificationStatus
    isDeleted?: BoolWithAggregatesFilter<"KYCVerification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"KYCVerification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KYCVerification"> | Date | string
  }

  export type ClassWhereInput = {
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    id?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    schoolId?: StringFilter<"Class"> | string
    isDeleted?: BoolFilter<"Class"> | boolean
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    fees?: FeesListRelationFilter
    invoices?: InvoiceListRelationFilter
    students?: StudentListRelationFilter
  }

  export type ClassOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    fees?: FeesOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
  }

  export type ClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    name?: StringFilter<"Class"> | string
    schoolId?: StringFilter<"Class"> | string
    isDeleted?: BoolFilter<"Class"> | boolean
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    fees?: FeesListRelationFilter
    invoices?: InvoiceListRelationFilter
    students?: StudentListRelationFilter
  }, "id">

  export type ClassOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClassCountOrderByAggregateInput
    _max?: ClassMaxOrderByAggregateInput
    _min?: ClassMinOrderByAggregateInput
  }

  export type ClassScalarWhereWithAggregatesInput = {
    AND?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    OR?: ClassScalarWhereWithAggregatesInput[]
    NOT?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Class"> | string
    name?: StringWithAggregatesFilter<"Class"> | string
    schoolId?: StringWithAggregatesFilter<"Class"> | string
    isDeleted?: BoolWithAggregatesFilter<"Class"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
  }

  export type AcademicSessionWhereInput = {
    AND?: AcademicSessionWhereInput | AcademicSessionWhereInput[]
    OR?: AcademicSessionWhereInput[]
    NOT?: AcademicSessionWhereInput | AcademicSessionWhereInput[]
    id?: StringFilter<"AcademicSession"> | string
    name?: StringFilter<"AcademicSession"> | string
    schoolId?: StringFilter<"AcademicSession"> | string
    isDeleted?: BoolFilter<"AcademicSession"> | boolean
    createdAt?: DateTimeFilter<"AcademicSession"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicSession"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    fees?: FeesListRelationFilter
    invoices?: InvoiceListRelationFilter
  }

  export type AcademicSessionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    fees?: FeesOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
  }

  export type AcademicSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AcademicSessionWhereInput | AcademicSessionWhereInput[]
    OR?: AcademicSessionWhereInput[]
    NOT?: AcademicSessionWhereInput | AcademicSessionWhereInput[]
    name?: StringFilter<"AcademicSession"> | string
    schoolId?: StringFilter<"AcademicSession"> | string
    isDeleted?: BoolFilter<"AcademicSession"> | boolean
    createdAt?: DateTimeFilter<"AcademicSession"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicSession"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    fees?: FeesListRelationFilter
    invoices?: InvoiceListRelationFilter
  }, "id">

  export type AcademicSessionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AcademicSessionCountOrderByAggregateInput
    _max?: AcademicSessionMaxOrderByAggregateInput
    _min?: AcademicSessionMinOrderByAggregateInput
  }

  export type AcademicSessionScalarWhereWithAggregatesInput = {
    AND?: AcademicSessionScalarWhereWithAggregatesInput | AcademicSessionScalarWhereWithAggregatesInput[]
    OR?: AcademicSessionScalarWhereWithAggregatesInput[]
    NOT?: AcademicSessionScalarWhereWithAggregatesInput | AcademicSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AcademicSession"> | string
    name?: StringWithAggregatesFilter<"AcademicSession"> | string
    schoolId?: StringWithAggregatesFilter<"AcademicSession"> | string
    isDeleted?: BoolWithAggregatesFilter<"AcademicSession"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AcademicSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AcademicSession"> | Date | string
  }

  export type TermWhereInput = {
    AND?: TermWhereInput | TermWhereInput[]
    OR?: TermWhereInput[]
    NOT?: TermWhereInput | TermWhereInput[]
    id?: StringFilter<"Term"> | string
    name?: StringFilter<"Term"> | string
    schoolId?: StringFilter<"Term"> | string
    isDeleted?: BoolFilter<"Term"> | boolean
    createdAt?: DateTimeFilter<"Term"> | Date | string
    updatedAt?: DateTimeFilter<"Term"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    fees?: FeesListRelationFilter
    invoices?: InvoiceListRelationFilter
  }

  export type TermOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
    fees?: FeesOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
  }

  export type TermWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TermWhereInput | TermWhereInput[]
    OR?: TermWhereInput[]
    NOT?: TermWhereInput | TermWhereInput[]
    name?: StringFilter<"Term"> | string
    schoolId?: StringFilter<"Term"> | string
    isDeleted?: BoolFilter<"Term"> | boolean
    createdAt?: DateTimeFilter<"Term"> | Date | string
    updatedAt?: DateTimeFilter<"Term"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    fees?: FeesListRelationFilter
    invoices?: InvoiceListRelationFilter
  }, "id">

  export type TermOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TermCountOrderByAggregateInput
    _max?: TermMaxOrderByAggregateInput
    _min?: TermMinOrderByAggregateInput
  }

  export type TermScalarWhereWithAggregatesInput = {
    AND?: TermScalarWhereWithAggregatesInput | TermScalarWhereWithAggregatesInput[]
    OR?: TermScalarWhereWithAggregatesInput[]
    NOT?: TermScalarWhereWithAggregatesInput | TermScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Term"> | string
    name?: StringWithAggregatesFilter<"Term"> | string
    schoolId?: StringWithAggregatesFilter<"Term"> | string
    isDeleted?: BoolWithAggregatesFilter<"Term"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Term"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Term"> | Date | string
  }

  export type FeesWhereInput = {
    AND?: FeesWhereInput | FeesWhereInput[]
    OR?: FeesWhereInput[]
    NOT?: FeesWhereInput | FeesWhereInput[]
    id?: StringFilter<"Fees"> | string
    dueAt?: DateTimeFilter<"Fees"> | Date | string
    latePaymentFee?: DecimalFilter<"Fees"> | Decimal | DecimalJsLike | number | string
    schoolId?: StringFilter<"Fees"> | string
    classId?: StringFilter<"Fees"> | string
    sessionId?: StringFilter<"Fees"> | string
    termId?: StringFilter<"Fees"> | string
    isDeleted?: BoolFilter<"Fees"> | boolean
    createdAt?: DateTimeFilter<"Fees"> | Date | string
    updatedAt?: DateTimeFilter<"Fees"> | Date | string
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    academicSession?: XOR<AcademicSessionScalarRelationFilter, AcademicSessionWhereInput>
    term?: XOR<TermScalarRelationFilter, TermWhereInput>
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    feeBreakdowns?: FeeBreakdownListRelationFilter
  }

  export type FeesOrderByWithRelationInput = {
    id?: SortOrder
    dueAt?: SortOrder
    latePaymentFee?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    sessionId?: SortOrder
    termId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    class?: ClassOrderByWithRelationInput
    academicSession?: AcademicSessionOrderByWithRelationInput
    term?: TermOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
    feeBreakdowns?: FeeBreakdownOrderByRelationAggregateInput
  }

  export type FeesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeesWhereInput | FeesWhereInput[]
    OR?: FeesWhereInput[]
    NOT?: FeesWhereInput | FeesWhereInput[]
    dueAt?: DateTimeFilter<"Fees"> | Date | string
    latePaymentFee?: DecimalFilter<"Fees"> | Decimal | DecimalJsLike | number | string
    schoolId?: StringFilter<"Fees"> | string
    classId?: StringFilter<"Fees"> | string
    sessionId?: StringFilter<"Fees"> | string
    termId?: StringFilter<"Fees"> | string
    isDeleted?: BoolFilter<"Fees"> | boolean
    createdAt?: DateTimeFilter<"Fees"> | Date | string
    updatedAt?: DateTimeFilter<"Fees"> | Date | string
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    academicSession?: XOR<AcademicSessionScalarRelationFilter, AcademicSessionWhereInput>
    term?: XOR<TermScalarRelationFilter, TermWhereInput>
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
    feeBreakdowns?: FeeBreakdownListRelationFilter
  }, "id">

  export type FeesOrderByWithAggregationInput = {
    id?: SortOrder
    dueAt?: SortOrder
    latePaymentFee?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    sessionId?: SortOrder
    termId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeesCountOrderByAggregateInput
    _avg?: FeesAvgOrderByAggregateInput
    _max?: FeesMaxOrderByAggregateInput
    _min?: FeesMinOrderByAggregateInput
    _sum?: FeesSumOrderByAggregateInput
  }

  export type FeesScalarWhereWithAggregatesInput = {
    AND?: FeesScalarWhereWithAggregatesInput | FeesScalarWhereWithAggregatesInput[]
    OR?: FeesScalarWhereWithAggregatesInput[]
    NOT?: FeesScalarWhereWithAggregatesInput | FeesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Fees"> | string
    dueAt?: DateTimeWithAggregatesFilter<"Fees"> | Date | string
    latePaymentFee?: DecimalWithAggregatesFilter<"Fees"> | Decimal | DecimalJsLike | number | string
    schoolId?: StringWithAggregatesFilter<"Fees"> | string
    classId?: StringWithAggregatesFilter<"Fees"> | string
    sessionId?: StringWithAggregatesFilter<"Fees"> | string
    termId?: StringWithAggregatesFilter<"Fees"> | string
    isDeleted?: BoolWithAggregatesFilter<"Fees"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Fees"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Fees"> | Date | string
  }

  export type FeeBreakdownWhereInput = {
    AND?: FeeBreakdownWhereInput | FeeBreakdownWhereInput[]
    OR?: FeeBreakdownWhereInput[]
    NOT?: FeeBreakdownWhereInput | FeeBreakdownWhereInput[]
    id?: StringFilter<"FeeBreakdown"> | string
    feeId?: StringFilter<"FeeBreakdown"> | string
    title?: StringFilter<"FeeBreakdown"> | string
    amount?: DecimalFilter<"FeeBreakdown"> | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolFilter<"FeeBreakdown"> | boolean
    createdAt?: DateTimeFilter<"FeeBreakdown"> | Date | string
    updatedAt?: DateTimeFilter<"FeeBreakdown"> | Date | string
    fee?: XOR<FeesScalarRelationFilter, FeesWhereInput>
  }

  export type FeeBreakdownOrderByWithRelationInput = {
    id?: SortOrder
    feeId?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fee?: FeesOrderByWithRelationInput
  }

  export type FeeBreakdownWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeeBreakdownWhereInput | FeeBreakdownWhereInput[]
    OR?: FeeBreakdownWhereInput[]
    NOT?: FeeBreakdownWhereInput | FeeBreakdownWhereInput[]
    feeId?: StringFilter<"FeeBreakdown"> | string
    title?: StringFilter<"FeeBreakdown"> | string
    amount?: DecimalFilter<"FeeBreakdown"> | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolFilter<"FeeBreakdown"> | boolean
    createdAt?: DateTimeFilter<"FeeBreakdown"> | Date | string
    updatedAt?: DateTimeFilter<"FeeBreakdown"> | Date | string
    fee?: XOR<FeesScalarRelationFilter, FeesWhereInput>
  }, "id">

  export type FeeBreakdownOrderByWithAggregationInput = {
    id?: SortOrder
    feeId?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeeBreakdownCountOrderByAggregateInput
    _avg?: FeeBreakdownAvgOrderByAggregateInput
    _max?: FeeBreakdownMaxOrderByAggregateInput
    _min?: FeeBreakdownMinOrderByAggregateInput
    _sum?: FeeBreakdownSumOrderByAggregateInput
  }

  export type FeeBreakdownScalarWhereWithAggregatesInput = {
    AND?: FeeBreakdownScalarWhereWithAggregatesInput | FeeBreakdownScalarWhereWithAggregatesInput[]
    OR?: FeeBreakdownScalarWhereWithAggregatesInput[]
    NOT?: FeeBreakdownScalarWhereWithAggregatesInput | FeeBreakdownScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeeBreakdown"> | string
    feeId?: StringWithAggregatesFilter<"FeeBreakdown"> | string
    title?: StringWithAggregatesFilter<"FeeBreakdown"> | string
    amount?: DecimalWithAggregatesFilter<"FeeBreakdown"> | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolWithAggregatesFilter<"FeeBreakdown"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FeeBreakdown"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeeBreakdown"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    invoiceNo?: StringFilter<"Invoice"> | string
    feeId?: StringFilter<"Invoice"> | string
    guardianId?: StringFilter<"Invoice"> | string
    classId?: StringFilter<"Invoice"> | string
    sessionId?: StringFilter<"Invoice"> | string
    termId?: StringFilter<"Invoice"> | string
    totalAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    dueAt?: DateTimeFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    isDeleted?: BoolFilter<"Invoice"> | boolean
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    guardian?: XOR<GuardianScalarRelationFilter, GuardianWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    academicSession?: XOR<AcademicSessionScalarRelationFilter, AcademicSessionWhereInput>
    term?: XOR<TermScalarRelationFilter, TermWhereInput>
    transactions?: TransactionListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    feeId?: SortOrder
    guardianId?: SortOrder
    classId?: SortOrder
    sessionId?: SortOrder
    termId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    dueAt?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    guardian?: GuardianOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    academicSession?: AcademicSessionOrderByWithRelationInput
    term?: TermOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNo?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    feeId?: StringFilter<"Invoice"> | string
    guardianId?: StringFilter<"Invoice"> | string
    classId?: StringFilter<"Invoice"> | string
    sessionId?: StringFilter<"Invoice"> | string
    termId?: StringFilter<"Invoice"> | string
    totalAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    dueAt?: DateTimeFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    isDeleted?: BoolFilter<"Invoice"> | boolean
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    guardian?: XOR<GuardianScalarRelationFilter, GuardianWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    academicSession?: XOR<AcademicSessionScalarRelationFilter, AcademicSessionWhereInput>
    term?: XOR<TermScalarRelationFilter, TermWhereInput>
    transactions?: TransactionListRelationFilter
  }, "id" | "invoiceNo">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    feeId?: SortOrder
    guardianId?: SortOrder
    classId?: SortOrder
    sessionId?: SortOrder
    termId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    dueAt?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    invoiceNo?: StringWithAggregatesFilter<"Invoice"> | string
    feeId?: StringWithAggregatesFilter<"Invoice"> | string
    guardianId?: StringWithAggregatesFilter<"Invoice"> | string
    classId?: StringWithAggregatesFilter<"Invoice"> | string
    sessionId?: StringWithAggregatesFilter<"Invoice"> | string
    termId?: StringWithAggregatesFilter<"Invoice"> | string
    totalAmount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    dueAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    isDeleted?: BoolWithAggregatesFilter<"Invoice"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    image?: StringNullableFilter<"Student"> | string | null
    classId?: StringFilter<"Student"> | string
    guardianId?: StringNullableFilter<"Student"> | string | null
    registrationNumber?: StringFilter<"Student"> | string
    status?: EnumStudentStatusFilter<"Student"> | $Enums.StudentStatus
    isDeleted?: BoolFilter<"Student"> | boolean
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    guardian?: XOR<GuardianNullableScalarRelationFilter, GuardianWhereInput> | null
    linkedStudentProfile?: XOR<LinkedStudentProfileNullableScalarRelationFilter, LinkedStudentProfileWhereInput> | null
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    image?: SortOrderInput | SortOrder
    classId?: SortOrder
    guardianId?: SortOrderInput | SortOrder
    registrationNumber?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    class?: ClassOrderByWithRelationInput
    guardian?: GuardianOrderByWithRelationInput
    linkedStudentProfile?: LinkedStudentProfileOrderByWithRelationInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    registrationNumber?: string
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    image?: StringNullableFilter<"Student"> | string | null
    classId?: StringFilter<"Student"> | string
    guardianId?: StringNullableFilter<"Student"> | string | null
    status?: EnumStudentStatusFilter<"Student"> | $Enums.StudentStatus
    isDeleted?: BoolFilter<"Student"> | boolean
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    guardian?: XOR<GuardianNullableScalarRelationFilter, GuardianWhereInput> | null
    linkedStudentProfile?: XOR<LinkedStudentProfileNullableScalarRelationFilter, LinkedStudentProfileWhereInput> | null
  }, "id" | "registrationNumber">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    image?: SortOrderInput | SortOrder
    classId?: SortOrder
    guardianId?: SortOrderInput | SortOrder
    registrationNumber?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    firstName?: StringWithAggregatesFilter<"Student"> | string
    lastName?: StringWithAggregatesFilter<"Student"> | string
    image?: StringNullableWithAggregatesFilter<"Student"> | string | null
    classId?: StringWithAggregatesFilter<"Student"> | string
    guardianId?: StringNullableWithAggregatesFilter<"Student"> | string | null
    registrationNumber?: StringWithAggregatesFilter<"Student"> | string
    status?: EnumStudentStatusWithAggregatesFilter<"Student"> | $Enums.StudentStatus
    isDeleted?: BoolWithAggregatesFilter<"Student"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
  }

  export type LinkedStudentProfileWhereInput = {
    AND?: LinkedStudentProfileWhereInput | LinkedStudentProfileWhereInput[]
    OR?: LinkedStudentProfileWhereInput[]
    NOT?: LinkedStudentProfileWhereInput | LinkedStudentProfileWhereInput[]
    id?: StringFilter<"LinkedStudentProfile"> | string
    studentId?: StringFilter<"LinkedStudentProfile"> | string
    guardianId?: StringFilter<"LinkedStudentProfile"> | string
    lastGuardiantChanged?: DateTimeFilter<"LinkedStudentProfile"> | Date | string
    isDeleted?: BoolFilter<"LinkedStudentProfile"> | boolean
    createdAt?: DateTimeFilter<"LinkedStudentProfile"> | Date | string
    updatedAt?: DateTimeFilter<"LinkedStudentProfile"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    guardian?: XOR<GuardianScalarRelationFilter, GuardianWhereInput>
  }

  export type LinkedStudentProfileOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    guardianId?: SortOrder
    lastGuardiantChanged?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    guardian?: GuardianOrderByWithRelationInput
  }

  export type LinkedStudentProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId?: string
    AND?: LinkedStudentProfileWhereInput | LinkedStudentProfileWhereInput[]
    OR?: LinkedStudentProfileWhereInput[]
    NOT?: LinkedStudentProfileWhereInput | LinkedStudentProfileWhereInput[]
    guardianId?: StringFilter<"LinkedStudentProfile"> | string
    lastGuardiantChanged?: DateTimeFilter<"LinkedStudentProfile"> | Date | string
    isDeleted?: BoolFilter<"LinkedStudentProfile"> | boolean
    createdAt?: DateTimeFilter<"LinkedStudentProfile"> | Date | string
    updatedAt?: DateTimeFilter<"LinkedStudentProfile"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    guardian?: XOR<GuardianScalarRelationFilter, GuardianWhereInput>
  }, "id" | "studentId">

  export type LinkedStudentProfileOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    guardianId?: SortOrder
    lastGuardiantChanged?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LinkedStudentProfileCountOrderByAggregateInput
    _max?: LinkedStudentProfileMaxOrderByAggregateInput
    _min?: LinkedStudentProfileMinOrderByAggregateInput
  }

  export type LinkedStudentProfileScalarWhereWithAggregatesInput = {
    AND?: LinkedStudentProfileScalarWhereWithAggregatesInput | LinkedStudentProfileScalarWhereWithAggregatesInput[]
    OR?: LinkedStudentProfileScalarWhereWithAggregatesInput[]
    NOT?: LinkedStudentProfileScalarWhereWithAggregatesInput | LinkedStudentProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LinkedStudentProfile"> | string
    studentId?: StringWithAggregatesFilter<"LinkedStudentProfile"> | string
    guardianId?: StringWithAggregatesFilter<"LinkedStudentProfile"> | string
    lastGuardiantChanged?: DateTimeWithAggregatesFilter<"LinkedStudentProfile"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"LinkedStudentProfile"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"LinkedStudentProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LinkedStudentProfile"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    guardianId?: StringFilter<"Transaction"> | string
    invoiceId?: StringFilter<"Transaction"> | string
    reference?: StringFilter<"Transaction"> | string
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    fees?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    transactionAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    processedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    description?: StringNullableFilter<"Transaction"> | string | null
    isDeleted?: BoolFilter<"Transaction"> | boolean
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    guardian?: XOR<GuardianScalarRelationFilter, GuardianWhereInput>
    transactionFee?: XOR<TransactionFeeNullableScalarRelationFilter, TransactionFeeWhereInput> | null
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    guardianId?: SortOrder
    invoiceId?: SortOrder
    reference?: SortOrder
    amount?: SortOrder
    fees?: SortOrder
    status?: SortOrder
    transactionAt?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    guardian?: GuardianOrderByWithRelationInput
    transactionFee?: TransactionFeeOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reference?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    guardianId?: StringFilter<"Transaction"> | string
    invoiceId?: StringFilter<"Transaction"> | string
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    fees?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    transactionAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    processedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    description?: StringNullableFilter<"Transaction"> | string | null
    isDeleted?: BoolFilter<"Transaction"> | boolean
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    guardian?: XOR<GuardianScalarRelationFilter, GuardianWhereInput>
    transactionFee?: XOR<TransactionFeeNullableScalarRelationFilter, TransactionFeeWhereInput> | null
  }, "id" | "reference">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    guardianId?: SortOrder
    invoiceId?: SortOrder
    reference?: SortOrder
    amount?: SortOrder
    fees?: SortOrder
    status?: SortOrder
    transactionAt?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    guardianId?: StringWithAggregatesFilter<"Transaction"> | string
    invoiceId?: StringWithAggregatesFilter<"Transaction"> | string
    reference?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    fees?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusWithAggregatesFilter<"Transaction"> | $Enums.TransactionStatus
    transactionAt?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Transaction"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type TransactionFeeWhereInput = {
    AND?: TransactionFeeWhereInput | TransactionFeeWhereInput[]
    OR?: TransactionFeeWhereInput[]
    NOT?: TransactionFeeWhereInput | TransactionFeeWhereInput[]
    id?: StringFilter<"TransactionFee"> | string
    transactionId?: StringFilter<"TransactionFee"> | string
    platformFee?: DecimalFilter<"TransactionFee"> | Decimal | DecimalJsLike | number | string
    latePaymentFee?: DecimalFilter<"TransactionFee"> | Decimal | DecimalJsLike | number | string
    processingFee?: DecimalFilter<"TransactionFee"> | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolFilter<"TransactionFee"> | boolean
    createdAt?: DateTimeFilter<"TransactionFee"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionFee"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
  }

  export type TransactionFeeOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    platformFee?: SortOrder
    latePaymentFee?: SortOrder
    processingFee?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transaction?: TransactionOrderByWithRelationInput
  }

  export type TransactionFeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionId?: string
    AND?: TransactionFeeWhereInput | TransactionFeeWhereInput[]
    OR?: TransactionFeeWhereInput[]
    NOT?: TransactionFeeWhereInput | TransactionFeeWhereInput[]
    platformFee?: DecimalFilter<"TransactionFee"> | Decimal | DecimalJsLike | number | string
    latePaymentFee?: DecimalFilter<"TransactionFee"> | Decimal | DecimalJsLike | number | string
    processingFee?: DecimalFilter<"TransactionFee"> | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolFilter<"TransactionFee"> | boolean
    createdAt?: DateTimeFilter<"TransactionFee"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionFee"> | Date | string
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
  }, "id" | "transactionId">

  export type TransactionFeeOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    platformFee?: SortOrder
    latePaymentFee?: SortOrder
    processingFee?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionFeeCountOrderByAggregateInput
    _avg?: TransactionFeeAvgOrderByAggregateInput
    _max?: TransactionFeeMaxOrderByAggregateInput
    _min?: TransactionFeeMinOrderByAggregateInput
    _sum?: TransactionFeeSumOrderByAggregateInput
  }

  export type TransactionFeeScalarWhereWithAggregatesInput = {
    AND?: TransactionFeeScalarWhereWithAggregatesInput | TransactionFeeScalarWhereWithAggregatesInput[]
    OR?: TransactionFeeScalarWhereWithAggregatesInput[]
    NOT?: TransactionFeeScalarWhereWithAggregatesInput | TransactionFeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransactionFee"> | string
    transactionId?: StringWithAggregatesFilter<"TransactionFee"> | string
    platformFee?: DecimalWithAggregatesFilter<"TransactionFee"> | Decimal | DecimalJsLike | number | string
    latePaymentFee?: DecimalWithAggregatesFilter<"TransactionFee"> | Decimal | DecimalJsLike | number | string
    processingFee?: DecimalWithAggregatesFilter<"TransactionFee"> | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolWithAggregatesFilter<"TransactionFee"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TransactionFee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TransactionFee"> | Date | string
  }

  export type PayoutWhereInput = {
    AND?: PayoutWhereInput | PayoutWhereInput[]
    OR?: PayoutWhereInput[]
    NOT?: PayoutWhereInput | PayoutWhereInput[]
    id?: StringFilter<"Payout"> | string
    schoolId?: StringFilter<"Payout"> | string
    amount?: DecimalFilter<"Payout"> | Decimal | DecimalJsLike | number | string
    processingFee?: DecimalFilter<"Payout"> | Decimal | DecimalJsLike | number | string
    status?: EnumPayoutStatusFilter<"Payout"> | $Enums.PayoutStatus
    initiatedAt?: DateTimeFilter<"Payout"> | Date | string
    completedAt?: DateTimeNullableFilter<"Payout"> | Date | string | null
    isDeleted?: BoolFilter<"Payout"> | boolean
    createdAt?: DateTimeFilter<"Payout"> | Date | string
    updatedAt?: DateTimeFilter<"Payout"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
  }

  export type PayoutOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    amount?: SortOrder
    processingFee?: SortOrder
    status?: SortOrder
    initiatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    school?: SchoolOrderByWithRelationInput
  }

  export type PayoutWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PayoutWhereInput | PayoutWhereInput[]
    OR?: PayoutWhereInput[]
    NOT?: PayoutWhereInput | PayoutWhereInput[]
    schoolId?: StringFilter<"Payout"> | string
    amount?: DecimalFilter<"Payout"> | Decimal | DecimalJsLike | number | string
    processingFee?: DecimalFilter<"Payout"> | Decimal | DecimalJsLike | number | string
    status?: EnumPayoutStatusFilter<"Payout"> | $Enums.PayoutStatus
    initiatedAt?: DateTimeFilter<"Payout"> | Date | string
    completedAt?: DateTimeNullableFilter<"Payout"> | Date | string | null
    isDeleted?: BoolFilter<"Payout"> | boolean
    createdAt?: DateTimeFilter<"Payout"> | Date | string
    updatedAt?: DateTimeFilter<"Payout"> | Date | string
    school?: XOR<SchoolScalarRelationFilter, SchoolWhereInput>
  }, "id">

  export type PayoutOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    amount?: SortOrder
    processingFee?: SortOrder
    status?: SortOrder
    initiatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PayoutCountOrderByAggregateInput
    _avg?: PayoutAvgOrderByAggregateInput
    _max?: PayoutMaxOrderByAggregateInput
    _min?: PayoutMinOrderByAggregateInput
    _sum?: PayoutSumOrderByAggregateInput
  }

  export type PayoutScalarWhereWithAggregatesInput = {
    AND?: PayoutScalarWhereWithAggregatesInput | PayoutScalarWhereWithAggregatesInput[]
    OR?: PayoutScalarWhereWithAggregatesInput[]
    NOT?: PayoutScalarWhereWithAggregatesInput | PayoutScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payout"> | string
    schoolId?: StringWithAggregatesFilter<"Payout"> | string
    amount?: DecimalWithAggregatesFilter<"Payout"> | Decimal | DecimalJsLike | number | string
    processingFee?: DecimalWithAggregatesFilter<"Payout"> | Decimal | DecimalJsLike | number | string
    status?: EnumPayoutStatusWithAggregatesFilter<"Payout"> | $Enums.PayoutStatus
    initiatedAt?: DateTimeWithAggregatesFilter<"Payout"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"Payout"> | Date | string | null
    isDeleted?: BoolWithAggregatesFilter<"Payout"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Payout"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payout"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    sentAt?: DateTimeFilter<"Notification"> | Date | string
    isDeleted?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    sentAt?: DateTimeFilter<"Notification"> | Date | string
    isDeleted?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    status?: EnumNotificationStatusWithAggregatesFilter<"Notification"> | $Enums.NotificationStatus
    sentAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type WalletWhereInput = {
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    id?: StringFilter<"Wallet"> | string
    userId?: StringFilter<"Wallet"> | string
    address?: StringFilter<"Wallet"> | string
    name?: StringFilter<"Wallet"> | string
    tag?: StringFilter<"Wallet"> | string
    routingNumber?: StringFilter<"Wallet"> | string
    balance?: StringFilter<"Wallet"> | string
    status?: EnumWalletStatusFilter<"Wallet"> | $Enums.WalletStatus
    isDeleted?: BoolFilter<"Wallet"> | boolean
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    Ledger?: LedgerListRelationFilter
    Transaction?: WalletTransactionListRelationFilter
  }

  export type WalletOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrder
    name?: SortOrder
    tag?: SortOrder
    routingNumber?: SortOrder
    balance?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    Ledger?: LedgerOrderByRelationAggregateInput
    Transaction?: WalletTransactionOrderByRelationAggregateInput
  }

  export type WalletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    address?: string
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    name?: StringFilter<"Wallet"> | string
    tag?: StringFilter<"Wallet"> | string
    routingNumber?: StringFilter<"Wallet"> | string
    balance?: StringFilter<"Wallet"> | string
    status?: EnumWalletStatusFilter<"Wallet"> | $Enums.WalletStatus
    isDeleted?: BoolFilter<"Wallet"> | boolean
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    Ledger?: LedgerListRelationFilter
    Transaction?: WalletTransactionListRelationFilter
  }, "id" | "userId" | "address">

  export type WalletOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrder
    name?: SortOrder
    tag?: SortOrder
    routingNumber?: SortOrder
    balance?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: WalletCountOrderByAggregateInput
    _max?: WalletMaxOrderByAggregateInput
    _min?: WalletMinOrderByAggregateInput
  }

  export type WalletScalarWhereWithAggregatesInput = {
    AND?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    OR?: WalletScalarWhereWithAggregatesInput[]
    NOT?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Wallet"> | string
    userId?: StringWithAggregatesFilter<"Wallet"> | string
    address?: StringWithAggregatesFilter<"Wallet"> | string
    name?: StringWithAggregatesFilter<"Wallet"> | string
    tag?: StringWithAggregatesFilter<"Wallet"> | string
    routingNumber?: StringWithAggregatesFilter<"Wallet"> | string
    balance?: StringWithAggregatesFilter<"Wallet"> | string
    status?: EnumWalletStatusWithAggregatesFilter<"Wallet"> | $Enums.WalletStatus
    isDeleted?: BoolWithAggregatesFilter<"Wallet"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
  }

  export type WalletTransactionWhereInput = {
    AND?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    OR?: WalletTransactionWhereInput[]
    NOT?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    id?: StringFilter<"WalletTransaction"> | string
    walletId?: StringFilter<"WalletTransaction"> | string
    amount?: DecimalFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    fees?: DecimalFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    reference?: StringFilter<"WalletTransaction"> | string
    type?: EnumTransactionTypeFilter<"WalletTransaction"> | $Enums.TransactionType
    flow?: EnumTransactionFlowFilter<"WalletTransaction"> | $Enums.TransactionFlow
    transactionAt?: DateTimeNullableFilter<"WalletTransaction"> | Date | string | null
    processedAt?: DateTimeNullableFilter<"WalletTransaction"> | Date | string | null
    desc?: StringNullableFilter<"WalletTransaction"> | string | null
    status?: EnumTransactionStatusFilter<"WalletTransaction"> | $Enums.TransactionStatus
    isDeleted?: BoolFilter<"WalletTransaction"> | boolean
    updatedAt?: DateTimeFilter<"WalletTransaction"> | Date | string
    createdAt?: DateTimeFilter<"WalletTransaction"> | Date | string
    wallet?: XOR<WalletScalarRelationFilter, WalletWhereInput>
    ledger?: XOR<LedgerNullableScalarRelationFilter, LedgerWhereInput> | null
  }

  export type WalletTransactionOrderByWithRelationInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    fees?: SortOrder
    netAmount?: SortOrder
    reference?: SortOrder
    type?: SortOrder
    flow?: SortOrder
    transactionAt?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    desc?: SortOrderInput | SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    wallet?: WalletOrderByWithRelationInput
    ledger?: LedgerOrderByWithRelationInput
  }

  export type WalletTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reference?: string
    AND?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    OR?: WalletTransactionWhereInput[]
    NOT?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    walletId?: StringFilter<"WalletTransaction"> | string
    amount?: DecimalFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    fees?: DecimalFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    type?: EnumTransactionTypeFilter<"WalletTransaction"> | $Enums.TransactionType
    flow?: EnumTransactionFlowFilter<"WalletTransaction"> | $Enums.TransactionFlow
    transactionAt?: DateTimeNullableFilter<"WalletTransaction"> | Date | string | null
    processedAt?: DateTimeNullableFilter<"WalletTransaction"> | Date | string | null
    desc?: StringNullableFilter<"WalletTransaction"> | string | null
    status?: EnumTransactionStatusFilter<"WalletTransaction"> | $Enums.TransactionStatus
    isDeleted?: BoolFilter<"WalletTransaction"> | boolean
    updatedAt?: DateTimeFilter<"WalletTransaction"> | Date | string
    createdAt?: DateTimeFilter<"WalletTransaction"> | Date | string
    wallet?: XOR<WalletScalarRelationFilter, WalletWhereInput>
    ledger?: XOR<LedgerNullableScalarRelationFilter, LedgerWhereInput> | null
  }, "id" | "reference">

  export type WalletTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    fees?: SortOrder
    netAmount?: SortOrder
    reference?: SortOrder
    type?: SortOrder
    flow?: SortOrder
    transactionAt?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    desc?: SortOrderInput | SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: WalletTransactionCountOrderByAggregateInput
    _avg?: WalletTransactionAvgOrderByAggregateInput
    _max?: WalletTransactionMaxOrderByAggregateInput
    _min?: WalletTransactionMinOrderByAggregateInput
    _sum?: WalletTransactionSumOrderByAggregateInput
  }

  export type WalletTransactionScalarWhereWithAggregatesInput = {
    AND?: WalletTransactionScalarWhereWithAggregatesInput | WalletTransactionScalarWhereWithAggregatesInput[]
    OR?: WalletTransactionScalarWhereWithAggregatesInput[]
    NOT?: WalletTransactionScalarWhereWithAggregatesInput | WalletTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WalletTransaction"> | string
    walletId?: StringWithAggregatesFilter<"WalletTransaction"> | string
    amount?: DecimalWithAggregatesFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    fees?: DecimalWithAggregatesFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalWithAggregatesFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    reference?: StringWithAggregatesFilter<"WalletTransaction"> | string
    type?: EnumTransactionTypeWithAggregatesFilter<"WalletTransaction"> | $Enums.TransactionType
    flow?: EnumTransactionFlowWithAggregatesFilter<"WalletTransaction"> | $Enums.TransactionFlow
    transactionAt?: DateTimeNullableWithAggregatesFilter<"WalletTransaction"> | Date | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"WalletTransaction"> | Date | string | null
    desc?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
    status?: EnumTransactionStatusWithAggregatesFilter<"WalletTransaction"> | $Enums.TransactionStatus
    isDeleted?: BoolWithAggregatesFilter<"WalletTransaction"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"WalletTransaction"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"WalletTransaction"> | Date | string
  }

  export type LedgerWhereInput = {
    AND?: LedgerWhereInput | LedgerWhereInput[]
    OR?: LedgerWhereInput[]
    NOT?: LedgerWhereInput | LedgerWhereInput[]
    id?: StringFilter<"Ledger"> | string
    walletId?: StringFilter<"Ledger"> | string
    transactionId?: StringFilter<"Ledger"> | string
    debit?: DecimalFilter<"Ledger"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalFilter<"Ledger"> | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFilter<"Ledger"> | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFilter<"Ledger"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"Ledger"> | string | null
    isDeleted?: BoolFilter<"Ledger"> | boolean
    updatedAt?: DateTimeFilter<"Ledger"> | Date | string
    createdAt?: DateTimeFilter<"Ledger"> | Date | string
    wallet?: XOR<WalletScalarRelationFilter, WalletWhereInput>
    transaction?: XOR<WalletTransactionScalarRelationFilter, WalletTransactionWhereInput>
  }

  export type LedgerOrderByWithRelationInput = {
    id?: SortOrder
    walletId?: SortOrder
    transactionId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    description?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    wallet?: WalletOrderByWithRelationInput
    transaction?: WalletTransactionOrderByWithRelationInput
  }

  export type LedgerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionId?: string
    AND?: LedgerWhereInput | LedgerWhereInput[]
    OR?: LedgerWhereInput[]
    NOT?: LedgerWhereInput | LedgerWhereInput[]
    walletId?: StringFilter<"Ledger"> | string
    debit?: DecimalFilter<"Ledger"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalFilter<"Ledger"> | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFilter<"Ledger"> | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFilter<"Ledger"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"Ledger"> | string | null
    isDeleted?: BoolFilter<"Ledger"> | boolean
    updatedAt?: DateTimeFilter<"Ledger"> | Date | string
    createdAt?: DateTimeFilter<"Ledger"> | Date | string
    wallet?: XOR<WalletScalarRelationFilter, WalletWhereInput>
    transaction?: XOR<WalletTransactionScalarRelationFilter, WalletTransactionWhereInput>
  }, "id" | "transactionId">

  export type LedgerOrderByWithAggregationInput = {
    id?: SortOrder
    walletId?: SortOrder
    transactionId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    description?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: LedgerCountOrderByAggregateInput
    _avg?: LedgerAvgOrderByAggregateInput
    _max?: LedgerMaxOrderByAggregateInput
    _min?: LedgerMinOrderByAggregateInput
    _sum?: LedgerSumOrderByAggregateInput
  }

  export type LedgerScalarWhereWithAggregatesInput = {
    AND?: LedgerScalarWhereWithAggregatesInput | LedgerScalarWhereWithAggregatesInput[]
    OR?: LedgerScalarWhereWithAggregatesInput[]
    NOT?: LedgerScalarWhereWithAggregatesInput | LedgerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ledger"> | string
    walletId?: StringWithAggregatesFilter<"Ledger"> | string
    transactionId?: StringWithAggregatesFilter<"Ledger"> | string
    debit?: DecimalWithAggregatesFilter<"Ledger"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalWithAggregatesFilter<"Ledger"> | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalWithAggregatesFilter<"Ledger"> | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalWithAggregatesFilter<"Ledger"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableWithAggregatesFilter<"Ledger"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Ledger"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"Ledger"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Ledger"> | Date | string
  }

  export type FirebaseTokenWhereInput = {
    AND?: FirebaseTokenWhereInput | FirebaseTokenWhereInput[]
    OR?: FirebaseTokenWhereInput[]
    NOT?: FirebaseTokenWhereInput | FirebaseTokenWhereInput[]
    id?: StringFilter<"FirebaseToken"> | string
    userId?: StringFilter<"FirebaseToken"> | string
    token?: StringNullableFilter<"FirebaseToken"> | string | null
    isDeleted?: BoolFilter<"FirebaseToken"> | boolean
    updatedAt?: DateTimeFilter<"FirebaseToken"> | Date | string
    createdAt?: DateTimeFilter<"FirebaseToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FirebaseTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type FirebaseTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: FirebaseTokenWhereInput | FirebaseTokenWhereInput[]
    OR?: FirebaseTokenWhereInput[]
    NOT?: FirebaseTokenWhereInput | FirebaseTokenWhereInput[]
    token?: StringNullableFilter<"FirebaseToken"> | string | null
    isDeleted?: BoolFilter<"FirebaseToken"> | boolean
    updatedAt?: DateTimeFilter<"FirebaseToken"> | Date | string
    createdAt?: DateTimeFilter<"FirebaseToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type FirebaseTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: FirebaseTokenCountOrderByAggregateInput
    _max?: FirebaseTokenMaxOrderByAggregateInput
    _min?: FirebaseTokenMinOrderByAggregateInput
  }

  export type FirebaseTokenScalarWhereWithAggregatesInput = {
    AND?: FirebaseTokenScalarWhereWithAggregatesInput | FirebaseTokenScalarWhereWithAggregatesInput[]
    OR?: FirebaseTokenScalarWhereWithAggregatesInput[]
    NOT?: FirebaseTokenScalarWhereWithAggregatesInput | FirebaseTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FirebaseToken"> | string
    userId?: StringWithAggregatesFilter<"FirebaseToken"> | string
    token?: StringNullableWithAggregatesFilter<"FirebaseToken"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"FirebaseToken"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"FirebaseToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"FirebaseToken"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    firstName: string
    lastName: string
    profileImage?: string | null
    email: string
    type: $Enums.UserType
    phone?: string | null
    accountStatus?: $Enums.AccountStatus
    verifiedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    administrator?: AdministratorCreateNestedOneWithoutUserInput
    guardian?: GuardianCreateNestedOneWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    school?: SchoolCreateNestedOneWithoutOwnerInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementCreateNestedOneWithoutSignedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    credential?: CredentialCreateNestedOneWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    firebaseToken?: FirebaseTokenCreateNestedOneWithoutUserInput
    kycverification?: KYCVerificationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    profileImage?: string | null
    email: string
    type: $Enums.UserType
    phone?: string | null
    accountStatus?: $Enums.AccountStatus
    verifiedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    administrator?: AdministratorUncheckedCreateNestedOneWithoutUserInput
    guardian?: GuardianUncheckedCreateNestedOneWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    school?: SchoolUncheckedCreateNestedOneWithoutOwnerInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedCreateNestedOneWithoutSignedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    credential?: CredentialUncheckedCreateNestedOneWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    firebaseToken?: FirebaseTokenUncheckedCreateNestedOneWithoutUserInput
    kycverification?: KYCVerificationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTermsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isPrivacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    administrator?: AdministratorUpdateOneWithoutUserNestedInput
    guardian?: GuardianUpdateOneWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    school?: SchoolUpdateOneWithoutOwnerNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUpdateOneWithoutSignedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    credential?: CredentialUpdateOneWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    firebaseToken?: FirebaseTokenUpdateOneWithoutUserNestedInput
    kycverification?: KYCVerificationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTermsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isPrivacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    administrator?: AdministratorUncheckedUpdateOneWithoutUserNestedInput
    guardian?: GuardianUncheckedUpdateOneWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    school?: SchoolUncheckedUpdateOneWithoutOwnerNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedUpdateOneWithoutSignedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    credential?: CredentialUncheckedUpdateOneWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    firebaseToken?: FirebaseTokenUncheckedUpdateOneWithoutUserNestedInput
    kycverification?: KYCVerificationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    profileImage?: string | null
    email: string
    type: $Enums.UserType
    phone?: string | null
    accountStatus?: $Enums.AccountStatus
    verifiedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTermsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isPrivacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTermsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isPrivacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CredentialCreateInput = {
    id?: string
    password?: string | null
    pinCode?: string | null
    lastResetAt?: Date | string | null
    lastUsedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCredentialInput
  }

  export type CredentialUncheckedCreateInput = {
    id?: string
    userId: string
    password?: string | null
    pinCode?: string | null
    lastResetAt?: Date | string | null
    lastUsedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CredentialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pinCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCredentialNestedInput
  }

  export type CredentialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pinCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CredentialCreateManyInput = {
    id?: string
    userId: string
    password?: string | null
    pinCode?: string | null
    lastResetAt?: Date | string | null
    lastUsedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CredentialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pinCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CredentialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pinCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    revoked?: boolean
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    revoked?: boolean
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    revoked?: boolean
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdministratorCreateInput = {
    id?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdministratorInput
  }

  export type AdministratorUncheckedCreateInput = {
    id?: string
    userId: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdministratorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdministratorNestedInput
  }

  export type AdministratorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdministratorCreateManyInput = {
    id?: string
    userId: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdministratorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdministratorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuardianCreateInput = {
    id?: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGuardianInput
    invoices?: InvoiceCreateNestedManyWithoutGuardianInput
    students?: StudentCreateNestedManyWithoutGuardianInput
    linkedStudentProfiles?: LinkedStudentProfileCreateNestedManyWithoutGuardianInput
    transactions?: TransactionCreateNestedManyWithoutGuardianInput
  }

  export type GuardianUncheckedCreateInput = {
    id?: string
    userId: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutGuardianInput
    students?: StudentUncheckedCreateNestedManyWithoutGuardianInput
    linkedStudentProfiles?: LinkedStudentProfileUncheckedCreateNestedManyWithoutGuardianInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutGuardianInput
  }

  export type GuardianUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGuardianNestedInput
    invoices?: InvoiceUpdateManyWithoutGuardianNestedInput
    students?: StudentUpdateManyWithoutGuardianNestedInput
    linkedStudentProfiles?: LinkedStudentProfileUpdateManyWithoutGuardianNestedInput
    transactions?: TransactionUpdateManyWithoutGuardianNestedInput
  }

  export type GuardianUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutGuardianNestedInput
    students?: StudentUncheckedUpdateManyWithoutGuardianNestedInput
    linkedStudentProfiles?: LinkedStudentProfileUncheckedUpdateManyWithoutGuardianNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutGuardianNestedInput
  }

  export type GuardianCreateManyInput = {
    id?: string
    userId: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GuardianUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuardianUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id?: string
    type: $Enums.VerificationType
    code: string
    expiresAt: Date | string
    resendCount?: number
    used?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutVerificationsInput
  }

  export type VerificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.VerificationType
    code: string
    expiresAt: Date | string
    resendCount?: number
    used?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumVerificationTypeFieldUpdateOperationsInput | $Enums.VerificationType
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resendCount?: IntFieldUpdateOperationsInput | number
    used?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVerificationsNestedInput
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumVerificationTypeFieldUpdateOperationsInput | $Enums.VerificationType
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resendCount?: IntFieldUpdateOperationsInput | number
    used?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.VerificationType
    code: string
    expiresAt: Date | string
    resendCount?: number
    used?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumVerificationTypeFieldUpdateOperationsInput | $Enums.VerificationType
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resendCount?: IntFieldUpdateOperationsInput | number
    used?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumVerificationTypeFieldUpdateOperationsInput | $Enums.VerificationType
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resendCount?: IntFieldUpdateOperationsInput | number
    used?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolCreateInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutSchoolInput
    schoolDirectorVerification?: SchoolDirectorVerificationCreateNestedOneWithoutSchoolInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationCreateNestedOneWithoutSchoolInput
    schoolVerification?: SchoolVerificationCreateNestedOneWithoutSchoolInput
    schoolPayoutDetail?: SchoolPayoutDetailCreateNestedOneWithoutSchoolInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementCreateNestedOneWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    academicSessions?: AcademicSessionCreateNestedManyWithoutSchoolInput
    terms?: TermCreateNestedManyWithoutSchoolInput
    fees?: FeesCreateNestedManyWithoutSchoolInput
    payouts?: PayoutCreateNestedManyWithoutSchoolInput
    kycverification?: KYCVerificationCreateNestedOneWithoutSchoolInput
  }

  export type SchoolUncheckedCreateInput = {
    id?: string
    ownerId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolDirectorVerification?: SchoolDirectorVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolVerification?: SchoolVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolPayoutDetail?: SchoolPayoutDetailUncheckedCreateNestedOneWithoutSchoolInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedCreateNestedOneWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    academicSessions?: AcademicSessionUncheckedCreateNestedManyWithoutSchoolInput
    terms?: TermUncheckedCreateNestedManyWithoutSchoolInput
    fees?: FeesUncheckedCreateNestedManyWithoutSchoolInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutSchoolInput
    kycverification?: KYCVerificationUncheckedCreateNestedOneWithoutSchoolInput
  }

  export type SchoolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutSchoolNestedInput
    schoolDirectorVerification?: SchoolDirectorVerificationUpdateOneWithoutSchoolNestedInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUpdateOneWithoutSchoolNestedInput
    schoolVerification?: SchoolVerificationUpdateOneWithoutSchoolNestedInput
    schoolPayoutDetail?: SchoolPayoutDetailUpdateOneWithoutSchoolNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUpdateOneWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    academicSessions?: AcademicSessionUpdateManyWithoutSchoolNestedInput
    terms?: TermUpdateManyWithoutSchoolNestedInput
    fees?: FeesUpdateManyWithoutSchoolNestedInput
    payouts?: PayoutUpdateManyWithoutSchoolNestedInput
    kycverification?: KYCVerificationUpdateOneWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolDirectorVerification?: SchoolDirectorVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolVerification?: SchoolVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolPayoutDetail?: SchoolPayoutDetailUncheckedUpdateOneWithoutSchoolNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedUpdateOneWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    academicSessions?: AcademicSessionUncheckedUpdateManyWithoutSchoolNestedInput
    terms?: TermUncheckedUpdateManyWithoutSchoolNestedInput
    fees?: FeesUncheckedUpdateManyWithoutSchoolNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutSchoolNestedInput
    kycverification?: KYCVerificationUncheckedUpdateOneWithoutSchoolNestedInput
  }

  export type SchoolCreateManyInput = {
    id?: string
    ownerId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolDirectorVerificationCreateInput = {
    id?: string
    directorFullName: string
    directorIDType: $Enums.DirectorIDType
    directorIDNumber: string
    document: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutSchoolDirectorVerificationInput
  }

  export type SchoolDirectorVerificationUncheckedCreateInput = {
    id?: string
    schoolId: string
    directorFullName: string
    directorIDType: $Enums.DirectorIDType
    directorIDNumber: string
    document: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolDirectorVerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    directorFullName?: StringFieldUpdateOperationsInput | string
    directorIDType?: EnumDirectorIDTypeFieldUpdateOperationsInput | $Enums.DirectorIDType
    directorIDNumber?: StringFieldUpdateOperationsInput | string
    document?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutSchoolDirectorVerificationNestedInput
  }

  export type SchoolDirectorVerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    directorFullName?: StringFieldUpdateOperationsInput | string
    directorIDType?: EnumDirectorIDTypeFieldUpdateOperationsInput | $Enums.DirectorIDType
    directorIDNumber?: StringFieldUpdateOperationsInput | string
    document?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolDirectorVerificationCreateManyInput = {
    id?: string
    schoolId: string
    directorFullName: string
    directorIDType: $Enums.DirectorIDType
    directorIDNumber: string
    document: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolDirectorVerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    directorFullName?: StringFieldUpdateOperationsInput | string
    directorIDType?: EnumDirectorIDTypeFieldUpdateOperationsInput | $Enums.DirectorIDType
    directorIDNumber?: StringFieldUpdateOperationsInput | string
    document?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolDirectorVerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    directorFullName?: StringFieldUpdateOperationsInput | string
    directorIDType?: EnumDirectorIDTypeFieldUpdateOperationsInput | $Enums.DirectorIDType
    directorIDNumber?: StringFieldUpdateOperationsInput | string
    document?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolOwnershipVerificationCreateInput = {
    id?: string
    cacform7: string
    cacShareAllotmentForm: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutSchoolOwnershipVerificationInput
  }

  export type SchoolOwnershipVerificationUncheckedCreateInput = {
    id?: string
    schoolId: string
    cacform7: string
    cacShareAllotmentForm: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolOwnershipVerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cacform7?: StringFieldUpdateOperationsInput | string
    cacShareAllotmentForm?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutSchoolOwnershipVerificationNestedInput
  }

  export type SchoolOwnershipVerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    cacform7?: StringFieldUpdateOperationsInput | string
    cacShareAllotmentForm?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolOwnershipVerificationCreateManyInput = {
    id?: string
    schoolId: string
    cacform7: string
    cacShareAllotmentForm: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolOwnershipVerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cacform7?: StringFieldUpdateOperationsInput | string
    cacShareAllotmentForm?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolOwnershipVerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    cacform7?: StringFieldUpdateOperationsInput | string
    cacShareAllotmentForm?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolVerificationCreateInput = {
    id?: string
    cacCertificate: string
    accreditationDocument: string
    taxIdentificationNumber: string
    licenseDocument: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutSchoolVerificationInput
  }

  export type SchoolVerificationUncheckedCreateInput = {
    id?: string
    schoolId: string
    cacCertificate: string
    accreditationDocument: string
    taxIdentificationNumber: string
    licenseDocument: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolVerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cacCertificate?: StringFieldUpdateOperationsInput | string
    accreditationDocument?: StringFieldUpdateOperationsInput | string
    taxIdentificationNumber?: StringFieldUpdateOperationsInput | string
    licenseDocument?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutSchoolVerificationNestedInput
  }

  export type SchoolVerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    cacCertificate?: StringFieldUpdateOperationsInput | string
    accreditationDocument?: StringFieldUpdateOperationsInput | string
    taxIdentificationNumber?: StringFieldUpdateOperationsInput | string
    licenseDocument?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolVerificationCreateManyInput = {
    id?: string
    schoolId: string
    cacCertificate: string
    accreditationDocument: string
    taxIdentificationNumber: string
    licenseDocument: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolVerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cacCertificate?: StringFieldUpdateOperationsInput | string
    accreditationDocument?: StringFieldUpdateOperationsInput | string
    taxIdentificationNumber?: StringFieldUpdateOperationsInput | string
    licenseDocument?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolVerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    cacCertificate?: StringFieldUpdateOperationsInput | string
    accreditationDocument?: StringFieldUpdateOperationsInput | string
    taxIdentificationNumber?: StringFieldUpdateOperationsInput | string
    licenseDocument?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolPayoutDetailCreateInput = {
    id?: string
    bankName: string
    bankCode: string
    accountNumber: string
    accountName: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutSchoolPayoutDetailInput
  }

  export type SchoolPayoutDetailUncheckedCreateInput = {
    id?: string
    schoolId: string
    bankName: string
    bankCode: string
    accountNumber: string
    accountName: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolPayoutDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutSchoolPayoutDetailNestedInput
  }

  export type SchoolPayoutDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolPayoutDetailCreateManyInput = {
    id?: string
    schoolId: string
    bankName: string
    bankCode: string
    accountNumber: string
    accountName: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolPayoutDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolPayoutDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolAndPlatformLegalAgreementCreateInput = {
    id?: string
    signature: string
    signedAt: Date | string
    legalDocumentRef: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutSchoolAndPlatformLegalAgreementInput
    signedBy: UserCreateNestedOneWithoutSchoolAndPlatformLegalAgreementInput
  }

  export type SchoolAndPlatformLegalAgreementUncheckedCreateInput = {
    id?: string
    schoolId: string
    signedById: string
    signature: string
    signedAt: Date | string
    legalDocumentRef: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolAndPlatformLegalAgreementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    legalDocumentRef?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutSchoolAndPlatformLegalAgreementNestedInput
    signedBy?: UserUpdateOneRequiredWithoutSchoolAndPlatformLegalAgreementNestedInput
  }

  export type SchoolAndPlatformLegalAgreementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    signedById?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    legalDocumentRef?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolAndPlatformLegalAgreementCreateManyInput = {
    id?: string
    schoolId: string
    signedById: string
    signature: string
    signedAt: Date | string
    legalDocumentRef: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolAndPlatformLegalAgreementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    legalDocumentRef?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolAndPlatformLegalAgreementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    signedById?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    legalDocumentRef?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KYCVerificationCreateInput = {
    id?: string
    status?: $Enums.KYCVerificationStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutKycverificationInput
    school: SchoolCreateNestedOneWithoutKycverificationInput
  }

  export type KYCVerificationUncheckedCreateInput = {
    id?: string
    userId: string
    schoolId: string
    status?: $Enums.KYCVerificationStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KYCVerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumKYCVerificationStatusFieldUpdateOperationsInput | $Enums.KYCVerificationStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutKycverificationNestedInput
    school?: SchoolUpdateOneRequiredWithoutKycverificationNestedInput
  }

  export type KYCVerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    status?: EnumKYCVerificationStatusFieldUpdateOperationsInput | $Enums.KYCVerificationStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KYCVerificationCreateManyInput = {
    id?: string
    userId: string
    schoolId: string
    status?: $Enums.KYCVerificationStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KYCVerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumKYCVerificationStatusFieldUpdateOperationsInput | $Enums.KYCVerificationStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KYCVerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    status?: EnumKYCVerificationStatusFieldUpdateOperationsInput | $Enums.KYCVerificationStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassCreateInput = {
    id?: string
    name: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassesInput
    fees?: FeesCreateNestedManyWithoutClassInput
    invoices?: InvoiceCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateInput = {
    id?: string
    name: string
    schoolId: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fees?: FeesUncheckedCreateNestedManyWithoutClassInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    fees?: FeesUpdateManyWithoutClassNestedInput
    invoices?: InvoiceUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fees?: FeesUncheckedUpdateManyWithoutClassNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateManyInput = {
    id?: string
    name: string
    schoolId: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicSessionCreateInput = {
    id?: string
    name: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutAcademicSessionsInput
    fees?: FeesCreateNestedManyWithoutAcademicSessionInput
    invoices?: InvoiceCreateNestedManyWithoutAcademicSessionInput
  }

  export type AcademicSessionUncheckedCreateInput = {
    id?: string
    name: string
    schoolId: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fees?: FeesUncheckedCreateNestedManyWithoutAcademicSessionInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAcademicSessionInput
  }

  export type AcademicSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutAcademicSessionsNestedInput
    fees?: FeesUpdateManyWithoutAcademicSessionNestedInput
    invoices?: InvoiceUpdateManyWithoutAcademicSessionNestedInput
  }

  export type AcademicSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fees?: FeesUncheckedUpdateManyWithoutAcademicSessionNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAcademicSessionNestedInput
  }

  export type AcademicSessionCreateManyInput = {
    id?: string
    name: string
    schoolId: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermCreateInput = {
    id?: string
    name: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutTermsInput
    fees?: FeesCreateNestedManyWithoutTermInput
    invoices?: InvoiceCreateNestedManyWithoutTermInput
  }

  export type TermUncheckedCreateInput = {
    id?: string
    name: string
    schoolId: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fees?: FeesUncheckedCreateNestedManyWithoutTermInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTermInput
  }

  export type TermUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutTermsNestedInput
    fees?: FeesUpdateManyWithoutTermNestedInput
    invoices?: InvoiceUpdateManyWithoutTermNestedInput
  }

  export type TermUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fees?: FeesUncheckedUpdateManyWithoutTermNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTermNestedInput
  }

  export type TermCreateManyInput = {
    id?: string
    name: string
    schoolId: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TermUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeesCreateInput = {
    id?: string
    dueAt: Date | string
    latePaymentFee?: Decimal | DecimalJsLike | number | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutFeesInput
    academicSession: AcademicSessionCreateNestedOneWithoutFeesInput
    term: TermCreateNestedOneWithoutFeesInput
    school: SchoolCreateNestedOneWithoutFeesInput
    feeBreakdowns?: FeeBreakdownCreateNestedManyWithoutFeeInput
  }

  export type FeesUncheckedCreateInput = {
    id?: string
    dueAt: Date | string
    latePaymentFee?: Decimal | DecimalJsLike | number | string
    schoolId: string
    classId: string
    sessionId: string
    termId: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    feeBreakdowns?: FeeBreakdownUncheckedCreateNestedManyWithoutFeeInput
  }

  export type FeesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latePaymentFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutFeesNestedInput
    academicSession?: AcademicSessionUpdateOneRequiredWithoutFeesNestedInput
    term?: TermUpdateOneRequiredWithoutFeesNestedInput
    school?: SchoolUpdateOneRequiredWithoutFeesNestedInput
    feeBreakdowns?: FeeBreakdownUpdateManyWithoutFeeNestedInput
  }

  export type FeesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latePaymentFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feeBreakdowns?: FeeBreakdownUncheckedUpdateManyWithoutFeeNestedInput
  }

  export type FeesCreateManyInput = {
    id?: string
    dueAt: Date | string
    latePaymentFee?: Decimal | DecimalJsLike | number | string
    schoolId: string
    classId: string
    sessionId: string
    termId: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latePaymentFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latePaymentFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeBreakdownCreateInput = {
    id?: string
    title: string
    amount?: Decimal | DecimalJsLike | number | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fee: FeesCreateNestedOneWithoutFeeBreakdownsInput
  }

  export type FeeBreakdownUncheckedCreateInput = {
    id?: string
    feeId: string
    title: string
    amount?: Decimal | DecimalJsLike | number | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeeBreakdownUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fee?: FeesUpdateOneRequiredWithoutFeeBreakdownsNestedInput
  }

  export type FeeBreakdownUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeBreakdownCreateManyInput = {
    id?: string
    feeId: string
    title: string
    amount?: Decimal | DecimalJsLike | number | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeeBreakdownUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeBreakdownUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceNo: string
    feeId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueAt: Date | string
    paidAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    guardian: GuardianCreateNestedOneWithoutInvoicesInput
    class: ClassCreateNestedOneWithoutInvoicesInput
    academicSession: AcademicSessionCreateNestedOneWithoutInvoicesInput
    term: TermCreateNestedOneWithoutInvoicesInput
    transactions?: TransactionCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    invoiceNo: string
    feeId: string
    guardianId: string
    classId: string
    sessionId: string
    termId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueAt: Date | string
    paidAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    feeId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guardian?: GuardianUpdateOneRequiredWithoutInvoicesNestedInput
    class?: ClassUpdateOneRequiredWithoutInvoicesNestedInput
    academicSession?: AcademicSessionUpdateOneRequiredWithoutInvoicesNestedInput
    term?: TermUpdateOneRequiredWithoutInvoicesNestedInput
    transactions?: TransactionUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    feeId?: StringFieldUpdateOperationsInput | string
    guardianId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    invoiceNo: string
    feeId: string
    guardianId: string
    classId: string
    sessionId: string
    termId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueAt: Date | string
    paidAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    feeId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    feeId?: StringFieldUpdateOperationsInput | string
    guardianId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    registrationNumber: string
    status?: $Enums.StudentStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutStudentsInput
    guardian?: GuardianCreateNestedOneWithoutStudentsInput
    linkedStudentProfile?: LinkedStudentProfileCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    classId: string
    guardianId?: string | null
    registrationNumber: string
    status?: $Enums.StudentStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    linkedStudentProfile?: LinkedStudentProfileUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutStudentsNestedInput
    guardian?: GuardianUpdateOneWithoutStudentsNestedInput
    linkedStudentProfile?: LinkedStudentProfileUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: StringFieldUpdateOperationsInput | string
    guardianId?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkedStudentProfile?: LinkedStudentProfileUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    classId: string
    guardianId?: string | null
    registrationNumber: string
    status?: $Enums.StudentStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: StringFieldUpdateOperationsInput | string
    guardianId?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkedStudentProfileCreateInput = {
    id?: string
    lastGuardiantChanged: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutLinkedStudentProfileInput
    guardian: GuardianCreateNestedOneWithoutLinkedStudentProfilesInput
  }

  export type LinkedStudentProfileUncheckedCreateInput = {
    id?: string
    studentId: string
    guardianId: string
    lastGuardiantChanged: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LinkedStudentProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastGuardiantChanged?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutLinkedStudentProfileNestedInput
    guardian?: GuardianUpdateOneRequiredWithoutLinkedStudentProfilesNestedInput
  }

  export type LinkedStudentProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    guardianId?: StringFieldUpdateOperationsInput | string
    lastGuardiantChanged?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkedStudentProfileCreateManyInput = {
    id?: string
    studentId: string
    guardianId: string
    lastGuardiantChanged: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LinkedStudentProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastGuardiantChanged?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkedStudentProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    guardianId?: StringFieldUpdateOperationsInput | string
    lastGuardiantChanged?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    reference: string
    amount?: Decimal | DecimalJsLike | number | string
    fees?: Decimal | DecimalJsLike | number | string
    status?: $Enums.TransactionStatus
    transactionAt?: Date | string | null
    processedAt?: Date | string | null
    description?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutTransactionsInput
    guardian: GuardianCreateNestedOneWithoutTransactionsInput
    transactionFee?: TransactionFeeCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    guardianId: string
    invoiceId: string
    reference: string
    amount?: Decimal | DecimalJsLike | number | string
    fees?: Decimal | DecimalJsLike | number | string
    status?: $Enums.TransactionStatus
    transactionAt?: Date | string | null
    processedAt?: Date | string | null
    description?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionFee?: TransactionFeeUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    transactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutTransactionsNestedInput
    guardian?: GuardianUpdateOneRequiredWithoutTransactionsNestedInput
    transactionFee?: TransactionFeeUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    guardianId?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    transactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionFee?: TransactionFeeUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionCreateManyInput = {
    id?: string
    guardianId: string
    invoiceId: string
    reference: string
    amount?: Decimal | DecimalJsLike | number | string
    fees?: Decimal | DecimalJsLike | number | string
    status?: $Enums.TransactionStatus
    transactionAt?: Date | string | null
    processedAt?: Date | string | null
    description?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    transactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    guardianId?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    transactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionFeeCreateInput = {
    id?: string
    platformFee?: Decimal | DecimalJsLike | number | string
    latePaymentFee?: Decimal | DecimalJsLike | number | string
    processingFee?: Decimal | DecimalJsLike | number | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutTransactionFeeInput
  }

  export type TransactionFeeUncheckedCreateInput = {
    id?: string
    transactionId: string
    platformFee?: Decimal | DecimalJsLike | number | string
    latePaymentFee?: Decimal | DecimalJsLike | number | string
    processingFee?: Decimal | DecimalJsLike | number | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionFeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    latePaymentFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    processingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutTransactionFeeNestedInput
  }

  export type TransactionFeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    platformFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    latePaymentFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    processingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionFeeCreateManyInput = {
    id?: string
    transactionId: string
    platformFee?: Decimal | DecimalJsLike | number | string
    latePaymentFee?: Decimal | DecimalJsLike | number | string
    processingFee?: Decimal | DecimalJsLike | number | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionFeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    latePaymentFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    processingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionFeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    platformFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    latePaymentFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    processingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayoutCreateInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string
    processingFee?: Decimal | DecimalJsLike | number | string
    status?: $Enums.PayoutStatus
    initiatedAt: Date | string
    completedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutPayoutsInput
  }

  export type PayoutUncheckedCreateInput = {
    id?: string
    schoolId: string
    amount?: Decimal | DecimalJsLike | number | string
    processingFee?: Decimal | DecimalJsLike | number | string
    status?: $Enums.PayoutStatus
    initiatedAt: Date | string
    completedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayoutUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    processingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutPayoutsNestedInput
  }

  export type PayoutUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    processingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayoutCreateManyInput = {
    id?: string
    schoolId: string
    amount?: Decimal | DecimalJsLike | number | string
    processingFee?: Decimal | DecimalJsLike | number | string
    status?: $Enums.PayoutStatus
    initiatedAt: Date | string
    completedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayoutUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    processingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayoutUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    processingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    status?: $Enums.NotificationStatus
    sentAt: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    message: string
    status?: $Enums.NotificationStatus
    sentAt: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    title: string
    message: string
    status?: $Enums.NotificationStatus
    sentAt: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletCreateInput = {
    id?: string
    address: string
    name: string
    tag: string
    routingNumber: string
    balance: string
    status?: $Enums.WalletStatus
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWalletInput
    Ledger?: LedgerCreateNestedManyWithoutWalletInput
    Transaction?: WalletTransactionCreateNestedManyWithoutWalletInput
  }

  export type WalletUncheckedCreateInput = {
    id?: string
    userId: string
    address: string
    name: string
    tag: string
    routingNumber: string
    balance: string
    status?: $Enums.WalletStatus
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
    Ledger?: LedgerUncheckedCreateNestedManyWithoutWalletInput
    Transaction?: WalletTransactionUncheckedCreateNestedManyWithoutWalletInput
  }

  export type WalletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    routingNumber?: StringFieldUpdateOperationsInput | string
    balance?: StringFieldUpdateOperationsInput | string
    status?: EnumWalletStatusFieldUpdateOperationsInput | $Enums.WalletStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWalletNestedInput
    Ledger?: LedgerUpdateManyWithoutWalletNestedInput
    Transaction?: WalletTransactionUpdateManyWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    routingNumber?: StringFieldUpdateOperationsInput | string
    balance?: StringFieldUpdateOperationsInput | string
    status?: EnumWalletStatusFieldUpdateOperationsInput | $Enums.WalletStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ledger?: LedgerUncheckedUpdateManyWithoutWalletNestedInput
    Transaction?: WalletTransactionUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type WalletCreateManyInput = {
    id?: string
    userId: string
    address: string
    name: string
    tag: string
    routingNumber: string
    balance: string
    status?: $Enums.WalletStatus
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type WalletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    routingNumber?: StringFieldUpdateOperationsInput | string
    balance?: StringFieldUpdateOperationsInput | string
    status?: EnumWalletStatusFieldUpdateOperationsInput | $Enums.WalletStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    routingNumber?: StringFieldUpdateOperationsInput | string
    balance?: StringFieldUpdateOperationsInput | string
    status?: EnumWalletStatusFieldUpdateOperationsInput | $Enums.WalletStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionCreateInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string
    fees?: Decimal | DecimalJsLike | number | string
    netAmount?: Decimal | DecimalJsLike | number | string
    reference: string
    type: $Enums.TransactionType
    flow: $Enums.TransactionFlow
    transactionAt?: Date | string | null
    processedAt?: Date | string | null
    desc?: string | null
    status?: $Enums.TransactionStatus
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
    wallet: WalletCreateNestedOneWithoutTransactionInput
    ledger?: LedgerCreateNestedOneWithoutTransactionInput
  }

  export type WalletTransactionUncheckedCreateInput = {
    id?: string
    walletId: string
    amount?: Decimal | DecimalJsLike | number | string
    fees?: Decimal | DecimalJsLike | number | string
    netAmount?: Decimal | DecimalJsLike | number | string
    reference: string
    type: $Enums.TransactionType
    flow: $Enums.TransactionFlow
    transactionAt?: Date | string | null
    processedAt?: Date | string | null
    desc?: string | null
    status?: $Enums.TransactionStatus
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
    ledger?: LedgerUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type WalletTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    flow?: EnumTransactionFlowFieldUpdateOperationsInput | $Enums.TransactionFlow
    transactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet?: WalletUpdateOneRequiredWithoutTransactionNestedInput
    ledger?: LedgerUpdateOneWithoutTransactionNestedInput
  }

  export type WalletTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    flow?: EnumTransactionFlowFieldUpdateOperationsInput | $Enums.TransactionFlow
    transactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledger?: LedgerUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type WalletTransactionCreateManyInput = {
    id?: string
    walletId: string
    amount?: Decimal | DecimalJsLike | number | string
    fees?: Decimal | DecimalJsLike | number | string
    netAmount?: Decimal | DecimalJsLike | number | string
    reference: string
    type: $Enums.TransactionType
    flow: $Enums.TransactionFlow
    transactionAt?: Date | string | null
    processedAt?: Date | string | null
    desc?: string | null
    status?: $Enums.TransactionStatus
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type WalletTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    flow?: EnumTransactionFlowFieldUpdateOperationsInput | $Enums.TransactionFlow
    transactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    flow?: EnumTransactionFlowFieldUpdateOperationsInput | $Enums.TransactionFlow
    transactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerCreateInput = {
    id?: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    balanceBefore?: Decimal | DecimalJsLike | number | string
    balanceAfter?: Decimal | DecimalJsLike | number | string
    description?: string | null
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
    wallet: WalletCreateNestedOneWithoutLedgerInput
    transaction: WalletTransactionCreateNestedOneWithoutLedgerInput
  }

  export type LedgerUncheckedCreateInput = {
    id?: string
    walletId: string
    transactionId: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    balanceBefore?: Decimal | DecimalJsLike | number | string
    balanceAfter?: Decimal | DecimalJsLike | number | string
    description?: string | null
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type LedgerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet?: WalletUpdateOneRequiredWithoutLedgerNestedInput
    transaction?: WalletTransactionUpdateOneRequiredWithoutLedgerNestedInput
  }

  export type LedgerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerCreateManyInput = {
    id?: string
    walletId: string
    transactionId: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    balanceBefore?: Decimal | DecimalJsLike | number | string
    balanceAfter?: Decimal | DecimalJsLike | number | string
    description?: string | null
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type LedgerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FirebaseTokenCreateInput = {
    id?: string
    token?: string | null
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFirebaseTokenInput
  }

  export type FirebaseTokenUncheckedCreateInput = {
    id?: string
    userId: string
    token?: string | null
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type FirebaseTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFirebaseTokenNestedInput
  }

  export type FirebaseTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FirebaseTokenCreateManyInput = {
    id?: string
    userId: string
    token?: string | null
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type FirebaseTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FirebaseTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type EnumAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusFilter<$PrismaModel> | $Enums.AccountStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AdministratorNullableScalarRelationFilter = {
    is?: AdministratorWhereInput | null
    isNot?: AdministratorWhereInput | null
  }

  export type GuardianNullableScalarRelationFilter = {
    is?: GuardianWhereInput | null
    isNot?: GuardianWhereInput | null
  }

  export type VerificationListRelationFilter = {
    every?: VerificationWhereInput
    some?: VerificationWhereInput
    none?: VerificationWhereInput
  }

  export type SchoolNullableScalarRelationFilter = {
    is?: SchoolWhereInput | null
    isNot?: SchoolWhereInput | null
  }

  export type SchoolAndPlatformLegalAgreementNullableScalarRelationFilter = {
    is?: SchoolAndPlatformLegalAgreementWhereInput | null
    isNot?: SchoolAndPlatformLegalAgreementWhereInput | null
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type CredentialNullableScalarRelationFilter = {
    is?: CredentialWhereInput | null
    isNot?: CredentialWhereInput | null
  }

  export type WalletNullableScalarRelationFilter = {
    is?: WalletWhereInput | null
    isNot?: WalletWhereInput | null
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type FirebaseTokenNullableScalarRelationFilter = {
    is?: FirebaseTokenWhereInput | null
    isNot?: FirebaseTokenWhereInput | null
  }

  export type KYCVerificationNullableScalarRelationFilter = {
    is?: KYCVerificationWhereInput | null
    isNot?: KYCVerificationWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type VerificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    type?: SortOrder
    phone?: SortOrder
    accountStatus?: SortOrder
    verifiedAt?: SortOrder
    lastSeenAt?: SortOrder
    isTermsAccepted?: SortOrder
    isPrivacyAccepted?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    type?: SortOrder
    phone?: SortOrder
    accountStatus?: SortOrder
    verifiedAt?: SortOrder
    lastSeenAt?: SortOrder
    isTermsAccepted?: SortOrder
    isPrivacyAccepted?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    type?: SortOrder
    phone?: SortOrder
    accountStatus?: SortOrder
    verifiedAt?: SortOrder
    lastSeenAt?: SortOrder
    isTermsAccepted?: SortOrder
    isPrivacyAccepted?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type EnumAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CredentialCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    password?: SortOrder
    pinCode?: SortOrder
    lastResetAt?: SortOrder
    lastUsedAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CredentialMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    password?: SortOrder
    pinCode?: SortOrder
    lastResetAt?: SortOrder
    lastUsedAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CredentialMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    password?: SortOrder
    pinCode?: SortOrder
    lastResetAt?: SortOrder
    lastUsedAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AdministratorCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdministratorMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdministratorMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type LinkedStudentProfileListRelationFilter = {
    every?: LinkedStudentProfileWhereInput
    some?: LinkedStudentProfileWhereInput
    none?: LinkedStudentProfileWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LinkedStudentProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GuardianCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GuardianMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GuardianMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumVerificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationType | EnumVerificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationType[] | ListEnumVerificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationType[] | ListEnumVerificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationTypeFilter<$PrismaModel> | $Enums.VerificationType
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    resendCount?: SortOrder
    used?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationAvgOrderByAggregateInput = {
    resendCount?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    resendCount?: SortOrder
    used?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    resendCount?: SortOrder
    used?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationSumOrderByAggregateInput = {
    resendCount?: SortOrder
  }

  export type EnumVerificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationType | EnumVerificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationType[] | ListEnumVerificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationType[] | ListEnumVerificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.VerificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationTypeFilter<$PrismaModel>
    _max?: NestedEnumVerificationTypeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumSchoolTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SchoolType | EnumSchoolTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SchoolType[] | ListEnumSchoolTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SchoolType[] | ListEnumSchoolTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSchoolTypeFilter<$PrismaModel> | $Enums.SchoolType
  }

  export type EnumSchoolOwnershipFilter<$PrismaModel = never> = {
    equals?: $Enums.SchoolOwnership | EnumSchoolOwnershipFieldRefInput<$PrismaModel>
    in?: $Enums.SchoolOwnership[] | ListEnumSchoolOwnershipFieldRefInput<$PrismaModel>
    notIn?: $Enums.SchoolOwnership[] | ListEnumSchoolOwnershipFieldRefInput<$PrismaModel>
    not?: NestedEnumSchoolOwnershipFilter<$PrismaModel> | $Enums.SchoolOwnership
  }

  export type EnumSchoolStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SchoolStatus | EnumSchoolStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SchoolStatus[] | ListEnumSchoolStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SchoolStatus[] | ListEnumSchoolStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSchoolStatusFilter<$PrismaModel> | $Enums.SchoolStatus
  }

  export type SchoolDirectorVerificationNullableScalarRelationFilter = {
    is?: SchoolDirectorVerificationWhereInput | null
    isNot?: SchoolDirectorVerificationWhereInput | null
  }

  export type SchoolOwnershipVerificationNullableScalarRelationFilter = {
    is?: SchoolOwnershipVerificationWhereInput | null
    isNot?: SchoolOwnershipVerificationWhereInput | null
  }

  export type SchoolVerificationNullableScalarRelationFilter = {
    is?: SchoolVerificationWhereInput | null
    isNot?: SchoolVerificationWhereInput | null
  }

  export type SchoolPayoutDetailNullableScalarRelationFilter = {
    is?: SchoolPayoutDetailWhereInput | null
    isNot?: SchoolPayoutDetailWhereInput | null
  }

  export type ClassListRelationFilter = {
    every?: ClassWhereInput
    some?: ClassWhereInput
    none?: ClassWhereInput
  }

  export type AcademicSessionListRelationFilter = {
    every?: AcademicSessionWhereInput
    some?: AcademicSessionWhereInput
    none?: AcademicSessionWhereInput
  }

  export type TermListRelationFilter = {
    every?: TermWhereInput
    some?: TermWhereInput
    none?: TermWhereInput
  }

  export type FeesListRelationFilter = {
    every?: FeesWhereInput
    some?: FeesWhereInput
    none?: FeesWhereInput
  }

  export type PayoutListRelationFilter = {
    every?: PayoutWhereInput
    some?: PayoutWhereInput
    none?: PayoutWhereInput
  }

  export type ClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcademicSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TermOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayoutOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    lga?: SortOrder
    postalCode?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    establishedYear?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    schoolType?: SortOrder
    ownership?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolAvgOrderByAggregateInput = {
    establishedYear?: SortOrder
  }

  export type SchoolMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    lga?: SortOrder
    postalCode?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    establishedYear?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    schoolType?: SortOrder
    ownership?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    lga?: SortOrder
    postalCode?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    establishedYear?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    schoolType?: SortOrder
    ownership?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolSumOrderByAggregateInput = {
    establishedYear?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumSchoolTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SchoolType | EnumSchoolTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SchoolType[] | ListEnumSchoolTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SchoolType[] | ListEnumSchoolTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSchoolTypeWithAggregatesFilter<$PrismaModel> | $Enums.SchoolType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSchoolTypeFilter<$PrismaModel>
    _max?: NestedEnumSchoolTypeFilter<$PrismaModel>
  }

  export type EnumSchoolOwnershipWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SchoolOwnership | EnumSchoolOwnershipFieldRefInput<$PrismaModel>
    in?: $Enums.SchoolOwnership[] | ListEnumSchoolOwnershipFieldRefInput<$PrismaModel>
    notIn?: $Enums.SchoolOwnership[] | ListEnumSchoolOwnershipFieldRefInput<$PrismaModel>
    not?: NestedEnumSchoolOwnershipWithAggregatesFilter<$PrismaModel> | $Enums.SchoolOwnership
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSchoolOwnershipFilter<$PrismaModel>
    _max?: NestedEnumSchoolOwnershipFilter<$PrismaModel>
  }

  export type EnumSchoolStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SchoolStatus | EnumSchoolStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SchoolStatus[] | ListEnumSchoolStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SchoolStatus[] | ListEnumSchoolStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSchoolStatusWithAggregatesFilter<$PrismaModel> | $Enums.SchoolStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSchoolStatusFilter<$PrismaModel>
    _max?: NestedEnumSchoolStatusFilter<$PrismaModel>
  }

  export type EnumDirectorIDTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DirectorIDType | EnumDirectorIDTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DirectorIDType[] | ListEnumDirectorIDTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DirectorIDType[] | ListEnumDirectorIDTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectorIDTypeFilter<$PrismaModel> | $Enums.DirectorIDType
  }

  export type SchoolScalarRelationFilter = {
    is?: SchoolWhereInput
    isNot?: SchoolWhereInput
  }

  export type SchoolDirectorVerificationCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    directorFullName?: SortOrder
    directorIDType?: SortOrder
    directorIDNumber?: SortOrder
    document?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolDirectorVerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    directorFullName?: SortOrder
    directorIDType?: SortOrder
    directorIDNumber?: SortOrder
    document?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolDirectorVerificationMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    directorFullName?: SortOrder
    directorIDType?: SortOrder
    directorIDNumber?: SortOrder
    document?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDirectorIDTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DirectorIDType | EnumDirectorIDTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DirectorIDType[] | ListEnumDirectorIDTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DirectorIDType[] | ListEnumDirectorIDTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectorIDTypeWithAggregatesFilter<$PrismaModel> | $Enums.DirectorIDType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDirectorIDTypeFilter<$PrismaModel>
    _max?: NestedEnumDirectorIDTypeFilter<$PrismaModel>
  }

  export type SchoolOwnershipVerificationCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    cacform7?: SortOrder
    cacShareAllotmentForm?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolOwnershipVerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    cacform7?: SortOrder
    cacShareAllotmentForm?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolOwnershipVerificationMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    cacform7?: SortOrder
    cacShareAllotmentForm?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolVerificationCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    cacCertificate?: SortOrder
    accreditationDocument?: SortOrder
    taxIdentificationNumber?: SortOrder
    licenseDocument?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolVerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    cacCertificate?: SortOrder
    accreditationDocument?: SortOrder
    taxIdentificationNumber?: SortOrder
    licenseDocument?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolVerificationMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    cacCertificate?: SortOrder
    accreditationDocument?: SortOrder
    taxIdentificationNumber?: SortOrder
    licenseDocument?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolPayoutDetailCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    bankName?: SortOrder
    bankCode?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolPayoutDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    bankName?: SortOrder
    bankCode?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolPayoutDetailMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    bankName?: SortOrder
    bankCode?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolAndPlatformLegalAgreementCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    signedById?: SortOrder
    signature?: SortOrder
    signedAt?: SortOrder
    legalDocumentRef?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolAndPlatformLegalAgreementMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    signedById?: SortOrder
    signature?: SortOrder
    signedAt?: SortOrder
    legalDocumentRef?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolAndPlatformLegalAgreementMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    signedById?: SortOrder
    signature?: SortOrder
    signedAt?: SortOrder
    legalDocumentRef?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumKYCVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCVerificationStatus | EnumKYCVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCVerificationStatus[] | ListEnumKYCVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCVerificationStatus[] | ListEnumKYCVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCVerificationStatusFilter<$PrismaModel> | $Enums.KYCVerificationStatus
  }

  export type KYCVerificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    schoolId?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KYCVerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    schoolId?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KYCVerificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    schoolId?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumKYCVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCVerificationStatus | EnumKYCVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCVerificationStatus[] | ListEnumKYCVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCVerificationStatus[] | ListEnumKYCVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.KYCVerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKYCVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumKYCVerificationStatusFilter<$PrismaModel>
  }

  export type ClassCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicSessionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicSessionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TermCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TermMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TermMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    schoolId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ClassScalarRelationFilter = {
    is?: ClassWhereInput
    isNot?: ClassWhereInput
  }

  export type AcademicSessionScalarRelationFilter = {
    is?: AcademicSessionWhereInput
    isNot?: AcademicSessionWhereInput
  }

  export type TermScalarRelationFilter = {
    is?: TermWhereInput
    isNot?: TermWhereInput
  }

  export type FeeBreakdownListRelationFilter = {
    every?: FeeBreakdownWhereInput
    some?: FeeBreakdownWhereInput
    none?: FeeBreakdownWhereInput
  }

  export type FeeBreakdownOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeesCountOrderByAggregateInput = {
    id?: SortOrder
    dueAt?: SortOrder
    latePaymentFee?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    sessionId?: SortOrder
    termId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeesAvgOrderByAggregateInput = {
    latePaymentFee?: SortOrder
  }

  export type FeesMaxOrderByAggregateInput = {
    id?: SortOrder
    dueAt?: SortOrder
    latePaymentFee?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    sessionId?: SortOrder
    termId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeesMinOrderByAggregateInput = {
    id?: SortOrder
    dueAt?: SortOrder
    latePaymentFee?: SortOrder
    schoolId?: SortOrder
    classId?: SortOrder
    sessionId?: SortOrder
    termId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeesSumOrderByAggregateInput = {
    latePaymentFee?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type FeesScalarRelationFilter = {
    is?: FeesWhereInput
    isNot?: FeesWhereInput
  }

  export type FeeBreakdownCountOrderByAggregateInput = {
    id?: SortOrder
    feeId?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeBreakdownAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FeeBreakdownMaxOrderByAggregateInput = {
    id?: SortOrder
    feeId?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeBreakdownMinOrderByAggregateInput = {
    id?: SortOrder
    feeId?: SortOrder
    title?: SortOrder
    amount?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeBreakdownSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type GuardianScalarRelationFilter = {
    is?: GuardianWhereInput
    isNot?: GuardianWhereInput
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    feeId?: SortOrder
    guardianId?: SortOrder
    classId?: SortOrder
    sessionId?: SortOrder
    termId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    dueAt?: SortOrder
    paidAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    feeId?: SortOrder
    guardianId?: SortOrder
    classId?: SortOrder
    sessionId?: SortOrder
    termId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    dueAt?: SortOrder
    paidAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNo?: SortOrder
    feeId?: SortOrder
    guardianId?: SortOrder
    classId?: SortOrder
    sessionId?: SortOrder
    termId?: SortOrder
    totalAmount?: SortOrder
    status?: SortOrder
    dueAt?: SortOrder
    paidAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type EnumStudentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentStatus | EnumStudentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentStatusFilter<$PrismaModel> | $Enums.StudentStatus
  }

  export type LinkedStudentProfileNullableScalarRelationFilter = {
    is?: LinkedStudentProfileWhereInput | null
    isNot?: LinkedStudentProfileWhereInput | null
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    image?: SortOrder
    classId?: SortOrder
    guardianId?: SortOrder
    registrationNumber?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    image?: SortOrder
    classId?: SortOrder
    guardianId?: SortOrder
    registrationNumber?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    image?: SortOrder
    classId?: SortOrder
    guardianId?: SortOrder
    registrationNumber?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStudentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentStatus | EnumStudentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentStatusWithAggregatesFilter<$PrismaModel> | $Enums.StudentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStudentStatusFilter<$PrismaModel>
    _max?: NestedEnumStudentStatusFilter<$PrismaModel>
  }

  export type StudentScalarRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type LinkedStudentProfileCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    guardianId?: SortOrder
    lastGuardiantChanged?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LinkedStudentProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    guardianId?: SortOrder
    lastGuardiantChanged?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LinkedStudentProfileMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    guardianId?: SortOrder
    lastGuardiantChanged?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type InvoiceScalarRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type TransactionFeeNullableScalarRelationFilter = {
    is?: TransactionFeeWhereInput | null
    isNot?: TransactionFeeWhereInput | null
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    guardianId?: SortOrder
    invoiceId?: SortOrder
    reference?: SortOrder
    amount?: SortOrder
    fees?: SortOrder
    status?: SortOrder
    transactionAt?: SortOrder
    processedAt?: SortOrder
    description?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    fees?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    guardianId?: SortOrder
    invoiceId?: SortOrder
    reference?: SortOrder
    amount?: SortOrder
    fees?: SortOrder
    status?: SortOrder
    transactionAt?: SortOrder
    processedAt?: SortOrder
    description?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    guardianId?: SortOrder
    invoiceId?: SortOrder
    reference?: SortOrder
    amount?: SortOrder
    fees?: SortOrder
    status?: SortOrder
    transactionAt?: SortOrder
    processedAt?: SortOrder
    description?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    fees?: SortOrder
  }

  export type EnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type TransactionScalarRelationFilter = {
    is?: TransactionWhereInput
    isNot?: TransactionWhereInput
  }

  export type TransactionFeeCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    platformFee?: SortOrder
    latePaymentFee?: SortOrder
    processingFee?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionFeeAvgOrderByAggregateInput = {
    platformFee?: SortOrder
    latePaymentFee?: SortOrder
    processingFee?: SortOrder
  }

  export type TransactionFeeMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    platformFee?: SortOrder
    latePaymentFee?: SortOrder
    processingFee?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionFeeMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    platformFee?: SortOrder
    latePaymentFee?: SortOrder
    processingFee?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionFeeSumOrderByAggregateInput = {
    platformFee?: SortOrder
    latePaymentFee?: SortOrder
    processingFee?: SortOrder
  }

  export type EnumPayoutStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusFilter<$PrismaModel> | $Enums.PayoutStatus
  }

  export type PayoutCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    amount?: SortOrder
    processingFee?: SortOrder
    status?: SortOrder
    initiatedAt?: SortOrder
    completedAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayoutAvgOrderByAggregateInput = {
    amount?: SortOrder
    processingFee?: SortOrder
  }

  export type PayoutMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    amount?: SortOrder
    processingFee?: SortOrder
    status?: SortOrder
    initiatedAt?: SortOrder
    completedAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayoutMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    amount?: SortOrder
    processingFee?: SortOrder
    status?: SortOrder
    initiatedAt?: SortOrder
    completedAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayoutSumOrderByAggregateInput = {
    amount?: SortOrder
    processingFee?: SortOrder
  }

  export type EnumPayoutStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayoutStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayoutStatusFilter<$PrismaModel>
    _max?: NestedEnumPayoutStatusFilter<$PrismaModel>
  }

  export type EnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type EnumWalletStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WalletStatus | EnumWalletStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WalletStatus[] | ListEnumWalletStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WalletStatus[] | ListEnumWalletStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWalletStatusFilter<$PrismaModel> | $Enums.WalletStatus
  }

  export type LedgerListRelationFilter = {
    every?: LedgerWhereInput
    some?: LedgerWhereInput
    none?: LedgerWhereInput
  }

  export type WalletTransactionListRelationFilter = {
    every?: WalletTransactionWhereInput
    some?: WalletTransactionWhereInput
    none?: WalletTransactionWhereInput
  }

  export type LedgerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WalletTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WalletCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrder
    name?: SortOrder
    tag?: SortOrder
    routingNumber?: SortOrder
    balance?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrder
    name?: SortOrder
    tag?: SortOrder
    routingNumber?: SortOrder
    balance?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrder
    name?: SortOrder
    tag?: SortOrder
    routingNumber?: SortOrder
    balance?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumWalletStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WalletStatus | EnumWalletStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WalletStatus[] | ListEnumWalletStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WalletStatus[] | ListEnumWalletStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWalletStatusWithAggregatesFilter<$PrismaModel> | $Enums.WalletStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWalletStatusFilter<$PrismaModel>
    _max?: NestedEnumWalletStatusFilter<$PrismaModel>
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type EnumTransactionFlowFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionFlow | EnumTransactionFlowFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionFlow[] | ListEnumTransactionFlowFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionFlow[] | ListEnumTransactionFlowFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionFlowFilter<$PrismaModel> | $Enums.TransactionFlow
  }

  export type WalletScalarRelationFilter = {
    is?: WalletWhereInput
    isNot?: WalletWhereInput
  }

  export type LedgerNullableScalarRelationFilter = {
    is?: LedgerWhereInput | null
    isNot?: LedgerWhereInput | null
  }

  export type WalletTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    fees?: SortOrder
    netAmount?: SortOrder
    reference?: SortOrder
    type?: SortOrder
    flow?: SortOrder
    transactionAt?: SortOrder
    processedAt?: SortOrder
    desc?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    fees?: SortOrder
    netAmount?: SortOrder
  }

  export type WalletTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    fees?: SortOrder
    netAmount?: SortOrder
    reference?: SortOrder
    type?: SortOrder
    flow?: SortOrder
    transactionAt?: SortOrder
    processedAt?: SortOrder
    desc?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    fees?: SortOrder
    netAmount?: SortOrder
    reference?: SortOrder
    type?: SortOrder
    flow?: SortOrder
    transactionAt?: SortOrder
    processedAt?: SortOrder
    desc?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    fees?: SortOrder
    netAmount?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumTransactionFlowWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionFlow | EnumTransactionFlowFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionFlow[] | ListEnumTransactionFlowFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionFlow[] | ListEnumTransactionFlowFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionFlowWithAggregatesFilter<$PrismaModel> | $Enums.TransactionFlow
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionFlowFilter<$PrismaModel>
    _max?: NestedEnumTransactionFlowFilter<$PrismaModel>
  }

  export type WalletTransactionScalarRelationFilter = {
    is?: WalletTransactionWhereInput
    isNot?: WalletTransactionWhereInput
  }

  export type LedgerCountOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    transactionId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    description?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LedgerAvgOrderByAggregateInput = {
    debit?: SortOrder
    credit?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
  }

  export type LedgerMaxOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    transactionId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    description?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LedgerMinOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    transactionId?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
    description?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LedgerSumOrderByAggregateInput = {
    debit?: SortOrder
    credit?: SortOrder
    balanceBefore?: SortOrder
    balanceAfter?: SortOrder
  }

  export type FirebaseTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type FirebaseTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type FirebaseTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    isDeleted?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AdministratorCreateNestedOneWithoutUserInput = {
    create?: XOR<AdministratorCreateWithoutUserInput, AdministratorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdministratorCreateOrConnectWithoutUserInput
    connect?: AdministratorWhereUniqueInput
  }

  export type GuardianCreateNestedOneWithoutUserInput = {
    create?: XOR<GuardianCreateWithoutUserInput, GuardianUncheckedCreateWithoutUserInput>
    connectOrCreate?: GuardianCreateOrConnectWithoutUserInput
    connect?: GuardianWhereUniqueInput
  }

  export type VerificationCreateNestedManyWithoutUserInput = {
    create?: XOR<VerificationCreateWithoutUserInput, VerificationUncheckedCreateWithoutUserInput> | VerificationCreateWithoutUserInput[] | VerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationCreateOrConnectWithoutUserInput | VerificationCreateOrConnectWithoutUserInput[]
    createMany?: VerificationCreateManyUserInputEnvelope
    connect?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
  }

  export type SchoolCreateNestedOneWithoutOwnerInput = {
    create?: XOR<SchoolCreateWithoutOwnerInput, SchoolUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutOwnerInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolAndPlatformLegalAgreementCreateNestedOneWithoutSignedByInput = {
    create?: XOR<SchoolAndPlatformLegalAgreementCreateWithoutSignedByInput, SchoolAndPlatformLegalAgreementUncheckedCreateWithoutSignedByInput>
    connectOrCreate?: SchoolAndPlatformLegalAgreementCreateOrConnectWithoutSignedByInput
    connect?: SchoolAndPlatformLegalAgreementWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CredentialCreateNestedOneWithoutUserInput = {
    create?: XOR<CredentialCreateWithoutUserInput, CredentialUncheckedCreateWithoutUserInput>
    connectOrCreate?: CredentialCreateOrConnectWithoutUserInput
    connect?: CredentialWhereUniqueInput
  }

  export type WalletCreateNestedOneWithoutUserInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    connect?: WalletWhereUniqueInput
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type FirebaseTokenCreateNestedOneWithoutUserInput = {
    create?: XOR<FirebaseTokenCreateWithoutUserInput, FirebaseTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: FirebaseTokenCreateOrConnectWithoutUserInput
    connect?: FirebaseTokenWhereUniqueInput
  }

  export type KYCVerificationCreateNestedOneWithoutUserInput = {
    create?: XOR<KYCVerificationCreateWithoutUserInput, KYCVerificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: KYCVerificationCreateOrConnectWithoutUserInput
    connect?: KYCVerificationWhereUniqueInput
  }

  export type AdministratorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdministratorCreateWithoutUserInput, AdministratorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdministratorCreateOrConnectWithoutUserInput
    connect?: AdministratorWhereUniqueInput
  }

  export type GuardianUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<GuardianCreateWithoutUserInput, GuardianUncheckedCreateWithoutUserInput>
    connectOrCreate?: GuardianCreateOrConnectWithoutUserInput
    connect?: GuardianWhereUniqueInput
  }

  export type VerificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VerificationCreateWithoutUserInput, VerificationUncheckedCreateWithoutUserInput> | VerificationCreateWithoutUserInput[] | VerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationCreateOrConnectWithoutUserInput | VerificationCreateOrConnectWithoutUserInput[]
    createMany?: VerificationCreateManyUserInputEnvelope
    connect?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
  }

  export type SchoolUncheckedCreateNestedOneWithoutOwnerInput = {
    create?: XOR<SchoolCreateWithoutOwnerInput, SchoolUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutOwnerInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolAndPlatformLegalAgreementUncheckedCreateNestedOneWithoutSignedByInput = {
    create?: XOR<SchoolAndPlatformLegalAgreementCreateWithoutSignedByInput, SchoolAndPlatformLegalAgreementUncheckedCreateWithoutSignedByInput>
    connectOrCreate?: SchoolAndPlatformLegalAgreementCreateOrConnectWithoutSignedByInput
    connect?: SchoolAndPlatformLegalAgreementWhereUniqueInput
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CredentialUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CredentialCreateWithoutUserInput, CredentialUncheckedCreateWithoutUserInput>
    connectOrCreate?: CredentialCreateOrConnectWithoutUserInput
    connect?: CredentialWhereUniqueInput
  }

  export type WalletUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    connect?: WalletWhereUniqueInput
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type FirebaseTokenUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<FirebaseTokenCreateWithoutUserInput, FirebaseTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: FirebaseTokenCreateOrConnectWithoutUserInput
    connect?: FirebaseTokenWhereUniqueInput
  }

  export type KYCVerificationUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<KYCVerificationCreateWithoutUserInput, KYCVerificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: KYCVerificationCreateOrConnectWithoutUserInput
    connect?: KYCVerificationWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserTypeFieldUpdateOperationsInput = {
    set?: $Enums.UserType
  }

  export type EnumAccountStatusFieldUpdateOperationsInput = {
    set?: $Enums.AccountStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AdministratorUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdministratorCreateWithoutUserInput, AdministratorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdministratorCreateOrConnectWithoutUserInput
    upsert?: AdministratorUpsertWithoutUserInput
    disconnect?: AdministratorWhereInput | boolean
    delete?: AdministratorWhereInput | boolean
    connect?: AdministratorWhereUniqueInput
    update?: XOR<XOR<AdministratorUpdateToOneWithWhereWithoutUserInput, AdministratorUpdateWithoutUserInput>, AdministratorUncheckedUpdateWithoutUserInput>
  }

  export type GuardianUpdateOneWithoutUserNestedInput = {
    create?: XOR<GuardianCreateWithoutUserInput, GuardianUncheckedCreateWithoutUserInput>
    connectOrCreate?: GuardianCreateOrConnectWithoutUserInput
    upsert?: GuardianUpsertWithoutUserInput
    disconnect?: GuardianWhereInput | boolean
    delete?: GuardianWhereInput | boolean
    connect?: GuardianWhereUniqueInput
    update?: XOR<XOR<GuardianUpdateToOneWithWhereWithoutUserInput, GuardianUpdateWithoutUserInput>, GuardianUncheckedUpdateWithoutUserInput>
  }

  export type VerificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<VerificationCreateWithoutUserInput, VerificationUncheckedCreateWithoutUserInput> | VerificationCreateWithoutUserInput[] | VerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationCreateOrConnectWithoutUserInput | VerificationCreateOrConnectWithoutUserInput[]
    upsert?: VerificationUpsertWithWhereUniqueWithoutUserInput | VerificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VerificationCreateManyUserInputEnvelope
    set?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
    disconnect?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
    delete?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
    connect?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
    update?: VerificationUpdateWithWhereUniqueWithoutUserInput | VerificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VerificationUpdateManyWithWhereWithoutUserInput | VerificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VerificationScalarWhereInput | VerificationScalarWhereInput[]
  }

  export type SchoolUpdateOneWithoutOwnerNestedInput = {
    create?: XOR<SchoolCreateWithoutOwnerInput, SchoolUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutOwnerInput
    upsert?: SchoolUpsertWithoutOwnerInput
    disconnect?: SchoolWhereInput | boolean
    delete?: SchoolWhereInput | boolean
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutOwnerInput, SchoolUpdateWithoutOwnerInput>, SchoolUncheckedUpdateWithoutOwnerInput>
  }

  export type SchoolAndPlatformLegalAgreementUpdateOneWithoutSignedByNestedInput = {
    create?: XOR<SchoolAndPlatformLegalAgreementCreateWithoutSignedByInput, SchoolAndPlatformLegalAgreementUncheckedCreateWithoutSignedByInput>
    connectOrCreate?: SchoolAndPlatformLegalAgreementCreateOrConnectWithoutSignedByInput
    upsert?: SchoolAndPlatformLegalAgreementUpsertWithoutSignedByInput
    disconnect?: SchoolAndPlatformLegalAgreementWhereInput | boolean
    delete?: SchoolAndPlatformLegalAgreementWhereInput | boolean
    connect?: SchoolAndPlatformLegalAgreementWhereUniqueInput
    update?: XOR<XOR<SchoolAndPlatformLegalAgreementUpdateToOneWithWhereWithoutSignedByInput, SchoolAndPlatformLegalAgreementUpdateWithoutSignedByInput>, SchoolAndPlatformLegalAgreementUncheckedUpdateWithoutSignedByInput>
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CredentialUpdateOneWithoutUserNestedInput = {
    create?: XOR<CredentialCreateWithoutUserInput, CredentialUncheckedCreateWithoutUserInput>
    connectOrCreate?: CredentialCreateOrConnectWithoutUserInput
    upsert?: CredentialUpsertWithoutUserInput
    disconnect?: CredentialWhereInput | boolean
    delete?: CredentialWhereInput | boolean
    connect?: CredentialWhereUniqueInput
    update?: XOR<XOR<CredentialUpdateToOneWithWhereWithoutUserInput, CredentialUpdateWithoutUserInput>, CredentialUncheckedUpdateWithoutUserInput>
  }

  export type WalletUpdateOneWithoutUserNestedInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    upsert?: WalletUpsertWithoutUserInput
    disconnect?: WalletWhereInput | boolean
    delete?: WalletWhereInput | boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutUserInput, WalletUpdateWithoutUserInput>, WalletUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type FirebaseTokenUpdateOneWithoutUserNestedInput = {
    create?: XOR<FirebaseTokenCreateWithoutUserInput, FirebaseTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: FirebaseTokenCreateOrConnectWithoutUserInput
    upsert?: FirebaseTokenUpsertWithoutUserInput
    disconnect?: FirebaseTokenWhereInput | boolean
    delete?: FirebaseTokenWhereInput | boolean
    connect?: FirebaseTokenWhereUniqueInput
    update?: XOR<XOR<FirebaseTokenUpdateToOneWithWhereWithoutUserInput, FirebaseTokenUpdateWithoutUserInput>, FirebaseTokenUncheckedUpdateWithoutUserInput>
  }

  export type KYCVerificationUpdateOneWithoutUserNestedInput = {
    create?: XOR<KYCVerificationCreateWithoutUserInput, KYCVerificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: KYCVerificationCreateOrConnectWithoutUserInput
    upsert?: KYCVerificationUpsertWithoutUserInput
    disconnect?: KYCVerificationWhereInput | boolean
    delete?: KYCVerificationWhereInput | boolean
    connect?: KYCVerificationWhereUniqueInput
    update?: XOR<XOR<KYCVerificationUpdateToOneWithWhereWithoutUserInput, KYCVerificationUpdateWithoutUserInput>, KYCVerificationUncheckedUpdateWithoutUserInput>
  }

  export type AdministratorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdministratorCreateWithoutUserInput, AdministratorUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdministratorCreateOrConnectWithoutUserInput
    upsert?: AdministratorUpsertWithoutUserInput
    disconnect?: AdministratorWhereInput | boolean
    delete?: AdministratorWhereInput | boolean
    connect?: AdministratorWhereUniqueInput
    update?: XOR<XOR<AdministratorUpdateToOneWithWhereWithoutUserInput, AdministratorUpdateWithoutUserInput>, AdministratorUncheckedUpdateWithoutUserInput>
  }

  export type GuardianUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<GuardianCreateWithoutUserInput, GuardianUncheckedCreateWithoutUserInput>
    connectOrCreate?: GuardianCreateOrConnectWithoutUserInput
    upsert?: GuardianUpsertWithoutUserInput
    disconnect?: GuardianWhereInput | boolean
    delete?: GuardianWhereInput | boolean
    connect?: GuardianWhereUniqueInput
    update?: XOR<XOR<GuardianUpdateToOneWithWhereWithoutUserInput, GuardianUpdateWithoutUserInput>, GuardianUncheckedUpdateWithoutUserInput>
  }

  export type VerificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VerificationCreateWithoutUserInput, VerificationUncheckedCreateWithoutUserInput> | VerificationCreateWithoutUserInput[] | VerificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationCreateOrConnectWithoutUserInput | VerificationCreateOrConnectWithoutUserInput[]
    upsert?: VerificationUpsertWithWhereUniqueWithoutUserInput | VerificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VerificationCreateManyUserInputEnvelope
    set?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
    disconnect?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
    delete?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
    connect?: VerificationWhereUniqueInput | VerificationWhereUniqueInput[]
    update?: VerificationUpdateWithWhereUniqueWithoutUserInput | VerificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VerificationUpdateManyWithWhereWithoutUserInput | VerificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VerificationScalarWhereInput | VerificationScalarWhereInput[]
  }

  export type SchoolUncheckedUpdateOneWithoutOwnerNestedInput = {
    create?: XOR<SchoolCreateWithoutOwnerInput, SchoolUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutOwnerInput
    upsert?: SchoolUpsertWithoutOwnerInput
    disconnect?: SchoolWhereInput | boolean
    delete?: SchoolWhereInput | boolean
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutOwnerInput, SchoolUpdateWithoutOwnerInput>, SchoolUncheckedUpdateWithoutOwnerInput>
  }

  export type SchoolAndPlatformLegalAgreementUncheckedUpdateOneWithoutSignedByNestedInput = {
    create?: XOR<SchoolAndPlatformLegalAgreementCreateWithoutSignedByInput, SchoolAndPlatformLegalAgreementUncheckedCreateWithoutSignedByInput>
    connectOrCreate?: SchoolAndPlatformLegalAgreementCreateOrConnectWithoutSignedByInput
    upsert?: SchoolAndPlatformLegalAgreementUpsertWithoutSignedByInput
    disconnect?: SchoolAndPlatformLegalAgreementWhereInput | boolean
    delete?: SchoolAndPlatformLegalAgreementWhereInput | boolean
    connect?: SchoolAndPlatformLegalAgreementWhereUniqueInput
    update?: XOR<XOR<SchoolAndPlatformLegalAgreementUpdateToOneWithWhereWithoutSignedByInput, SchoolAndPlatformLegalAgreementUpdateWithoutSignedByInput>, SchoolAndPlatformLegalAgreementUncheckedUpdateWithoutSignedByInput>
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CredentialUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CredentialCreateWithoutUserInput, CredentialUncheckedCreateWithoutUserInput>
    connectOrCreate?: CredentialCreateOrConnectWithoutUserInput
    upsert?: CredentialUpsertWithoutUserInput
    disconnect?: CredentialWhereInput | boolean
    delete?: CredentialWhereInput | boolean
    connect?: CredentialWhereUniqueInput
    update?: XOR<XOR<CredentialUpdateToOneWithWhereWithoutUserInput, CredentialUpdateWithoutUserInput>, CredentialUncheckedUpdateWithoutUserInput>
  }

  export type WalletUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    connectOrCreate?: WalletCreateOrConnectWithoutUserInput
    upsert?: WalletUpsertWithoutUserInput
    disconnect?: WalletWhereInput | boolean
    delete?: WalletWhereInput | boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutUserInput, WalletUpdateWithoutUserInput>, WalletUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type FirebaseTokenUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<FirebaseTokenCreateWithoutUserInput, FirebaseTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: FirebaseTokenCreateOrConnectWithoutUserInput
    upsert?: FirebaseTokenUpsertWithoutUserInput
    disconnect?: FirebaseTokenWhereInput | boolean
    delete?: FirebaseTokenWhereInput | boolean
    connect?: FirebaseTokenWhereUniqueInput
    update?: XOR<XOR<FirebaseTokenUpdateToOneWithWhereWithoutUserInput, FirebaseTokenUpdateWithoutUserInput>, FirebaseTokenUncheckedUpdateWithoutUserInput>
  }

  export type KYCVerificationUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<KYCVerificationCreateWithoutUserInput, KYCVerificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: KYCVerificationCreateOrConnectWithoutUserInput
    upsert?: KYCVerificationUpsertWithoutUserInput
    disconnect?: KYCVerificationWhereInput | boolean
    delete?: KYCVerificationWhereInput | boolean
    connect?: KYCVerificationWhereUniqueInput
    update?: XOR<XOR<KYCVerificationUpdateToOneWithWhereWithoutUserInput, KYCVerificationUpdateWithoutUserInput>, KYCVerificationUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutCredentialInput = {
    create?: XOR<UserCreateWithoutCredentialInput, UserUncheckedCreateWithoutCredentialInput>
    connectOrCreate?: UserCreateOrConnectWithoutCredentialInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCredentialNestedInput = {
    create?: XOR<UserCreateWithoutCredentialInput, UserUncheckedCreateWithoutCredentialInput>
    connectOrCreate?: UserCreateOrConnectWithoutCredentialInput
    upsert?: UserUpsertWithoutCredentialInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCredentialInput, UserUpdateWithoutCredentialInput>, UserUncheckedUpdateWithoutCredentialInput>
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserCreateNestedOneWithoutAdministratorInput = {
    create?: XOR<UserCreateWithoutAdministratorInput, UserUncheckedCreateWithoutAdministratorInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdministratorInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdministratorNestedInput = {
    create?: XOR<UserCreateWithoutAdministratorInput, UserUncheckedCreateWithoutAdministratorInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdministratorInput
    upsert?: UserUpsertWithoutAdministratorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdministratorInput, UserUpdateWithoutAdministratorInput>, UserUncheckedUpdateWithoutAdministratorInput>
  }

  export type UserCreateNestedOneWithoutGuardianInput = {
    create?: XOR<UserCreateWithoutGuardianInput, UserUncheckedCreateWithoutGuardianInput>
    connectOrCreate?: UserCreateOrConnectWithoutGuardianInput
    connect?: UserWhereUniqueInput
  }

  export type InvoiceCreateNestedManyWithoutGuardianInput = {
    create?: XOR<InvoiceCreateWithoutGuardianInput, InvoiceUncheckedCreateWithoutGuardianInput> | InvoiceCreateWithoutGuardianInput[] | InvoiceUncheckedCreateWithoutGuardianInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutGuardianInput | InvoiceCreateOrConnectWithoutGuardianInput[]
    createMany?: InvoiceCreateManyGuardianInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutGuardianInput = {
    create?: XOR<StudentCreateWithoutGuardianInput, StudentUncheckedCreateWithoutGuardianInput> | StudentCreateWithoutGuardianInput[] | StudentUncheckedCreateWithoutGuardianInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutGuardianInput | StudentCreateOrConnectWithoutGuardianInput[]
    createMany?: StudentCreateManyGuardianInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type LinkedStudentProfileCreateNestedManyWithoutGuardianInput = {
    create?: XOR<LinkedStudentProfileCreateWithoutGuardianInput, LinkedStudentProfileUncheckedCreateWithoutGuardianInput> | LinkedStudentProfileCreateWithoutGuardianInput[] | LinkedStudentProfileUncheckedCreateWithoutGuardianInput[]
    connectOrCreate?: LinkedStudentProfileCreateOrConnectWithoutGuardianInput | LinkedStudentProfileCreateOrConnectWithoutGuardianInput[]
    createMany?: LinkedStudentProfileCreateManyGuardianInputEnvelope
    connect?: LinkedStudentProfileWhereUniqueInput | LinkedStudentProfileWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutGuardianInput = {
    create?: XOR<TransactionCreateWithoutGuardianInput, TransactionUncheckedCreateWithoutGuardianInput> | TransactionCreateWithoutGuardianInput[] | TransactionUncheckedCreateWithoutGuardianInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutGuardianInput | TransactionCreateOrConnectWithoutGuardianInput[]
    createMany?: TransactionCreateManyGuardianInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutGuardianInput = {
    create?: XOR<InvoiceCreateWithoutGuardianInput, InvoiceUncheckedCreateWithoutGuardianInput> | InvoiceCreateWithoutGuardianInput[] | InvoiceUncheckedCreateWithoutGuardianInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutGuardianInput | InvoiceCreateOrConnectWithoutGuardianInput[]
    createMany?: InvoiceCreateManyGuardianInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutGuardianInput = {
    create?: XOR<StudentCreateWithoutGuardianInput, StudentUncheckedCreateWithoutGuardianInput> | StudentCreateWithoutGuardianInput[] | StudentUncheckedCreateWithoutGuardianInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutGuardianInput | StudentCreateOrConnectWithoutGuardianInput[]
    createMany?: StudentCreateManyGuardianInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type LinkedStudentProfileUncheckedCreateNestedManyWithoutGuardianInput = {
    create?: XOR<LinkedStudentProfileCreateWithoutGuardianInput, LinkedStudentProfileUncheckedCreateWithoutGuardianInput> | LinkedStudentProfileCreateWithoutGuardianInput[] | LinkedStudentProfileUncheckedCreateWithoutGuardianInput[]
    connectOrCreate?: LinkedStudentProfileCreateOrConnectWithoutGuardianInput | LinkedStudentProfileCreateOrConnectWithoutGuardianInput[]
    createMany?: LinkedStudentProfileCreateManyGuardianInputEnvelope
    connect?: LinkedStudentProfileWhereUniqueInput | LinkedStudentProfileWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutGuardianInput = {
    create?: XOR<TransactionCreateWithoutGuardianInput, TransactionUncheckedCreateWithoutGuardianInput> | TransactionCreateWithoutGuardianInput[] | TransactionUncheckedCreateWithoutGuardianInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutGuardianInput | TransactionCreateOrConnectWithoutGuardianInput[]
    createMany?: TransactionCreateManyGuardianInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutGuardianNestedInput = {
    create?: XOR<UserCreateWithoutGuardianInput, UserUncheckedCreateWithoutGuardianInput>
    connectOrCreate?: UserCreateOrConnectWithoutGuardianInput
    upsert?: UserUpsertWithoutGuardianInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGuardianInput, UserUpdateWithoutGuardianInput>, UserUncheckedUpdateWithoutGuardianInput>
  }

  export type InvoiceUpdateManyWithoutGuardianNestedInput = {
    create?: XOR<InvoiceCreateWithoutGuardianInput, InvoiceUncheckedCreateWithoutGuardianInput> | InvoiceCreateWithoutGuardianInput[] | InvoiceUncheckedCreateWithoutGuardianInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutGuardianInput | InvoiceCreateOrConnectWithoutGuardianInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutGuardianInput | InvoiceUpsertWithWhereUniqueWithoutGuardianInput[]
    createMany?: InvoiceCreateManyGuardianInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutGuardianInput | InvoiceUpdateWithWhereUniqueWithoutGuardianInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutGuardianInput | InvoiceUpdateManyWithWhereWithoutGuardianInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutGuardianNestedInput = {
    create?: XOR<StudentCreateWithoutGuardianInput, StudentUncheckedCreateWithoutGuardianInput> | StudentCreateWithoutGuardianInput[] | StudentUncheckedCreateWithoutGuardianInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutGuardianInput | StudentCreateOrConnectWithoutGuardianInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutGuardianInput | StudentUpsertWithWhereUniqueWithoutGuardianInput[]
    createMany?: StudentCreateManyGuardianInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutGuardianInput | StudentUpdateWithWhereUniqueWithoutGuardianInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutGuardianInput | StudentUpdateManyWithWhereWithoutGuardianInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type LinkedStudentProfileUpdateManyWithoutGuardianNestedInput = {
    create?: XOR<LinkedStudentProfileCreateWithoutGuardianInput, LinkedStudentProfileUncheckedCreateWithoutGuardianInput> | LinkedStudentProfileCreateWithoutGuardianInput[] | LinkedStudentProfileUncheckedCreateWithoutGuardianInput[]
    connectOrCreate?: LinkedStudentProfileCreateOrConnectWithoutGuardianInput | LinkedStudentProfileCreateOrConnectWithoutGuardianInput[]
    upsert?: LinkedStudentProfileUpsertWithWhereUniqueWithoutGuardianInput | LinkedStudentProfileUpsertWithWhereUniqueWithoutGuardianInput[]
    createMany?: LinkedStudentProfileCreateManyGuardianInputEnvelope
    set?: LinkedStudentProfileWhereUniqueInput | LinkedStudentProfileWhereUniqueInput[]
    disconnect?: LinkedStudentProfileWhereUniqueInput | LinkedStudentProfileWhereUniqueInput[]
    delete?: LinkedStudentProfileWhereUniqueInput | LinkedStudentProfileWhereUniqueInput[]
    connect?: LinkedStudentProfileWhereUniqueInput | LinkedStudentProfileWhereUniqueInput[]
    update?: LinkedStudentProfileUpdateWithWhereUniqueWithoutGuardianInput | LinkedStudentProfileUpdateWithWhereUniqueWithoutGuardianInput[]
    updateMany?: LinkedStudentProfileUpdateManyWithWhereWithoutGuardianInput | LinkedStudentProfileUpdateManyWithWhereWithoutGuardianInput[]
    deleteMany?: LinkedStudentProfileScalarWhereInput | LinkedStudentProfileScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutGuardianNestedInput = {
    create?: XOR<TransactionCreateWithoutGuardianInput, TransactionUncheckedCreateWithoutGuardianInput> | TransactionCreateWithoutGuardianInput[] | TransactionUncheckedCreateWithoutGuardianInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutGuardianInput | TransactionCreateOrConnectWithoutGuardianInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutGuardianInput | TransactionUpsertWithWhereUniqueWithoutGuardianInput[]
    createMany?: TransactionCreateManyGuardianInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutGuardianInput | TransactionUpdateWithWhereUniqueWithoutGuardianInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutGuardianInput | TransactionUpdateManyWithWhereWithoutGuardianInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutGuardianNestedInput = {
    create?: XOR<InvoiceCreateWithoutGuardianInput, InvoiceUncheckedCreateWithoutGuardianInput> | InvoiceCreateWithoutGuardianInput[] | InvoiceUncheckedCreateWithoutGuardianInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutGuardianInput | InvoiceCreateOrConnectWithoutGuardianInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutGuardianInput | InvoiceUpsertWithWhereUniqueWithoutGuardianInput[]
    createMany?: InvoiceCreateManyGuardianInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutGuardianInput | InvoiceUpdateWithWhereUniqueWithoutGuardianInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutGuardianInput | InvoiceUpdateManyWithWhereWithoutGuardianInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutGuardianNestedInput = {
    create?: XOR<StudentCreateWithoutGuardianInput, StudentUncheckedCreateWithoutGuardianInput> | StudentCreateWithoutGuardianInput[] | StudentUncheckedCreateWithoutGuardianInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutGuardianInput | StudentCreateOrConnectWithoutGuardianInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutGuardianInput | StudentUpsertWithWhereUniqueWithoutGuardianInput[]
    createMany?: StudentCreateManyGuardianInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutGuardianInput | StudentUpdateWithWhereUniqueWithoutGuardianInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutGuardianInput | StudentUpdateManyWithWhereWithoutGuardianInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type LinkedStudentProfileUncheckedUpdateManyWithoutGuardianNestedInput = {
    create?: XOR<LinkedStudentProfileCreateWithoutGuardianInput, LinkedStudentProfileUncheckedCreateWithoutGuardianInput> | LinkedStudentProfileCreateWithoutGuardianInput[] | LinkedStudentProfileUncheckedCreateWithoutGuardianInput[]
    connectOrCreate?: LinkedStudentProfileCreateOrConnectWithoutGuardianInput | LinkedStudentProfileCreateOrConnectWithoutGuardianInput[]
    upsert?: LinkedStudentProfileUpsertWithWhereUniqueWithoutGuardianInput | LinkedStudentProfileUpsertWithWhereUniqueWithoutGuardianInput[]
    createMany?: LinkedStudentProfileCreateManyGuardianInputEnvelope
    set?: LinkedStudentProfileWhereUniqueInput | LinkedStudentProfileWhereUniqueInput[]
    disconnect?: LinkedStudentProfileWhereUniqueInput | LinkedStudentProfileWhereUniqueInput[]
    delete?: LinkedStudentProfileWhereUniqueInput | LinkedStudentProfileWhereUniqueInput[]
    connect?: LinkedStudentProfileWhereUniqueInput | LinkedStudentProfileWhereUniqueInput[]
    update?: LinkedStudentProfileUpdateWithWhereUniqueWithoutGuardianInput | LinkedStudentProfileUpdateWithWhereUniqueWithoutGuardianInput[]
    updateMany?: LinkedStudentProfileUpdateManyWithWhereWithoutGuardianInput | LinkedStudentProfileUpdateManyWithWhereWithoutGuardianInput[]
    deleteMany?: LinkedStudentProfileScalarWhereInput | LinkedStudentProfileScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutGuardianNestedInput = {
    create?: XOR<TransactionCreateWithoutGuardianInput, TransactionUncheckedCreateWithoutGuardianInput> | TransactionCreateWithoutGuardianInput[] | TransactionUncheckedCreateWithoutGuardianInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutGuardianInput | TransactionCreateOrConnectWithoutGuardianInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutGuardianInput | TransactionUpsertWithWhereUniqueWithoutGuardianInput[]
    createMany?: TransactionCreateManyGuardianInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutGuardianInput | TransactionUpdateWithWhereUniqueWithoutGuardianInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutGuardianInput | TransactionUpdateManyWithWhereWithoutGuardianInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutVerificationsInput = {
    create?: XOR<UserCreateWithoutVerificationsInput, UserUncheckedCreateWithoutVerificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumVerificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.VerificationType
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutVerificationsNestedInput = {
    create?: XOR<UserCreateWithoutVerificationsInput, UserUncheckedCreateWithoutVerificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerificationsInput
    upsert?: UserUpsertWithoutVerificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVerificationsInput, UserUpdateWithoutVerificationsInput>, UserUncheckedUpdateWithoutVerificationsInput>
  }

  export type UserCreateNestedOneWithoutSchoolInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput
    connect?: UserWhereUniqueInput
  }

  export type SchoolDirectorVerificationCreateNestedOneWithoutSchoolInput = {
    create?: XOR<SchoolDirectorVerificationCreateWithoutSchoolInput, SchoolDirectorVerificationUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: SchoolDirectorVerificationCreateOrConnectWithoutSchoolInput
    connect?: SchoolDirectorVerificationWhereUniqueInput
  }

  export type SchoolOwnershipVerificationCreateNestedOneWithoutSchoolInput = {
    create?: XOR<SchoolOwnershipVerificationCreateWithoutSchoolInput, SchoolOwnershipVerificationUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: SchoolOwnershipVerificationCreateOrConnectWithoutSchoolInput
    connect?: SchoolOwnershipVerificationWhereUniqueInput
  }

  export type SchoolVerificationCreateNestedOneWithoutSchoolInput = {
    create?: XOR<SchoolVerificationCreateWithoutSchoolInput, SchoolVerificationUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: SchoolVerificationCreateOrConnectWithoutSchoolInput
    connect?: SchoolVerificationWhereUniqueInput
  }

  export type SchoolPayoutDetailCreateNestedOneWithoutSchoolInput = {
    create?: XOR<SchoolPayoutDetailCreateWithoutSchoolInput, SchoolPayoutDetailUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: SchoolPayoutDetailCreateOrConnectWithoutSchoolInput
    connect?: SchoolPayoutDetailWhereUniqueInput
  }

  export type SchoolAndPlatformLegalAgreementCreateNestedOneWithoutSchoolInput = {
    create?: XOR<SchoolAndPlatformLegalAgreementCreateWithoutSchoolInput, SchoolAndPlatformLegalAgreementUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: SchoolAndPlatformLegalAgreementCreateOrConnectWithoutSchoolInput
    connect?: SchoolAndPlatformLegalAgreementWhereUniqueInput
  }

  export type ClassCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type AcademicSessionCreateNestedManyWithoutSchoolInput = {
    create?: XOR<AcademicSessionCreateWithoutSchoolInput, AcademicSessionUncheckedCreateWithoutSchoolInput> | AcademicSessionCreateWithoutSchoolInput[] | AcademicSessionUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AcademicSessionCreateOrConnectWithoutSchoolInput | AcademicSessionCreateOrConnectWithoutSchoolInput[]
    createMany?: AcademicSessionCreateManySchoolInputEnvelope
    connect?: AcademicSessionWhereUniqueInput | AcademicSessionWhereUniqueInput[]
  }

  export type TermCreateNestedManyWithoutSchoolInput = {
    create?: XOR<TermCreateWithoutSchoolInput, TermUncheckedCreateWithoutSchoolInput> | TermCreateWithoutSchoolInput[] | TermUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TermCreateOrConnectWithoutSchoolInput | TermCreateOrConnectWithoutSchoolInput[]
    createMany?: TermCreateManySchoolInputEnvelope
    connect?: TermWhereUniqueInput | TermWhereUniqueInput[]
  }

  export type FeesCreateNestedManyWithoutSchoolInput = {
    create?: XOR<FeesCreateWithoutSchoolInput, FeesUncheckedCreateWithoutSchoolInput> | FeesCreateWithoutSchoolInput[] | FeesUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FeesCreateOrConnectWithoutSchoolInput | FeesCreateOrConnectWithoutSchoolInput[]
    createMany?: FeesCreateManySchoolInputEnvelope
    connect?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
  }

  export type PayoutCreateNestedManyWithoutSchoolInput = {
    create?: XOR<PayoutCreateWithoutSchoolInput, PayoutUncheckedCreateWithoutSchoolInput> | PayoutCreateWithoutSchoolInput[] | PayoutUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PayoutCreateOrConnectWithoutSchoolInput | PayoutCreateOrConnectWithoutSchoolInput[]
    createMany?: PayoutCreateManySchoolInputEnvelope
    connect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
  }

  export type KYCVerificationCreateNestedOneWithoutSchoolInput = {
    create?: XOR<KYCVerificationCreateWithoutSchoolInput, KYCVerificationUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: KYCVerificationCreateOrConnectWithoutSchoolInput
    connect?: KYCVerificationWhereUniqueInput
  }

  export type SchoolDirectorVerificationUncheckedCreateNestedOneWithoutSchoolInput = {
    create?: XOR<SchoolDirectorVerificationCreateWithoutSchoolInput, SchoolDirectorVerificationUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: SchoolDirectorVerificationCreateOrConnectWithoutSchoolInput
    connect?: SchoolDirectorVerificationWhereUniqueInput
  }

  export type SchoolOwnershipVerificationUncheckedCreateNestedOneWithoutSchoolInput = {
    create?: XOR<SchoolOwnershipVerificationCreateWithoutSchoolInput, SchoolOwnershipVerificationUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: SchoolOwnershipVerificationCreateOrConnectWithoutSchoolInput
    connect?: SchoolOwnershipVerificationWhereUniqueInput
  }

  export type SchoolVerificationUncheckedCreateNestedOneWithoutSchoolInput = {
    create?: XOR<SchoolVerificationCreateWithoutSchoolInput, SchoolVerificationUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: SchoolVerificationCreateOrConnectWithoutSchoolInput
    connect?: SchoolVerificationWhereUniqueInput
  }

  export type SchoolPayoutDetailUncheckedCreateNestedOneWithoutSchoolInput = {
    create?: XOR<SchoolPayoutDetailCreateWithoutSchoolInput, SchoolPayoutDetailUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: SchoolPayoutDetailCreateOrConnectWithoutSchoolInput
    connect?: SchoolPayoutDetailWhereUniqueInput
  }

  export type SchoolAndPlatformLegalAgreementUncheckedCreateNestedOneWithoutSchoolInput = {
    create?: XOR<SchoolAndPlatformLegalAgreementCreateWithoutSchoolInput, SchoolAndPlatformLegalAgreementUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: SchoolAndPlatformLegalAgreementCreateOrConnectWithoutSchoolInput
    connect?: SchoolAndPlatformLegalAgreementWhereUniqueInput
  }

  export type ClassUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type AcademicSessionUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<AcademicSessionCreateWithoutSchoolInput, AcademicSessionUncheckedCreateWithoutSchoolInput> | AcademicSessionCreateWithoutSchoolInput[] | AcademicSessionUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AcademicSessionCreateOrConnectWithoutSchoolInput | AcademicSessionCreateOrConnectWithoutSchoolInput[]
    createMany?: AcademicSessionCreateManySchoolInputEnvelope
    connect?: AcademicSessionWhereUniqueInput | AcademicSessionWhereUniqueInput[]
  }

  export type TermUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<TermCreateWithoutSchoolInput, TermUncheckedCreateWithoutSchoolInput> | TermCreateWithoutSchoolInput[] | TermUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TermCreateOrConnectWithoutSchoolInput | TermCreateOrConnectWithoutSchoolInput[]
    createMany?: TermCreateManySchoolInputEnvelope
    connect?: TermWhereUniqueInput | TermWhereUniqueInput[]
  }

  export type FeesUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<FeesCreateWithoutSchoolInput, FeesUncheckedCreateWithoutSchoolInput> | FeesCreateWithoutSchoolInput[] | FeesUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FeesCreateOrConnectWithoutSchoolInput | FeesCreateOrConnectWithoutSchoolInput[]
    createMany?: FeesCreateManySchoolInputEnvelope
    connect?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
  }

  export type PayoutUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<PayoutCreateWithoutSchoolInput, PayoutUncheckedCreateWithoutSchoolInput> | PayoutCreateWithoutSchoolInput[] | PayoutUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PayoutCreateOrConnectWithoutSchoolInput | PayoutCreateOrConnectWithoutSchoolInput[]
    createMany?: PayoutCreateManySchoolInputEnvelope
    connect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
  }

  export type KYCVerificationUncheckedCreateNestedOneWithoutSchoolInput = {
    create?: XOR<KYCVerificationCreateWithoutSchoolInput, KYCVerificationUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: KYCVerificationCreateOrConnectWithoutSchoolInput
    connect?: KYCVerificationWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumSchoolTypeFieldUpdateOperationsInput = {
    set?: $Enums.SchoolType
  }

  export type EnumSchoolOwnershipFieldUpdateOperationsInput = {
    set?: $Enums.SchoolOwnership
  }

  export type EnumSchoolStatusFieldUpdateOperationsInput = {
    set?: $Enums.SchoolStatus
  }

  export type UserUpdateOneRequiredWithoutSchoolNestedInput = {
    create?: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: UserCreateOrConnectWithoutSchoolInput
    upsert?: UserUpsertWithoutSchoolInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSchoolInput, UserUpdateWithoutSchoolInput>, UserUncheckedUpdateWithoutSchoolInput>
  }

  export type SchoolDirectorVerificationUpdateOneWithoutSchoolNestedInput = {
    create?: XOR<SchoolDirectorVerificationCreateWithoutSchoolInput, SchoolDirectorVerificationUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: SchoolDirectorVerificationCreateOrConnectWithoutSchoolInput
    upsert?: SchoolDirectorVerificationUpsertWithoutSchoolInput
    disconnect?: SchoolDirectorVerificationWhereInput | boolean
    delete?: SchoolDirectorVerificationWhereInput | boolean
    connect?: SchoolDirectorVerificationWhereUniqueInput
    update?: XOR<XOR<SchoolDirectorVerificationUpdateToOneWithWhereWithoutSchoolInput, SchoolDirectorVerificationUpdateWithoutSchoolInput>, SchoolDirectorVerificationUncheckedUpdateWithoutSchoolInput>
  }

  export type SchoolOwnershipVerificationUpdateOneWithoutSchoolNestedInput = {
    create?: XOR<SchoolOwnershipVerificationCreateWithoutSchoolInput, SchoolOwnershipVerificationUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: SchoolOwnershipVerificationCreateOrConnectWithoutSchoolInput
    upsert?: SchoolOwnershipVerificationUpsertWithoutSchoolInput
    disconnect?: SchoolOwnershipVerificationWhereInput | boolean
    delete?: SchoolOwnershipVerificationWhereInput | boolean
    connect?: SchoolOwnershipVerificationWhereUniqueInput
    update?: XOR<XOR<SchoolOwnershipVerificationUpdateToOneWithWhereWithoutSchoolInput, SchoolOwnershipVerificationUpdateWithoutSchoolInput>, SchoolOwnershipVerificationUncheckedUpdateWithoutSchoolInput>
  }

  export type SchoolVerificationUpdateOneWithoutSchoolNestedInput = {
    create?: XOR<SchoolVerificationCreateWithoutSchoolInput, SchoolVerificationUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: SchoolVerificationCreateOrConnectWithoutSchoolInput
    upsert?: SchoolVerificationUpsertWithoutSchoolInput
    disconnect?: SchoolVerificationWhereInput | boolean
    delete?: SchoolVerificationWhereInput | boolean
    connect?: SchoolVerificationWhereUniqueInput
    update?: XOR<XOR<SchoolVerificationUpdateToOneWithWhereWithoutSchoolInput, SchoolVerificationUpdateWithoutSchoolInput>, SchoolVerificationUncheckedUpdateWithoutSchoolInput>
  }

  export type SchoolPayoutDetailUpdateOneWithoutSchoolNestedInput = {
    create?: XOR<SchoolPayoutDetailCreateWithoutSchoolInput, SchoolPayoutDetailUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: SchoolPayoutDetailCreateOrConnectWithoutSchoolInput
    upsert?: SchoolPayoutDetailUpsertWithoutSchoolInput
    disconnect?: SchoolPayoutDetailWhereInput | boolean
    delete?: SchoolPayoutDetailWhereInput | boolean
    connect?: SchoolPayoutDetailWhereUniqueInput
    update?: XOR<XOR<SchoolPayoutDetailUpdateToOneWithWhereWithoutSchoolInput, SchoolPayoutDetailUpdateWithoutSchoolInput>, SchoolPayoutDetailUncheckedUpdateWithoutSchoolInput>
  }

  export type SchoolAndPlatformLegalAgreementUpdateOneWithoutSchoolNestedInput = {
    create?: XOR<SchoolAndPlatformLegalAgreementCreateWithoutSchoolInput, SchoolAndPlatformLegalAgreementUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: SchoolAndPlatformLegalAgreementCreateOrConnectWithoutSchoolInput
    upsert?: SchoolAndPlatformLegalAgreementUpsertWithoutSchoolInput
    disconnect?: SchoolAndPlatformLegalAgreementWhereInput | boolean
    delete?: SchoolAndPlatformLegalAgreementWhereInput | boolean
    connect?: SchoolAndPlatformLegalAgreementWhereUniqueInput
    update?: XOR<XOR<SchoolAndPlatformLegalAgreementUpdateToOneWithWhereWithoutSchoolInput, SchoolAndPlatformLegalAgreementUpdateWithoutSchoolInput>, SchoolAndPlatformLegalAgreementUncheckedUpdateWithoutSchoolInput>
  }

  export type ClassUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutSchoolInput | ClassUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutSchoolInput | ClassUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutSchoolInput | ClassUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type AcademicSessionUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<AcademicSessionCreateWithoutSchoolInput, AcademicSessionUncheckedCreateWithoutSchoolInput> | AcademicSessionCreateWithoutSchoolInput[] | AcademicSessionUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AcademicSessionCreateOrConnectWithoutSchoolInput | AcademicSessionCreateOrConnectWithoutSchoolInput[]
    upsert?: AcademicSessionUpsertWithWhereUniqueWithoutSchoolInput | AcademicSessionUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: AcademicSessionCreateManySchoolInputEnvelope
    set?: AcademicSessionWhereUniqueInput | AcademicSessionWhereUniqueInput[]
    disconnect?: AcademicSessionWhereUniqueInput | AcademicSessionWhereUniqueInput[]
    delete?: AcademicSessionWhereUniqueInput | AcademicSessionWhereUniqueInput[]
    connect?: AcademicSessionWhereUniqueInput | AcademicSessionWhereUniqueInput[]
    update?: AcademicSessionUpdateWithWhereUniqueWithoutSchoolInput | AcademicSessionUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: AcademicSessionUpdateManyWithWhereWithoutSchoolInput | AcademicSessionUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: AcademicSessionScalarWhereInput | AcademicSessionScalarWhereInput[]
  }

  export type TermUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<TermCreateWithoutSchoolInput, TermUncheckedCreateWithoutSchoolInput> | TermCreateWithoutSchoolInput[] | TermUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TermCreateOrConnectWithoutSchoolInput | TermCreateOrConnectWithoutSchoolInput[]
    upsert?: TermUpsertWithWhereUniqueWithoutSchoolInput | TermUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: TermCreateManySchoolInputEnvelope
    set?: TermWhereUniqueInput | TermWhereUniqueInput[]
    disconnect?: TermWhereUniqueInput | TermWhereUniqueInput[]
    delete?: TermWhereUniqueInput | TermWhereUniqueInput[]
    connect?: TermWhereUniqueInput | TermWhereUniqueInput[]
    update?: TermUpdateWithWhereUniqueWithoutSchoolInput | TermUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: TermUpdateManyWithWhereWithoutSchoolInput | TermUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: TermScalarWhereInput | TermScalarWhereInput[]
  }

  export type FeesUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<FeesCreateWithoutSchoolInput, FeesUncheckedCreateWithoutSchoolInput> | FeesCreateWithoutSchoolInput[] | FeesUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FeesCreateOrConnectWithoutSchoolInput | FeesCreateOrConnectWithoutSchoolInput[]
    upsert?: FeesUpsertWithWhereUniqueWithoutSchoolInput | FeesUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: FeesCreateManySchoolInputEnvelope
    set?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    disconnect?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    delete?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    connect?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    update?: FeesUpdateWithWhereUniqueWithoutSchoolInput | FeesUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: FeesUpdateManyWithWhereWithoutSchoolInput | FeesUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: FeesScalarWhereInput | FeesScalarWhereInput[]
  }

  export type PayoutUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<PayoutCreateWithoutSchoolInput, PayoutUncheckedCreateWithoutSchoolInput> | PayoutCreateWithoutSchoolInput[] | PayoutUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PayoutCreateOrConnectWithoutSchoolInput | PayoutCreateOrConnectWithoutSchoolInput[]
    upsert?: PayoutUpsertWithWhereUniqueWithoutSchoolInput | PayoutUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: PayoutCreateManySchoolInputEnvelope
    set?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    disconnect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    delete?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    connect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    update?: PayoutUpdateWithWhereUniqueWithoutSchoolInput | PayoutUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: PayoutUpdateManyWithWhereWithoutSchoolInput | PayoutUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: PayoutScalarWhereInput | PayoutScalarWhereInput[]
  }

  export type KYCVerificationUpdateOneWithoutSchoolNestedInput = {
    create?: XOR<KYCVerificationCreateWithoutSchoolInput, KYCVerificationUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: KYCVerificationCreateOrConnectWithoutSchoolInput
    upsert?: KYCVerificationUpsertWithoutSchoolInput
    disconnect?: KYCVerificationWhereInput | boolean
    delete?: KYCVerificationWhereInput | boolean
    connect?: KYCVerificationWhereUniqueInput
    update?: XOR<XOR<KYCVerificationUpdateToOneWithWhereWithoutSchoolInput, KYCVerificationUpdateWithoutSchoolInput>, KYCVerificationUncheckedUpdateWithoutSchoolInput>
  }

  export type SchoolDirectorVerificationUncheckedUpdateOneWithoutSchoolNestedInput = {
    create?: XOR<SchoolDirectorVerificationCreateWithoutSchoolInput, SchoolDirectorVerificationUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: SchoolDirectorVerificationCreateOrConnectWithoutSchoolInput
    upsert?: SchoolDirectorVerificationUpsertWithoutSchoolInput
    disconnect?: SchoolDirectorVerificationWhereInput | boolean
    delete?: SchoolDirectorVerificationWhereInput | boolean
    connect?: SchoolDirectorVerificationWhereUniqueInput
    update?: XOR<XOR<SchoolDirectorVerificationUpdateToOneWithWhereWithoutSchoolInput, SchoolDirectorVerificationUpdateWithoutSchoolInput>, SchoolDirectorVerificationUncheckedUpdateWithoutSchoolInput>
  }

  export type SchoolOwnershipVerificationUncheckedUpdateOneWithoutSchoolNestedInput = {
    create?: XOR<SchoolOwnershipVerificationCreateWithoutSchoolInput, SchoolOwnershipVerificationUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: SchoolOwnershipVerificationCreateOrConnectWithoutSchoolInput
    upsert?: SchoolOwnershipVerificationUpsertWithoutSchoolInput
    disconnect?: SchoolOwnershipVerificationWhereInput | boolean
    delete?: SchoolOwnershipVerificationWhereInput | boolean
    connect?: SchoolOwnershipVerificationWhereUniqueInput
    update?: XOR<XOR<SchoolOwnershipVerificationUpdateToOneWithWhereWithoutSchoolInput, SchoolOwnershipVerificationUpdateWithoutSchoolInput>, SchoolOwnershipVerificationUncheckedUpdateWithoutSchoolInput>
  }

  export type SchoolVerificationUncheckedUpdateOneWithoutSchoolNestedInput = {
    create?: XOR<SchoolVerificationCreateWithoutSchoolInput, SchoolVerificationUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: SchoolVerificationCreateOrConnectWithoutSchoolInput
    upsert?: SchoolVerificationUpsertWithoutSchoolInput
    disconnect?: SchoolVerificationWhereInput | boolean
    delete?: SchoolVerificationWhereInput | boolean
    connect?: SchoolVerificationWhereUniqueInput
    update?: XOR<XOR<SchoolVerificationUpdateToOneWithWhereWithoutSchoolInput, SchoolVerificationUpdateWithoutSchoolInput>, SchoolVerificationUncheckedUpdateWithoutSchoolInput>
  }

  export type SchoolPayoutDetailUncheckedUpdateOneWithoutSchoolNestedInput = {
    create?: XOR<SchoolPayoutDetailCreateWithoutSchoolInput, SchoolPayoutDetailUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: SchoolPayoutDetailCreateOrConnectWithoutSchoolInput
    upsert?: SchoolPayoutDetailUpsertWithoutSchoolInput
    disconnect?: SchoolPayoutDetailWhereInput | boolean
    delete?: SchoolPayoutDetailWhereInput | boolean
    connect?: SchoolPayoutDetailWhereUniqueInput
    update?: XOR<XOR<SchoolPayoutDetailUpdateToOneWithWhereWithoutSchoolInput, SchoolPayoutDetailUpdateWithoutSchoolInput>, SchoolPayoutDetailUncheckedUpdateWithoutSchoolInput>
  }

  export type SchoolAndPlatformLegalAgreementUncheckedUpdateOneWithoutSchoolNestedInput = {
    create?: XOR<SchoolAndPlatformLegalAgreementCreateWithoutSchoolInput, SchoolAndPlatformLegalAgreementUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: SchoolAndPlatformLegalAgreementCreateOrConnectWithoutSchoolInput
    upsert?: SchoolAndPlatformLegalAgreementUpsertWithoutSchoolInput
    disconnect?: SchoolAndPlatformLegalAgreementWhereInput | boolean
    delete?: SchoolAndPlatformLegalAgreementWhereInput | boolean
    connect?: SchoolAndPlatformLegalAgreementWhereUniqueInput
    update?: XOR<XOR<SchoolAndPlatformLegalAgreementUpdateToOneWithWhereWithoutSchoolInput, SchoolAndPlatformLegalAgreementUpdateWithoutSchoolInput>, SchoolAndPlatformLegalAgreementUncheckedUpdateWithoutSchoolInput>
  }

  export type ClassUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput> | ClassCreateWithoutSchoolInput[] | ClassUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSchoolInput | ClassCreateOrConnectWithoutSchoolInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutSchoolInput | ClassUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: ClassCreateManySchoolInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutSchoolInput | ClassUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutSchoolInput | ClassUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type AcademicSessionUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<AcademicSessionCreateWithoutSchoolInput, AcademicSessionUncheckedCreateWithoutSchoolInput> | AcademicSessionCreateWithoutSchoolInput[] | AcademicSessionUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: AcademicSessionCreateOrConnectWithoutSchoolInput | AcademicSessionCreateOrConnectWithoutSchoolInput[]
    upsert?: AcademicSessionUpsertWithWhereUniqueWithoutSchoolInput | AcademicSessionUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: AcademicSessionCreateManySchoolInputEnvelope
    set?: AcademicSessionWhereUniqueInput | AcademicSessionWhereUniqueInput[]
    disconnect?: AcademicSessionWhereUniqueInput | AcademicSessionWhereUniqueInput[]
    delete?: AcademicSessionWhereUniqueInput | AcademicSessionWhereUniqueInput[]
    connect?: AcademicSessionWhereUniqueInput | AcademicSessionWhereUniqueInput[]
    update?: AcademicSessionUpdateWithWhereUniqueWithoutSchoolInput | AcademicSessionUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: AcademicSessionUpdateManyWithWhereWithoutSchoolInput | AcademicSessionUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: AcademicSessionScalarWhereInput | AcademicSessionScalarWhereInput[]
  }

  export type TermUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<TermCreateWithoutSchoolInput, TermUncheckedCreateWithoutSchoolInput> | TermCreateWithoutSchoolInput[] | TermUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TermCreateOrConnectWithoutSchoolInput | TermCreateOrConnectWithoutSchoolInput[]
    upsert?: TermUpsertWithWhereUniqueWithoutSchoolInput | TermUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: TermCreateManySchoolInputEnvelope
    set?: TermWhereUniqueInput | TermWhereUniqueInput[]
    disconnect?: TermWhereUniqueInput | TermWhereUniqueInput[]
    delete?: TermWhereUniqueInput | TermWhereUniqueInput[]
    connect?: TermWhereUniqueInput | TermWhereUniqueInput[]
    update?: TermUpdateWithWhereUniqueWithoutSchoolInput | TermUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: TermUpdateManyWithWhereWithoutSchoolInput | TermUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: TermScalarWhereInput | TermScalarWhereInput[]
  }

  export type FeesUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<FeesCreateWithoutSchoolInput, FeesUncheckedCreateWithoutSchoolInput> | FeesCreateWithoutSchoolInput[] | FeesUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: FeesCreateOrConnectWithoutSchoolInput | FeesCreateOrConnectWithoutSchoolInput[]
    upsert?: FeesUpsertWithWhereUniqueWithoutSchoolInput | FeesUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: FeesCreateManySchoolInputEnvelope
    set?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    disconnect?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    delete?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    connect?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    update?: FeesUpdateWithWhereUniqueWithoutSchoolInput | FeesUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: FeesUpdateManyWithWhereWithoutSchoolInput | FeesUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: FeesScalarWhereInput | FeesScalarWhereInput[]
  }

  export type PayoutUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<PayoutCreateWithoutSchoolInput, PayoutUncheckedCreateWithoutSchoolInput> | PayoutCreateWithoutSchoolInput[] | PayoutUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: PayoutCreateOrConnectWithoutSchoolInput | PayoutCreateOrConnectWithoutSchoolInput[]
    upsert?: PayoutUpsertWithWhereUniqueWithoutSchoolInput | PayoutUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: PayoutCreateManySchoolInputEnvelope
    set?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    disconnect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    delete?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    connect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    update?: PayoutUpdateWithWhereUniqueWithoutSchoolInput | PayoutUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: PayoutUpdateManyWithWhereWithoutSchoolInput | PayoutUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: PayoutScalarWhereInput | PayoutScalarWhereInput[]
  }

  export type KYCVerificationUncheckedUpdateOneWithoutSchoolNestedInput = {
    create?: XOR<KYCVerificationCreateWithoutSchoolInput, KYCVerificationUncheckedCreateWithoutSchoolInput>
    connectOrCreate?: KYCVerificationCreateOrConnectWithoutSchoolInput
    upsert?: KYCVerificationUpsertWithoutSchoolInput
    disconnect?: KYCVerificationWhereInput | boolean
    delete?: KYCVerificationWhereInput | boolean
    connect?: KYCVerificationWhereUniqueInput
    update?: XOR<XOR<KYCVerificationUpdateToOneWithWhereWithoutSchoolInput, KYCVerificationUpdateWithoutSchoolInput>, KYCVerificationUncheckedUpdateWithoutSchoolInput>
  }

  export type SchoolCreateNestedOneWithoutSchoolDirectorVerificationInput = {
    create?: XOR<SchoolCreateWithoutSchoolDirectorVerificationInput, SchoolUncheckedCreateWithoutSchoolDirectorVerificationInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutSchoolDirectorVerificationInput
    connect?: SchoolWhereUniqueInput
  }

  export type EnumDirectorIDTypeFieldUpdateOperationsInput = {
    set?: $Enums.DirectorIDType
  }

  export type SchoolUpdateOneRequiredWithoutSchoolDirectorVerificationNestedInput = {
    create?: XOR<SchoolCreateWithoutSchoolDirectorVerificationInput, SchoolUncheckedCreateWithoutSchoolDirectorVerificationInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutSchoolDirectorVerificationInput
    upsert?: SchoolUpsertWithoutSchoolDirectorVerificationInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutSchoolDirectorVerificationInput, SchoolUpdateWithoutSchoolDirectorVerificationInput>, SchoolUncheckedUpdateWithoutSchoolDirectorVerificationInput>
  }

  export type SchoolCreateNestedOneWithoutSchoolOwnershipVerificationInput = {
    create?: XOR<SchoolCreateWithoutSchoolOwnershipVerificationInput, SchoolUncheckedCreateWithoutSchoolOwnershipVerificationInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutSchoolOwnershipVerificationInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutSchoolOwnershipVerificationNestedInput = {
    create?: XOR<SchoolCreateWithoutSchoolOwnershipVerificationInput, SchoolUncheckedCreateWithoutSchoolOwnershipVerificationInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutSchoolOwnershipVerificationInput
    upsert?: SchoolUpsertWithoutSchoolOwnershipVerificationInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutSchoolOwnershipVerificationInput, SchoolUpdateWithoutSchoolOwnershipVerificationInput>, SchoolUncheckedUpdateWithoutSchoolOwnershipVerificationInput>
  }

  export type SchoolCreateNestedOneWithoutSchoolVerificationInput = {
    create?: XOR<SchoolCreateWithoutSchoolVerificationInput, SchoolUncheckedCreateWithoutSchoolVerificationInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutSchoolVerificationInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutSchoolVerificationNestedInput = {
    create?: XOR<SchoolCreateWithoutSchoolVerificationInput, SchoolUncheckedCreateWithoutSchoolVerificationInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutSchoolVerificationInput
    upsert?: SchoolUpsertWithoutSchoolVerificationInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutSchoolVerificationInput, SchoolUpdateWithoutSchoolVerificationInput>, SchoolUncheckedUpdateWithoutSchoolVerificationInput>
  }

  export type SchoolCreateNestedOneWithoutSchoolPayoutDetailInput = {
    create?: XOR<SchoolCreateWithoutSchoolPayoutDetailInput, SchoolUncheckedCreateWithoutSchoolPayoutDetailInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutSchoolPayoutDetailInput
    connect?: SchoolWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutSchoolPayoutDetailNestedInput = {
    create?: XOR<SchoolCreateWithoutSchoolPayoutDetailInput, SchoolUncheckedCreateWithoutSchoolPayoutDetailInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutSchoolPayoutDetailInput
    upsert?: SchoolUpsertWithoutSchoolPayoutDetailInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutSchoolPayoutDetailInput, SchoolUpdateWithoutSchoolPayoutDetailInput>, SchoolUncheckedUpdateWithoutSchoolPayoutDetailInput>
  }

  export type SchoolCreateNestedOneWithoutSchoolAndPlatformLegalAgreementInput = {
    create?: XOR<SchoolCreateWithoutSchoolAndPlatformLegalAgreementInput, SchoolUncheckedCreateWithoutSchoolAndPlatformLegalAgreementInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutSchoolAndPlatformLegalAgreementInput
    connect?: SchoolWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSchoolAndPlatformLegalAgreementInput = {
    create?: XOR<UserCreateWithoutSchoolAndPlatformLegalAgreementInput, UserUncheckedCreateWithoutSchoolAndPlatformLegalAgreementInput>
    connectOrCreate?: UserCreateOrConnectWithoutSchoolAndPlatformLegalAgreementInput
    connect?: UserWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutSchoolAndPlatformLegalAgreementNestedInput = {
    create?: XOR<SchoolCreateWithoutSchoolAndPlatformLegalAgreementInput, SchoolUncheckedCreateWithoutSchoolAndPlatformLegalAgreementInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutSchoolAndPlatformLegalAgreementInput
    upsert?: SchoolUpsertWithoutSchoolAndPlatformLegalAgreementInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutSchoolAndPlatformLegalAgreementInput, SchoolUpdateWithoutSchoolAndPlatformLegalAgreementInput>, SchoolUncheckedUpdateWithoutSchoolAndPlatformLegalAgreementInput>
  }

  export type UserUpdateOneRequiredWithoutSchoolAndPlatformLegalAgreementNestedInput = {
    create?: XOR<UserCreateWithoutSchoolAndPlatformLegalAgreementInput, UserUncheckedCreateWithoutSchoolAndPlatformLegalAgreementInput>
    connectOrCreate?: UserCreateOrConnectWithoutSchoolAndPlatformLegalAgreementInput
    upsert?: UserUpsertWithoutSchoolAndPlatformLegalAgreementInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSchoolAndPlatformLegalAgreementInput, UserUpdateWithoutSchoolAndPlatformLegalAgreementInput>, UserUncheckedUpdateWithoutSchoolAndPlatformLegalAgreementInput>
  }

  export type UserCreateNestedOneWithoutKycverificationInput = {
    create?: XOR<UserCreateWithoutKycverificationInput, UserUncheckedCreateWithoutKycverificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutKycverificationInput
    connect?: UserWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutKycverificationInput = {
    create?: XOR<SchoolCreateWithoutKycverificationInput, SchoolUncheckedCreateWithoutKycverificationInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutKycverificationInput
    connect?: SchoolWhereUniqueInput
  }

  export type EnumKYCVerificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.KYCVerificationStatus
  }

  export type UserUpdateOneRequiredWithoutKycverificationNestedInput = {
    create?: XOR<UserCreateWithoutKycverificationInput, UserUncheckedCreateWithoutKycverificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutKycverificationInput
    upsert?: UserUpsertWithoutKycverificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutKycverificationInput, UserUpdateWithoutKycverificationInput>, UserUncheckedUpdateWithoutKycverificationInput>
  }

  export type SchoolUpdateOneRequiredWithoutKycverificationNestedInput = {
    create?: XOR<SchoolCreateWithoutKycverificationInput, SchoolUncheckedCreateWithoutKycverificationInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutKycverificationInput
    upsert?: SchoolUpsertWithoutKycverificationInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutKycverificationInput, SchoolUpdateWithoutKycverificationInput>, SchoolUncheckedUpdateWithoutKycverificationInput>
  }

  export type SchoolCreateNestedOneWithoutClassesInput = {
    create?: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutClassesInput
    connect?: SchoolWhereUniqueInput
  }

  export type FeesCreateNestedManyWithoutClassInput = {
    create?: XOR<FeesCreateWithoutClassInput, FeesUncheckedCreateWithoutClassInput> | FeesCreateWithoutClassInput[] | FeesUncheckedCreateWithoutClassInput[]
    connectOrCreate?: FeesCreateOrConnectWithoutClassInput | FeesCreateOrConnectWithoutClassInput[]
    createMany?: FeesCreateManyClassInputEnvelope
    connect?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutClassInput = {
    create?: XOR<InvoiceCreateWithoutClassInput, InvoiceUncheckedCreateWithoutClassInput> | InvoiceCreateWithoutClassInput[] | InvoiceUncheckedCreateWithoutClassInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClassInput | InvoiceCreateOrConnectWithoutClassInput[]
    createMany?: InvoiceCreateManyClassInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutClassInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type FeesUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<FeesCreateWithoutClassInput, FeesUncheckedCreateWithoutClassInput> | FeesCreateWithoutClassInput[] | FeesUncheckedCreateWithoutClassInput[]
    connectOrCreate?: FeesCreateOrConnectWithoutClassInput | FeesCreateOrConnectWithoutClassInput[]
    createMany?: FeesCreateManyClassInputEnvelope
    connect?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<InvoiceCreateWithoutClassInput, InvoiceUncheckedCreateWithoutClassInput> | InvoiceCreateWithoutClassInput[] | InvoiceUncheckedCreateWithoutClassInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClassInput | InvoiceCreateOrConnectWithoutClassInput[]
    createMany?: InvoiceCreateManyClassInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type SchoolUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutClassesInput
    upsert?: SchoolUpsertWithoutClassesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutClassesInput, SchoolUpdateWithoutClassesInput>, SchoolUncheckedUpdateWithoutClassesInput>
  }

  export type FeesUpdateManyWithoutClassNestedInput = {
    create?: XOR<FeesCreateWithoutClassInput, FeesUncheckedCreateWithoutClassInput> | FeesCreateWithoutClassInput[] | FeesUncheckedCreateWithoutClassInput[]
    connectOrCreate?: FeesCreateOrConnectWithoutClassInput | FeesCreateOrConnectWithoutClassInput[]
    upsert?: FeesUpsertWithWhereUniqueWithoutClassInput | FeesUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: FeesCreateManyClassInputEnvelope
    set?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    disconnect?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    delete?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    connect?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    update?: FeesUpdateWithWhereUniqueWithoutClassInput | FeesUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: FeesUpdateManyWithWhereWithoutClassInput | FeesUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: FeesScalarWhereInput | FeesScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutClassNestedInput = {
    create?: XOR<InvoiceCreateWithoutClassInput, InvoiceUncheckedCreateWithoutClassInput> | InvoiceCreateWithoutClassInput[] | InvoiceUncheckedCreateWithoutClassInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClassInput | InvoiceCreateOrConnectWithoutClassInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutClassInput | InvoiceUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: InvoiceCreateManyClassInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutClassInput | InvoiceUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutClassInput | InvoiceUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutClassNestedInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutClassInput | StudentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutClassInput | StudentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutClassInput | StudentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type FeesUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<FeesCreateWithoutClassInput, FeesUncheckedCreateWithoutClassInput> | FeesCreateWithoutClassInput[] | FeesUncheckedCreateWithoutClassInput[]
    connectOrCreate?: FeesCreateOrConnectWithoutClassInput | FeesCreateOrConnectWithoutClassInput[]
    upsert?: FeesUpsertWithWhereUniqueWithoutClassInput | FeesUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: FeesCreateManyClassInputEnvelope
    set?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    disconnect?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    delete?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    connect?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    update?: FeesUpdateWithWhereUniqueWithoutClassInput | FeesUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: FeesUpdateManyWithWhereWithoutClassInput | FeesUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: FeesScalarWhereInput | FeesScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<InvoiceCreateWithoutClassInput, InvoiceUncheckedCreateWithoutClassInput> | InvoiceCreateWithoutClassInput[] | InvoiceUncheckedCreateWithoutClassInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClassInput | InvoiceCreateOrConnectWithoutClassInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutClassInput | InvoiceUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: InvoiceCreateManyClassInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutClassInput | InvoiceUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutClassInput | InvoiceUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutClassInput | StudentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutClassInput | StudentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutClassInput | StudentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type SchoolCreateNestedOneWithoutAcademicSessionsInput = {
    create?: XOR<SchoolCreateWithoutAcademicSessionsInput, SchoolUncheckedCreateWithoutAcademicSessionsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutAcademicSessionsInput
    connect?: SchoolWhereUniqueInput
  }

  export type FeesCreateNestedManyWithoutAcademicSessionInput = {
    create?: XOR<FeesCreateWithoutAcademicSessionInput, FeesUncheckedCreateWithoutAcademicSessionInput> | FeesCreateWithoutAcademicSessionInput[] | FeesUncheckedCreateWithoutAcademicSessionInput[]
    connectOrCreate?: FeesCreateOrConnectWithoutAcademicSessionInput | FeesCreateOrConnectWithoutAcademicSessionInput[]
    createMany?: FeesCreateManyAcademicSessionInputEnvelope
    connect?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutAcademicSessionInput = {
    create?: XOR<InvoiceCreateWithoutAcademicSessionInput, InvoiceUncheckedCreateWithoutAcademicSessionInput> | InvoiceCreateWithoutAcademicSessionInput[] | InvoiceUncheckedCreateWithoutAcademicSessionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutAcademicSessionInput | InvoiceCreateOrConnectWithoutAcademicSessionInput[]
    createMany?: InvoiceCreateManyAcademicSessionInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type FeesUncheckedCreateNestedManyWithoutAcademicSessionInput = {
    create?: XOR<FeesCreateWithoutAcademicSessionInput, FeesUncheckedCreateWithoutAcademicSessionInput> | FeesCreateWithoutAcademicSessionInput[] | FeesUncheckedCreateWithoutAcademicSessionInput[]
    connectOrCreate?: FeesCreateOrConnectWithoutAcademicSessionInput | FeesCreateOrConnectWithoutAcademicSessionInput[]
    createMany?: FeesCreateManyAcademicSessionInputEnvelope
    connect?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutAcademicSessionInput = {
    create?: XOR<InvoiceCreateWithoutAcademicSessionInput, InvoiceUncheckedCreateWithoutAcademicSessionInput> | InvoiceCreateWithoutAcademicSessionInput[] | InvoiceUncheckedCreateWithoutAcademicSessionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutAcademicSessionInput | InvoiceCreateOrConnectWithoutAcademicSessionInput[]
    createMany?: InvoiceCreateManyAcademicSessionInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type SchoolUpdateOneRequiredWithoutAcademicSessionsNestedInput = {
    create?: XOR<SchoolCreateWithoutAcademicSessionsInput, SchoolUncheckedCreateWithoutAcademicSessionsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutAcademicSessionsInput
    upsert?: SchoolUpsertWithoutAcademicSessionsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutAcademicSessionsInput, SchoolUpdateWithoutAcademicSessionsInput>, SchoolUncheckedUpdateWithoutAcademicSessionsInput>
  }

  export type FeesUpdateManyWithoutAcademicSessionNestedInput = {
    create?: XOR<FeesCreateWithoutAcademicSessionInput, FeesUncheckedCreateWithoutAcademicSessionInput> | FeesCreateWithoutAcademicSessionInput[] | FeesUncheckedCreateWithoutAcademicSessionInput[]
    connectOrCreate?: FeesCreateOrConnectWithoutAcademicSessionInput | FeesCreateOrConnectWithoutAcademicSessionInput[]
    upsert?: FeesUpsertWithWhereUniqueWithoutAcademicSessionInput | FeesUpsertWithWhereUniqueWithoutAcademicSessionInput[]
    createMany?: FeesCreateManyAcademicSessionInputEnvelope
    set?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    disconnect?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    delete?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    connect?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    update?: FeesUpdateWithWhereUniqueWithoutAcademicSessionInput | FeesUpdateWithWhereUniqueWithoutAcademicSessionInput[]
    updateMany?: FeesUpdateManyWithWhereWithoutAcademicSessionInput | FeesUpdateManyWithWhereWithoutAcademicSessionInput[]
    deleteMany?: FeesScalarWhereInput | FeesScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutAcademicSessionNestedInput = {
    create?: XOR<InvoiceCreateWithoutAcademicSessionInput, InvoiceUncheckedCreateWithoutAcademicSessionInput> | InvoiceCreateWithoutAcademicSessionInput[] | InvoiceUncheckedCreateWithoutAcademicSessionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutAcademicSessionInput | InvoiceCreateOrConnectWithoutAcademicSessionInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutAcademicSessionInput | InvoiceUpsertWithWhereUniqueWithoutAcademicSessionInput[]
    createMany?: InvoiceCreateManyAcademicSessionInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutAcademicSessionInput | InvoiceUpdateWithWhereUniqueWithoutAcademicSessionInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutAcademicSessionInput | InvoiceUpdateManyWithWhereWithoutAcademicSessionInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type FeesUncheckedUpdateManyWithoutAcademicSessionNestedInput = {
    create?: XOR<FeesCreateWithoutAcademicSessionInput, FeesUncheckedCreateWithoutAcademicSessionInput> | FeesCreateWithoutAcademicSessionInput[] | FeesUncheckedCreateWithoutAcademicSessionInput[]
    connectOrCreate?: FeesCreateOrConnectWithoutAcademicSessionInput | FeesCreateOrConnectWithoutAcademicSessionInput[]
    upsert?: FeesUpsertWithWhereUniqueWithoutAcademicSessionInput | FeesUpsertWithWhereUniqueWithoutAcademicSessionInput[]
    createMany?: FeesCreateManyAcademicSessionInputEnvelope
    set?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    disconnect?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    delete?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    connect?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    update?: FeesUpdateWithWhereUniqueWithoutAcademicSessionInput | FeesUpdateWithWhereUniqueWithoutAcademicSessionInput[]
    updateMany?: FeesUpdateManyWithWhereWithoutAcademicSessionInput | FeesUpdateManyWithWhereWithoutAcademicSessionInput[]
    deleteMany?: FeesScalarWhereInput | FeesScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutAcademicSessionNestedInput = {
    create?: XOR<InvoiceCreateWithoutAcademicSessionInput, InvoiceUncheckedCreateWithoutAcademicSessionInput> | InvoiceCreateWithoutAcademicSessionInput[] | InvoiceUncheckedCreateWithoutAcademicSessionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutAcademicSessionInput | InvoiceCreateOrConnectWithoutAcademicSessionInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutAcademicSessionInput | InvoiceUpsertWithWhereUniqueWithoutAcademicSessionInput[]
    createMany?: InvoiceCreateManyAcademicSessionInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutAcademicSessionInput | InvoiceUpdateWithWhereUniqueWithoutAcademicSessionInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutAcademicSessionInput | InvoiceUpdateManyWithWhereWithoutAcademicSessionInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type SchoolCreateNestedOneWithoutTermsInput = {
    create?: XOR<SchoolCreateWithoutTermsInput, SchoolUncheckedCreateWithoutTermsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutTermsInput
    connect?: SchoolWhereUniqueInput
  }

  export type FeesCreateNestedManyWithoutTermInput = {
    create?: XOR<FeesCreateWithoutTermInput, FeesUncheckedCreateWithoutTermInput> | FeesCreateWithoutTermInput[] | FeesUncheckedCreateWithoutTermInput[]
    connectOrCreate?: FeesCreateOrConnectWithoutTermInput | FeesCreateOrConnectWithoutTermInput[]
    createMany?: FeesCreateManyTermInputEnvelope
    connect?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutTermInput = {
    create?: XOR<InvoiceCreateWithoutTermInput, InvoiceUncheckedCreateWithoutTermInput> | InvoiceCreateWithoutTermInput[] | InvoiceUncheckedCreateWithoutTermInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTermInput | InvoiceCreateOrConnectWithoutTermInput[]
    createMany?: InvoiceCreateManyTermInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type FeesUncheckedCreateNestedManyWithoutTermInput = {
    create?: XOR<FeesCreateWithoutTermInput, FeesUncheckedCreateWithoutTermInput> | FeesCreateWithoutTermInput[] | FeesUncheckedCreateWithoutTermInput[]
    connectOrCreate?: FeesCreateOrConnectWithoutTermInput | FeesCreateOrConnectWithoutTermInput[]
    createMany?: FeesCreateManyTermInputEnvelope
    connect?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutTermInput = {
    create?: XOR<InvoiceCreateWithoutTermInput, InvoiceUncheckedCreateWithoutTermInput> | InvoiceCreateWithoutTermInput[] | InvoiceUncheckedCreateWithoutTermInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTermInput | InvoiceCreateOrConnectWithoutTermInput[]
    createMany?: InvoiceCreateManyTermInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type SchoolUpdateOneRequiredWithoutTermsNestedInput = {
    create?: XOR<SchoolCreateWithoutTermsInput, SchoolUncheckedCreateWithoutTermsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutTermsInput
    upsert?: SchoolUpsertWithoutTermsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutTermsInput, SchoolUpdateWithoutTermsInput>, SchoolUncheckedUpdateWithoutTermsInput>
  }

  export type FeesUpdateManyWithoutTermNestedInput = {
    create?: XOR<FeesCreateWithoutTermInput, FeesUncheckedCreateWithoutTermInput> | FeesCreateWithoutTermInput[] | FeesUncheckedCreateWithoutTermInput[]
    connectOrCreate?: FeesCreateOrConnectWithoutTermInput | FeesCreateOrConnectWithoutTermInput[]
    upsert?: FeesUpsertWithWhereUniqueWithoutTermInput | FeesUpsertWithWhereUniqueWithoutTermInput[]
    createMany?: FeesCreateManyTermInputEnvelope
    set?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    disconnect?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    delete?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    connect?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    update?: FeesUpdateWithWhereUniqueWithoutTermInput | FeesUpdateWithWhereUniqueWithoutTermInput[]
    updateMany?: FeesUpdateManyWithWhereWithoutTermInput | FeesUpdateManyWithWhereWithoutTermInput[]
    deleteMany?: FeesScalarWhereInput | FeesScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutTermNestedInput = {
    create?: XOR<InvoiceCreateWithoutTermInput, InvoiceUncheckedCreateWithoutTermInput> | InvoiceCreateWithoutTermInput[] | InvoiceUncheckedCreateWithoutTermInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTermInput | InvoiceCreateOrConnectWithoutTermInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutTermInput | InvoiceUpsertWithWhereUniqueWithoutTermInput[]
    createMany?: InvoiceCreateManyTermInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutTermInput | InvoiceUpdateWithWhereUniqueWithoutTermInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutTermInput | InvoiceUpdateManyWithWhereWithoutTermInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type FeesUncheckedUpdateManyWithoutTermNestedInput = {
    create?: XOR<FeesCreateWithoutTermInput, FeesUncheckedCreateWithoutTermInput> | FeesCreateWithoutTermInput[] | FeesUncheckedCreateWithoutTermInput[]
    connectOrCreate?: FeesCreateOrConnectWithoutTermInput | FeesCreateOrConnectWithoutTermInput[]
    upsert?: FeesUpsertWithWhereUniqueWithoutTermInput | FeesUpsertWithWhereUniqueWithoutTermInput[]
    createMany?: FeesCreateManyTermInputEnvelope
    set?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    disconnect?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    delete?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    connect?: FeesWhereUniqueInput | FeesWhereUniqueInput[]
    update?: FeesUpdateWithWhereUniqueWithoutTermInput | FeesUpdateWithWhereUniqueWithoutTermInput[]
    updateMany?: FeesUpdateManyWithWhereWithoutTermInput | FeesUpdateManyWithWhereWithoutTermInput[]
    deleteMany?: FeesScalarWhereInput | FeesScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutTermNestedInput = {
    create?: XOR<InvoiceCreateWithoutTermInput, InvoiceUncheckedCreateWithoutTermInput> | InvoiceCreateWithoutTermInput[] | InvoiceUncheckedCreateWithoutTermInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTermInput | InvoiceCreateOrConnectWithoutTermInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutTermInput | InvoiceUpsertWithWhereUniqueWithoutTermInput[]
    createMany?: InvoiceCreateManyTermInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutTermInput | InvoiceUpdateWithWhereUniqueWithoutTermInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutTermInput | InvoiceUpdateManyWithWhereWithoutTermInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type ClassCreateNestedOneWithoutFeesInput = {
    create?: XOR<ClassCreateWithoutFeesInput, ClassUncheckedCreateWithoutFeesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutFeesInput
    connect?: ClassWhereUniqueInput
  }

  export type AcademicSessionCreateNestedOneWithoutFeesInput = {
    create?: XOR<AcademicSessionCreateWithoutFeesInput, AcademicSessionUncheckedCreateWithoutFeesInput>
    connectOrCreate?: AcademicSessionCreateOrConnectWithoutFeesInput
    connect?: AcademicSessionWhereUniqueInput
  }

  export type TermCreateNestedOneWithoutFeesInput = {
    create?: XOR<TermCreateWithoutFeesInput, TermUncheckedCreateWithoutFeesInput>
    connectOrCreate?: TermCreateOrConnectWithoutFeesInput
    connect?: TermWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutFeesInput = {
    create?: XOR<SchoolCreateWithoutFeesInput, SchoolUncheckedCreateWithoutFeesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutFeesInput
    connect?: SchoolWhereUniqueInput
  }

  export type FeeBreakdownCreateNestedManyWithoutFeeInput = {
    create?: XOR<FeeBreakdownCreateWithoutFeeInput, FeeBreakdownUncheckedCreateWithoutFeeInput> | FeeBreakdownCreateWithoutFeeInput[] | FeeBreakdownUncheckedCreateWithoutFeeInput[]
    connectOrCreate?: FeeBreakdownCreateOrConnectWithoutFeeInput | FeeBreakdownCreateOrConnectWithoutFeeInput[]
    createMany?: FeeBreakdownCreateManyFeeInputEnvelope
    connect?: FeeBreakdownWhereUniqueInput | FeeBreakdownWhereUniqueInput[]
  }

  export type FeeBreakdownUncheckedCreateNestedManyWithoutFeeInput = {
    create?: XOR<FeeBreakdownCreateWithoutFeeInput, FeeBreakdownUncheckedCreateWithoutFeeInput> | FeeBreakdownCreateWithoutFeeInput[] | FeeBreakdownUncheckedCreateWithoutFeeInput[]
    connectOrCreate?: FeeBreakdownCreateOrConnectWithoutFeeInput | FeeBreakdownCreateOrConnectWithoutFeeInput[]
    createMany?: FeeBreakdownCreateManyFeeInputEnvelope
    connect?: FeeBreakdownWhereUniqueInput | FeeBreakdownWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ClassUpdateOneRequiredWithoutFeesNestedInput = {
    create?: XOR<ClassCreateWithoutFeesInput, ClassUncheckedCreateWithoutFeesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutFeesInput
    upsert?: ClassUpsertWithoutFeesInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutFeesInput, ClassUpdateWithoutFeesInput>, ClassUncheckedUpdateWithoutFeesInput>
  }

  export type AcademicSessionUpdateOneRequiredWithoutFeesNestedInput = {
    create?: XOR<AcademicSessionCreateWithoutFeesInput, AcademicSessionUncheckedCreateWithoutFeesInput>
    connectOrCreate?: AcademicSessionCreateOrConnectWithoutFeesInput
    upsert?: AcademicSessionUpsertWithoutFeesInput
    connect?: AcademicSessionWhereUniqueInput
    update?: XOR<XOR<AcademicSessionUpdateToOneWithWhereWithoutFeesInput, AcademicSessionUpdateWithoutFeesInput>, AcademicSessionUncheckedUpdateWithoutFeesInput>
  }

  export type TermUpdateOneRequiredWithoutFeesNestedInput = {
    create?: XOR<TermCreateWithoutFeesInput, TermUncheckedCreateWithoutFeesInput>
    connectOrCreate?: TermCreateOrConnectWithoutFeesInput
    upsert?: TermUpsertWithoutFeesInput
    connect?: TermWhereUniqueInput
    update?: XOR<XOR<TermUpdateToOneWithWhereWithoutFeesInput, TermUpdateWithoutFeesInput>, TermUncheckedUpdateWithoutFeesInput>
  }

  export type SchoolUpdateOneRequiredWithoutFeesNestedInput = {
    create?: XOR<SchoolCreateWithoutFeesInput, SchoolUncheckedCreateWithoutFeesInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutFeesInput
    upsert?: SchoolUpsertWithoutFeesInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutFeesInput, SchoolUpdateWithoutFeesInput>, SchoolUncheckedUpdateWithoutFeesInput>
  }

  export type FeeBreakdownUpdateManyWithoutFeeNestedInput = {
    create?: XOR<FeeBreakdownCreateWithoutFeeInput, FeeBreakdownUncheckedCreateWithoutFeeInput> | FeeBreakdownCreateWithoutFeeInput[] | FeeBreakdownUncheckedCreateWithoutFeeInput[]
    connectOrCreate?: FeeBreakdownCreateOrConnectWithoutFeeInput | FeeBreakdownCreateOrConnectWithoutFeeInput[]
    upsert?: FeeBreakdownUpsertWithWhereUniqueWithoutFeeInput | FeeBreakdownUpsertWithWhereUniqueWithoutFeeInput[]
    createMany?: FeeBreakdownCreateManyFeeInputEnvelope
    set?: FeeBreakdownWhereUniqueInput | FeeBreakdownWhereUniqueInput[]
    disconnect?: FeeBreakdownWhereUniqueInput | FeeBreakdownWhereUniqueInput[]
    delete?: FeeBreakdownWhereUniqueInput | FeeBreakdownWhereUniqueInput[]
    connect?: FeeBreakdownWhereUniqueInput | FeeBreakdownWhereUniqueInput[]
    update?: FeeBreakdownUpdateWithWhereUniqueWithoutFeeInput | FeeBreakdownUpdateWithWhereUniqueWithoutFeeInput[]
    updateMany?: FeeBreakdownUpdateManyWithWhereWithoutFeeInput | FeeBreakdownUpdateManyWithWhereWithoutFeeInput[]
    deleteMany?: FeeBreakdownScalarWhereInput | FeeBreakdownScalarWhereInput[]
  }

  export type FeeBreakdownUncheckedUpdateManyWithoutFeeNestedInput = {
    create?: XOR<FeeBreakdownCreateWithoutFeeInput, FeeBreakdownUncheckedCreateWithoutFeeInput> | FeeBreakdownCreateWithoutFeeInput[] | FeeBreakdownUncheckedCreateWithoutFeeInput[]
    connectOrCreate?: FeeBreakdownCreateOrConnectWithoutFeeInput | FeeBreakdownCreateOrConnectWithoutFeeInput[]
    upsert?: FeeBreakdownUpsertWithWhereUniqueWithoutFeeInput | FeeBreakdownUpsertWithWhereUniqueWithoutFeeInput[]
    createMany?: FeeBreakdownCreateManyFeeInputEnvelope
    set?: FeeBreakdownWhereUniqueInput | FeeBreakdownWhereUniqueInput[]
    disconnect?: FeeBreakdownWhereUniqueInput | FeeBreakdownWhereUniqueInput[]
    delete?: FeeBreakdownWhereUniqueInput | FeeBreakdownWhereUniqueInput[]
    connect?: FeeBreakdownWhereUniqueInput | FeeBreakdownWhereUniqueInput[]
    update?: FeeBreakdownUpdateWithWhereUniqueWithoutFeeInput | FeeBreakdownUpdateWithWhereUniqueWithoutFeeInput[]
    updateMany?: FeeBreakdownUpdateManyWithWhereWithoutFeeInput | FeeBreakdownUpdateManyWithWhereWithoutFeeInput[]
    deleteMany?: FeeBreakdownScalarWhereInput | FeeBreakdownScalarWhereInput[]
  }

  export type FeesCreateNestedOneWithoutFeeBreakdownsInput = {
    create?: XOR<FeesCreateWithoutFeeBreakdownsInput, FeesUncheckedCreateWithoutFeeBreakdownsInput>
    connectOrCreate?: FeesCreateOrConnectWithoutFeeBreakdownsInput
    connect?: FeesWhereUniqueInput
  }

  export type FeesUpdateOneRequiredWithoutFeeBreakdownsNestedInput = {
    create?: XOR<FeesCreateWithoutFeeBreakdownsInput, FeesUncheckedCreateWithoutFeeBreakdownsInput>
    connectOrCreate?: FeesCreateOrConnectWithoutFeeBreakdownsInput
    upsert?: FeesUpsertWithoutFeeBreakdownsInput
    connect?: FeesWhereUniqueInput
    update?: XOR<XOR<FeesUpdateToOneWithWhereWithoutFeeBreakdownsInput, FeesUpdateWithoutFeeBreakdownsInput>, FeesUncheckedUpdateWithoutFeeBreakdownsInput>
  }

  export type GuardianCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<GuardianCreateWithoutInvoicesInput, GuardianUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: GuardianCreateOrConnectWithoutInvoicesInput
    connect?: GuardianWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<ClassCreateWithoutInvoicesInput, ClassUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutInvoicesInput
    connect?: ClassWhereUniqueInput
  }

  export type AcademicSessionCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<AcademicSessionCreateWithoutInvoicesInput, AcademicSessionUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: AcademicSessionCreateOrConnectWithoutInvoicesInput
    connect?: AcademicSessionWhereUniqueInput
  }

  export type TermCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<TermCreateWithoutInvoicesInput, TermUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: TermCreateOrConnectWithoutInvoicesInput
    connect?: TermWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput> | TransactionCreateWithoutInvoiceInput[] | TransactionUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutInvoiceInput | TransactionCreateOrConnectWithoutInvoiceInput[]
    createMany?: TransactionCreateManyInvoiceInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput> | TransactionCreateWithoutInvoiceInput[] | TransactionUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutInvoiceInput | TransactionCreateOrConnectWithoutInvoiceInput[]
    createMany?: TransactionCreateManyInvoiceInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type GuardianUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<GuardianCreateWithoutInvoicesInput, GuardianUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: GuardianCreateOrConnectWithoutInvoicesInput
    upsert?: GuardianUpsertWithoutInvoicesInput
    connect?: GuardianWhereUniqueInput
    update?: XOR<XOR<GuardianUpdateToOneWithWhereWithoutInvoicesInput, GuardianUpdateWithoutInvoicesInput>, GuardianUncheckedUpdateWithoutInvoicesInput>
  }

  export type ClassUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<ClassCreateWithoutInvoicesInput, ClassUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutInvoicesInput
    upsert?: ClassUpsertWithoutInvoicesInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutInvoicesInput, ClassUpdateWithoutInvoicesInput>, ClassUncheckedUpdateWithoutInvoicesInput>
  }

  export type AcademicSessionUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<AcademicSessionCreateWithoutInvoicesInput, AcademicSessionUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: AcademicSessionCreateOrConnectWithoutInvoicesInput
    upsert?: AcademicSessionUpsertWithoutInvoicesInput
    connect?: AcademicSessionWhereUniqueInput
    update?: XOR<XOR<AcademicSessionUpdateToOneWithWhereWithoutInvoicesInput, AcademicSessionUpdateWithoutInvoicesInput>, AcademicSessionUncheckedUpdateWithoutInvoicesInput>
  }

  export type TermUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<TermCreateWithoutInvoicesInput, TermUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: TermCreateOrConnectWithoutInvoicesInput
    upsert?: TermUpsertWithoutInvoicesInput
    connect?: TermWhereUniqueInput
    update?: XOR<XOR<TermUpdateToOneWithWhereWithoutInvoicesInput, TermUpdateWithoutInvoicesInput>, TermUncheckedUpdateWithoutInvoicesInput>
  }

  export type TransactionUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput> | TransactionCreateWithoutInvoiceInput[] | TransactionUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutInvoiceInput | TransactionCreateOrConnectWithoutInvoiceInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutInvoiceInput | TransactionUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: TransactionCreateManyInvoiceInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutInvoiceInput | TransactionUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutInvoiceInput | TransactionUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput> | TransactionCreateWithoutInvoiceInput[] | TransactionUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutInvoiceInput | TransactionCreateOrConnectWithoutInvoiceInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutInvoiceInput | TransactionUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: TransactionCreateManyInvoiceInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutInvoiceInput | TransactionUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutInvoiceInput | TransactionUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ClassCreateNestedOneWithoutStudentsInput = {
    create?: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutStudentsInput
    connect?: ClassWhereUniqueInput
  }

  export type GuardianCreateNestedOneWithoutStudentsInput = {
    create?: XOR<GuardianCreateWithoutStudentsInput, GuardianUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: GuardianCreateOrConnectWithoutStudentsInput
    connect?: GuardianWhereUniqueInput
  }

  export type LinkedStudentProfileCreateNestedOneWithoutStudentInput = {
    create?: XOR<LinkedStudentProfileCreateWithoutStudentInput, LinkedStudentProfileUncheckedCreateWithoutStudentInput>
    connectOrCreate?: LinkedStudentProfileCreateOrConnectWithoutStudentInput
    connect?: LinkedStudentProfileWhereUniqueInput
  }

  export type LinkedStudentProfileUncheckedCreateNestedOneWithoutStudentInput = {
    create?: XOR<LinkedStudentProfileCreateWithoutStudentInput, LinkedStudentProfileUncheckedCreateWithoutStudentInput>
    connectOrCreate?: LinkedStudentProfileCreateOrConnectWithoutStudentInput
    connect?: LinkedStudentProfileWhereUniqueInput
  }

  export type EnumStudentStatusFieldUpdateOperationsInput = {
    set?: $Enums.StudentStatus
  }

  export type ClassUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutStudentsInput
    upsert?: ClassUpsertWithoutStudentsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutStudentsInput, ClassUpdateWithoutStudentsInput>, ClassUncheckedUpdateWithoutStudentsInput>
  }

  export type GuardianUpdateOneWithoutStudentsNestedInput = {
    create?: XOR<GuardianCreateWithoutStudentsInput, GuardianUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: GuardianCreateOrConnectWithoutStudentsInput
    upsert?: GuardianUpsertWithoutStudentsInput
    disconnect?: GuardianWhereInput | boolean
    delete?: GuardianWhereInput | boolean
    connect?: GuardianWhereUniqueInput
    update?: XOR<XOR<GuardianUpdateToOneWithWhereWithoutStudentsInput, GuardianUpdateWithoutStudentsInput>, GuardianUncheckedUpdateWithoutStudentsInput>
  }

  export type LinkedStudentProfileUpdateOneWithoutStudentNestedInput = {
    create?: XOR<LinkedStudentProfileCreateWithoutStudentInput, LinkedStudentProfileUncheckedCreateWithoutStudentInput>
    connectOrCreate?: LinkedStudentProfileCreateOrConnectWithoutStudentInput
    upsert?: LinkedStudentProfileUpsertWithoutStudentInput
    disconnect?: LinkedStudentProfileWhereInput | boolean
    delete?: LinkedStudentProfileWhereInput | boolean
    connect?: LinkedStudentProfileWhereUniqueInput
    update?: XOR<XOR<LinkedStudentProfileUpdateToOneWithWhereWithoutStudentInput, LinkedStudentProfileUpdateWithoutStudentInput>, LinkedStudentProfileUncheckedUpdateWithoutStudentInput>
  }

  export type LinkedStudentProfileUncheckedUpdateOneWithoutStudentNestedInput = {
    create?: XOR<LinkedStudentProfileCreateWithoutStudentInput, LinkedStudentProfileUncheckedCreateWithoutStudentInput>
    connectOrCreate?: LinkedStudentProfileCreateOrConnectWithoutStudentInput
    upsert?: LinkedStudentProfileUpsertWithoutStudentInput
    disconnect?: LinkedStudentProfileWhereInput | boolean
    delete?: LinkedStudentProfileWhereInput | boolean
    connect?: LinkedStudentProfileWhereUniqueInput
    update?: XOR<XOR<LinkedStudentProfileUpdateToOneWithWhereWithoutStudentInput, LinkedStudentProfileUpdateWithoutStudentInput>, LinkedStudentProfileUncheckedUpdateWithoutStudentInput>
  }

  export type StudentCreateNestedOneWithoutLinkedStudentProfileInput = {
    create?: XOR<StudentCreateWithoutLinkedStudentProfileInput, StudentUncheckedCreateWithoutLinkedStudentProfileInput>
    connectOrCreate?: StudentCreateOrConnectWithoutLinkedStudentProfileInput
    connect?: StudentWhereUniqueInput
  }

  export type GuardianCreateNestedOneWithoutLinkedStudentProfilesInput = {
    create?: XOR<GuardianCreateWithoutLinkedStudentProfilesInput, GuardianUncheckedCreateWithoutLinkedStudentProfilesInput>
    connectOrCreate?: GuardianCreateOrConnectWithoutLinkedStudentProfilesInput
    connect?: GuardianWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutLinkedStudentProfileNestedInput = {
    create?: XOR<StudentCreateWithoutLinkedStudentProfileInput, StudentUncheckedCreateWithoutLinkedStudentProfileInput>
    connectOrCreate?: StudentCreateOrConnectWithoutLinkedStudentProfileInput
    upsert?: StudentUpsertWithoutLinkedStudentProfileInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutLinkedStudentProfileInput, StudentUpdateWithoutLinkedStudentProfileInput>, StudentUncheckedUpdateWithoutLinkedStudentProfileInput>
  }

  export type GuardianUpdateOneRequiredWithoutLinkedStudentProfilesNestedInput = {
    create?: XOR<GuardianCreateWithoutLinkedStudentProfilesInput, GuardianUncheckedCreateWithoutLinkedStudentProfilesInput>
    connectOrCreate?: GuardianCreateOrConnectWithoutLinkedStudentProfilesInput
    upsert?: GuardianUpsertWithoutLinkedStudentProfilesInput
    connect?: GuardianWhereUniqueInput
    update?: XOR<XOR<GuardianUpdateToOneWithWhereWithoutLinkedStudentProfilesInput, GuardianUpdateWithoutLinkedStudentProfilesInput>, GuardianUncheckedUpdateWithoutLinkedStudentProfilesInput>
  }

  export type InvoiceCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutTransactionsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type GuardianCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<GuardianCreateWithoutTransactionsInput, GuardianUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: GuardianCreateOrConnectWithoutTransactionsInput
    connect?: GuardianWhereUniqueInput
  }

  export type TransactionFeeCreateNestedOneWithoutTransactionInput = {
    create?: XOR<TransactionFeeCreateWithoutTransactionInput, TransactionFeeUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: TransactionFeeCreateOrConnectWithoutTransactionInput
    connect?: TransactionFeeWhereUniqueInput
  }

  export type TransactionFeeUncheckedCreateNestedOneWithoutTransactionInput = {
    create?: XOR<TransactionFeeCreateWithoutTransactionInput, TransactionFeeUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: TransactionFeeCreateOrConnectWithoutTransactionInput
    connect?: TransactionFeeWhereUniqueInput
  }

  export type EnumTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransactionStatus
  }

  export type InvoiceUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutTransactionsInput
    upsert?: InvoiceUpsertWithoutTransactionsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutTransactionsInput, InvoiceUpdateWithoutTransactionsInput>, InvoiceUncheckedUpdateWithoutTransactionsInput>
  }

  export type GuardianUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<GuardianCreateWithoutTransactionsInput, GuardianUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: GuardianCreateOrConnectWithoutTransactionsInput
    upsert?: GuardianUpsertWithoutTransactionsInput
    connect?: GuardianWhereUniqueInput
    update?: XOR<XOR<GuardianUpdateToOneWithWhereWithoutTransactionsInput, GuardianUpdateWithoutTransactionsInput>, GuardianUncheckedUpdateWithoutTransactionsInput>
  }

  export type TransactionFeeUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<TransactionFeeCreateWithoutTransactionInput, TransactionFeeUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: TransactionFeeCreateOrConnectWithoutTransactionInput
    upsert?: TransactionFeeUpsertWithoutTransactionInput
    disconnect?: TransactionFeeWhereInput | boolean
    delete?: TransactionFeeWhereInput | boolean
    connect?: TransactionFeeWhereUniqueInput
    update?: XOR<XOR<TransactionFeeUpdateToOneWithWhereWithoutTransactionInput, TransactionFeeUpdateWithoutTransactionInput>, TransactionFeeUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionFeeUncheckedUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<TransactionFeeCreateWithoutTransactionInput, TransactionFeeUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: TransactionFeeCreateOrConnectWithoutTransactionInput
    upsert?: TransactionFeeUpsertWithoutTransactionInput
    disconnect?: TransactionFeeWhereInput | boolean
    delete?: TransactionFeeWhereInput | boolean
    connect?: TransactionFeeWhereUniqueInput
    update?: XOR<XOR<TransactionFeeUpdateToOneWithWhereWithoutTransactionInput, TransactionFeeUpdateWithoutTransactionInput>, TransactionFeeUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionCreateNestedOneWithoutTransactionFeeInput = {
    create?: XOR<TransactionCreateWithoutTransactionFeeInput, TransactionUncheckedCreateWithoutTransactionFeeInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutTransactionFeeInput
    connect?: TransactionWhereUniqueInput
  }

  export type TransactionUpdateOneRequiredWithoutTransactionFeeNestedInput = {
    create?: XOR<TransactionCreateWithoutTransactionFeeInput, TransactionUncheckedCreateWithoutTransactionFeeInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutTransactionFeeInput
    upsert?: TransactionUpsertWithoutTransactionFeeInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutTransactionFeeInput, TransactionUpdateWithoutTransactionFeeInput>, TransactionUncheckedUpdateWithoutTransactionFeeInput>
  }

  export type SchoolCreateNestedOneWithoutPayoutsInput = {
    create?: XOR<SchoolCreateWithoutPayoutsInput, SchoolUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutPayoutsInput
    connect?: SchoolWhereUniqueInput
  }

  export type EnumPayoutStatusFieldUpdateOperationsInput = {
    set?: $Enums.PayoutStatus
  }

  export type SchoolUpdateOneRequiredWithoutPayoutsNestedInput = {
    create?: XOR<SchoolCreateWithoutPayoutsInput, SchoolUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutPayoutsInput
    upsert?: SchoolUpsertWithoutPayoutsInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<XOR<SchoolUpdateToOneWithWhereWithoutPayoutsInput, SchoolUpdateWithoutPayoutsInput>, SchoolUncheckedUpdateWithoutPayoutsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.NotificationStatus
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutWalletInput = {
    create?: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletInput
    connect?: UserWhereUniqueInput
  }

  export type LedgerCreateNestedManyWithoutWalletInput = {
    create?: XOR<LedgerCreateWithoutWalletInput, LedgerUncheckedCreateWithoutWalletInput> | LedgerCreateWithoutWalletInput[] | LedgerUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: LedgerCreateOrConnectWithoutWalletInput | LedgerCreateOrConnectWithoutWalletInput[]
    createMany?: LedgerCreateManyWalletInputEnvelope
    connect?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
  }

  export type WalletTransactionCreateNestedManyWithoutWalletInput = {
    create?: XOR<WalletTransactionCreateWithoutWalletInput, WalletTransactionUncheckedCreateWithoutWalletInput> | WalletTransactionCreateWithoutWalletInput[] | WalletTransactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutWalletInput | WalletTransactionCreateOrConnectWithoutWalletInput[]
    createMany?: WalletTransactionCreateManyWalletInputEnvelope
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
  }

  export type LedgerUncheckedCreateNestedManyWithoutWalletInput = {
    create?: XOR<LedgerCreateWithoutWalletInput, LedgerUncheckedCreateWithoutWalletInput> | LedgerCreateWithoutWalletInput[] | LedgerUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: LedgerCreateOrConnectWithoutWalletInput | LedgerCreateOrConnectWithoutWalletInput[]
    createMany?: LedgerCreateManyWalletInputEnvelope
    connect?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
  }

  export type WalletTransactionUncheckedCreateNestedManyWithoutWalletInput = {
    create?: XOR<WalletTransactionCreateWithoutWalletInput, WalletTransactionUncheckedCreateWithoutWalletInput> | WalletTransactionCreateWithoutWalletInput[] | WalletTransactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutWalletInput | WalletTransactionCreateOrConnectWithoutWalletInput[]
    createMany?: WalletTransactionCreateManyWalletInputEnvelope
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
  }

  export type EnumWalletStatusFieldUpdateOperationsInput = {
    set?: $Enums.WalletStatus
  }

  export type UserUpdateOneRequiredWithoutWalletNestedInput = {
    create?: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletInput
    upsert?: UserUpsertWithoutWalletInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWalletInput, UserUpdateWithoutWalletInput>, UserUncheckedUpdateWithoutWalletInput>
  }

  export type LedgerUpdateManyWithoutWalletNestedInput = {
    create?: XOR<LedgerCreateWithoutWalletInput, LedgerUncheckedCreateWithoutWalletInput> | LedgerCreateWithoutWalletInput[] | LedgerUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: LedgerCreateOrConnectWithoutWalletInput | LedgerCreateOrConnectWithoutWalletInput[]
    upsert?: LedgerUpsertWithWhereUniqueWithoutWalletInput | LedgerUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: LedgerCreateManyWalletInputEnvelope
    set?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
    disconnect?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
    delete?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
    connect?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
    update?: LedgerUpdateWithWhereUniqueWithoutWalletInput | LedgerUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: LedgerUpdateManyWithWhereWithoutWalletInput | LedgerUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: LedgerScalarWhereInput | LedgerScalarWhereInput[]
  }

  export type WalletTransactionUpdateManyWithoutWalletNestedInput = {
    create?: XOR<WalletTransactionCreateWithoutWalletInput, WalletTransactionUncheckedCreateWithoutWalletInput> | WalletTransactionCreateWithoutWalletInput[] | WalletTransactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutWalletInput | WalletTransactionCreateOrConnectWithoutWalletInput[]
    upsert?: WalletTransactionUpsertWithWhereUniqueWithoutWalletInput | WalletTransactionUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: WalletTransactionCreateManyWalletInputEnvelope
    set?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    disconnect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    delete?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    update?: WalletTransactionUpdateWithWhereUniqueWithoutWalletInput | WalletTransactionUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: WalletTransactionUpdateManyWithWhereWithoutWalletInput | WalletTransactionUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
  }

  export type LedgerUncheckedUpdateManyWithoutWalletNestedInput = {
    create?: XOR<LedgerCreateWithoutWalletInput, LedgerUncheckedCreateWithoutWalletInput> | LedgerCreateWithoutWalletInput[] | LedgerUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: LedgerCreateOrConnectWithoutWalletInput | LedgerCreateOrConnectWithoutWalletInput[]
    upsert?: LedgerUpsertWithWhereUniqueWithoutWalletInput | LedgerUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: LedgerCreateManyWalletInputEnvelope
    set?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
    disconnect?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
    delete?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
    connect?: LedgerWhereUniqueInput | LedgerWhereUniqueInput[]
    update?: LedgerUpdateWithWhereUniqueWithoutWalletInput | LedgerUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: LedgerUpdateManyWithWhereWithoutWalletInput | LedgerUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: LedgerScalarWhereInput | LedgerScalarWhereInput[]
  }

  export type WalletTransactionUncheckedUpdateManyWithoutWalletNestedInput = {
    create?: XOR<WalletTransactionCreateWithoutWalletInput, WalletTransactionUncheckedCreateWithoutWalletInput> | WalletTransactionCreateWithoutWalletInput[] | WalletTransactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutWalletInput | WalletTransactionCreateOrConnectWithoutWalletInput[]
    upsert?: WalletTransactionUpsertWithWhereUniqueWithoutWalletInput | WalletTransactionUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: WalletTransactionCreateManyWalletInputEnvelope
    set?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    disconnect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    delete?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    update?: WalletTransactionUpdateWithWhereUniqueWithoutWalletInput | WalletTransactionUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: WalletTransactionUpdateManyWithWhereWithoutWalletInput | WalletTransactionUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
  }

  export type WalletCreateNestedOneWithoutTransactionInput = {
    create?: XOR<WalletCreateWithoutTransactionInput, WalletUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: WalletCreateOrConnectWithoutTransactionInput
    connect?: WalletWhereUniqueInput
  }

  export type LedgerCreateNestedOneWithoutTransactionInput = {
    create?: XOR<LedgerCreateWithoutTransactionInput, LedgerUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: LedgerCreateOrConnectWithoutTransactionInput
    connect?: LedgerWhereUniqueInput
  }

  export type LedgerUncheckedCreateNestedOneWithoutTransactionInput = {
    create?: XOR<LedgerCreateWithoutTransactionInput, LedgerUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: LedgerCreateOrConnectWithoutTransactionInput
    connect?: LedgerWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type EnumTransactionFlowFieldUpdateOperationsInput = {
    set?: $Enums.TransactionFlow
  }

  export type WalletUpdateOneRequiredWithoutTransactionNestedInput = {
    create?: XOR<WalletCreateWithoutTransactionInput, WalletUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: WalletCreateOrConnectWithoutTransactionInput
    upsert?: WalletUpsertWithoutTransactionInput
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutTransactionInput, WalletUpdateWithoutTransactionInput>, WalletUncheckedUpdateWithoutTransactionInput>
  }

  export type LedgerUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<LedgerCreateWithoutTransactionInput, LedgerUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: LedgerCreateOrConnectWithoutTransactionInput
    upsert?: LedgerUpsertWithoutTransactionInput
    disconnect?: LedgerWhereInput | boolean
    delete?: LedgerWhereInput | boolean
    connect?: LedgerWhereUniqueInput
    update?: XOR<XOR<LedgerUpdateToOneWithWhereWithoutTransactionInput, LedgerUpdateWithoutTransactionInput>, LedgerUncheckedUpdateWithoutTransactionInput>
  }

  export type LedgerUncheckedUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<LedgerCreateWithoutTransactionInput, LedgerUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: LedgerCreateOrConnectWithoutTransactionInput
    upsert?: LedgerUpsertWithoutTransactionInput
    disconnect?: LedgerWhereInput | boolean
    delete?: LedgerWhereInput | boolean
    connect?: LedgerWhereUniqueInput
    update?: XOR<XOR<LedgerUpdateToOneWithWhereWithoutTransactionInput, LedgerUpdateWithoutTransactionInput>, LedgerUncheckedUpdateWithoutTransactionInput>
  }

  export type WalletCreateNestedOneWithoutLedgerInput = {
    create?: XOR<WalletCreateWithoutLedgerInput, WalletUncheckedCreateWithoutLedgerInput>
    connectOrCreate?: WalletCreateOrConnectWithoutLedgerInput
    connect?: WalletWhereUniqueInput
  }

  export type WalletTransactionCreateNestedOneWithoutLedgerInput = {
    create?: XOR<WalletTransactionCreateWithoutLedgerInput, WalletTransactionUncheckedCreateWithoutLedgerInput>
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutLedgerInput
    connect?: WalletTransactionWhereUniqueInput
  }

  export type WalletUpdateOneRequiredWithoutLedgerNestedInput = {
    create?: XOR<WalletCreateWithoutLedgerInput, WalletUncheckedCreateWithoutLedgerInput>
    connectOrCreate?: WalletCreateOrConnectWithoutLedgerInput
    upsert?: WalletUpsertWithoutLedgerInput
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutLedgerInput, WalletUpdateWithoutLedgerInput>, WalletUncheckedUpdateWithoutLedgerInput>
  }

  export type WalletTransactionUpdateOneRequiredWithoutLedgerNestedInput = {
    create?: XOR<WalletTransactionCreateWithoutLedgerInput, WalletTransactionUncheckedCreateWithoutLedgerInput>
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutLedgerInput
    upsert?: WalletTransactionUpsertWithoutLedgerInput
    connect?: WalletTransactionWhereUniqueInput
    update?: XOR<XOR<WalletTransactionUpdateToOneWithWhereWithoutLedgerInput, WalletTransactionUpdateWithoutLedgerInput>, WalletTransactionUncheckedUpdateWithoutLedgerInput>
  }

  export type UserCreateNestedOneWithoutFirebaseTokenInput = {
    create?: XOR<UserCreateWithoutFirebaseTokenInput, UserUncheckedCreateWithoutFirebaseTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutFirebaseTokenInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFirebaseTokenNestedInput = {
    create?: XOR<UserCreateWithoutFirebaseTokenInput, UserUncheckedCreateWithoutFirebaseTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutFirebaseTokenInput
    upsert?: UserUpsertWithoutFirebaseTokenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFirebaseTokenInput, UserUpdateWithoutFirebaseTokenInput>, UserUncheckedUpdateWithoutFirebaseTokenInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type NestedEnumAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusFilter<$PrismaModel> | $Enums.AccountStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumVerificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationType | EnumVerificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationType[] | ListEnumVerificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationType[] | ListEnumVerificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationTypeFilter<$PrismaModel> | $Enums.VerificationType
  }

  export type NestedEnumVerificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationType | EnumVerificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationType[] | ListEnumVerificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationType[] | ListEnumVerificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.VerificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationTypeFilter<$PrismaModel>
    _max?: NestedEnumVerificationTypeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumSchoolTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SchoolType | EnumSchoolTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SchoolType[] | ListEnumSchoolTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SchoolType[] | ListEnumSchoolTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSchoolTypeFilter<$PrismaModel> | $Enums.SchoolType
  }

  export type NestedEnumSchoolOwnershipFilter<$PrismaModel = never> = {
    equals?: $Enums.SchoolOwnership | EnumSchoolOwnershipFieldRefInput<$PrismaModel>
    in?: $Enums.SchoolOwnership[] | ListEnumSchoolOwnershipFieldRefInput<$PrismaModel>
    notIn?: $Enums.SchoolOwnership[] | ListEnumSchoolOwnershipFieldRefInput<$PrismaModel>
    not?: NestedEnumSchoolOwnershipFilter<$PrismaModel> | $Enums.SchoolOwnership
  }

  export type NestedEnumSchoolStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SchoolStatus | EnumSchoolStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SchoolStatus[] | ListEnumSchoolStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SchoolStatus[] | ListEnumSchoolStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSchoolStatusFilter<$PrismaModel> | $Enums.SchoolStatus
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSchoolTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SchoolType | EnumSchoolTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SchoolType[] | ListEnumSchoolTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SchoolType[] | ListEnumSchoolTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSchoolTypeWithAggregatesFilter<$PrismaModel> | $Enums.SchoolType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSchoolTypeFilter<$PrismaModel>
    _max?: NestedEnumSchoolTypeFilter<$PrismaModel>
  }

  export type NestedEnumSchoolOwnershipWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SchoolOwnership | EnumSchoolOwnershipFieldRefInput<$PrismaModel>
    in?: $Enums.SchoolOwnership[] | ListEnumSchoolOwnershipFieldRefInput<$PrismaModel>
    notIn?: $Enums.SchoolOwnership[] | ListEnumSchoolOwnershipFieldRefInput<$PrismaModel>
    not?: NestedEnumSchoolOwnershipWithAggregatesFilter<$PrismaModel> | $Enums.SchoolOwnership
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSchoolOwnershipFilter<$PrismaModel>
    _max?: NestedEnumSchoolOwnershipFilter<$PrismaModel>
  }

  export type NestedEnumSchoolStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SchoolStatus | EnumSchoolStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SchoolStatus[] | ListEnumSchoolStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SchoolStatus[] | ListEnumSchoolStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSchoolStatusWithAggregatesFilter<$PrismaModel> | $Enums.SchoolStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSchoolStatusFilter<$PrismaModel>
    _max?: NestedEnumSchoolStatusFilter<$PrismaModel>
  }

  export type NestedEnumDirectorIDTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DirectorIDType | EnumDirectorIDTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DirectorIDType[] | ListEnumDirectorIDTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DirectorIDType[] | ListEnumDirectorIDTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectorIDTypeFilter<$PrismaModel> | $Enums.DirectorIDType
  }

  export type NestedEnumDirectorIDTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DirectorIDType | EnumDirectorIDTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DirectorIDType[] | ListEnumDirectorIDTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DirectorIDType[] | ListEnumDirectorIDTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDirectorIDTypeWithAggregatesFilter<$PrismaModel> | $Enums.DirectorIDType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDirectorIDTypeFilter<$PrismaModel>
    _max?: NestedEnumDirectorIDTypeFilter<$PrismaModel>
  }

  export type NestedEnumKYCVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCVerificationStatus | EnumKYCVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCVerificationStatus[] | ListEnumKYCVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCVerificationStatus[] | ListEnumKYCVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCVerificationStatusFilter<$PrismaModel> | $Enums.KYCVerificationStatus
  }

  export type NestedEnumKYCVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCVerificationStatus | EnumKYCVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCVerificationStatus[] | ListEnumKYCVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCVerificationStatus[] | ListEnumKYCVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.KYCVerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKYCVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumKYCVerificationStatusFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumStudentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentStatus | EnumStudentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentStatusFilter<$PrismaModel> | $Enums.StudentStatus
  }

  export type NestedEnumStudentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentStatus | EnumStudentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentStatus[] | ListEnumStudentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentStatusWithAggregatesFilter<$PrismaModel> | $Enums.StudentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStudentStatusFilter<$PrismaModel>
    _max?: NestedEnumStudentStatusFilter<$PrismaModel>
  }

  export type NestedEnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type NestedEnumPayoutStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusFilter<$PrismaModel> | $Enums.PayoutStatus
  }

  export type NestedEnumPayoutStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayoutStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayoutStatusFilter<$PrismaModel>
    _max?: NestedEnumPayoutStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumWalletStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WalletStatus | EnumWalletStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WalletStatus[] | ListEnumWalletStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WalletStatus[] | ListEnumWalletStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWalletStatusFilter<$PrismaModel> | $Enums.WalletStatus
  }

  export type NestedEnumWalletStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WalletStatus | EnumWalletStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WalletStatus[] | ListEnumWalletStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WalletStatus[] | ListEnumWalletStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWalletStatusWithAggregatesFilter<$PrismaModel> | $Enums.WalletStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWalletStatusFilter<$PrismaModel>
    _max?: NestedEnumWalletStatusFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionFlowFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionFlow | EnumTransactionFlowFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionFlow[] | ListEnumTransactionFlowFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionFlow[] | ListEnumTransactionFlowFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionFlowFilter<$PrismaModel> | $Enums.TransactionFlow
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionFlowWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionFlow | EnumTransactionFlowFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionFlow[] | ListEnumTransactionFlowFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionFlow[] | ListEnumTransactionFlowFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionFlowWithAggregatesFilter<$PrismaModel> | $Enums.TransactionFlow
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionFlowFilter<$PrismaModel>
    _max?: NestedEnumTransactionFlowFilter<$PrismaModel>
  }

  export type AdministratorCreateWithoutUserInput = {
    id?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdministratorUncheckedCreateWithoutUserInput = {
    id?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdministratorCreateOrConnectWithoutUserInput = {
    where: AdministratorWhereUniqueInput
    create: XOR<AdministratorCreateWithoutUserInput, AdministratorUncheckedCreateWithoutUserInput>
  }

  export type GuardianCreateWithoutUserInput = {
    id?: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutGuardianInput
    students?: StudentCreateNestedManyWithoutGuardianInput
    linkedStudentProfiles?: LinkedStudentProfileCreateNestedManyWithoutGuardianInput
    transactions?: TransactionCreateNestedManyWithoutGuardianInput
  }

  export type GuardianUncheckedCreateWithoutUserInput = {
    id?: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutGuardianInput
    students?: StudentUncheckedCreateNestedManyWithoutGuardianInput
    linkedStudentProfiles?: LinkedStudentProfileUncheckedCreateNestedManyWithoutGuardianInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutGuardianInput
  }

  export type GuardianCreateOrConnectWithoutUserInput = {
    where: GuardianWhereUniqueInput
    create: XOR<GuardianCreateWithoutUserInput, GuardianUncheckedCreateWithoutUserInput>
  }

  export type VerificationCreateWithoutUserInput = {
    id?: string
    type: $Enums.VerificationType
    code: string
    expiresAt: Date | string
    resendCount?: number
    used?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.VerificationType
    code: string
    expiresAt: Date | string
    resendCount?: number
    used?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationCreateOrConnectWithoutUserInput = {
    where: VerificationWhereUniqueInput
    create: XOR<VerificationCreateWithoutUserInput, VerificationUncheckedCreateWithoutUserInput>
  }

  export type VerificationCreateManyUserInputEnvelope = {
    data: VerificationCreateManyUserInput | VerificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SchoolCreateWithoutOwnerInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolDirectorVerification?: SchoolDirectorVerificationCreateNestedOneWithoutSchoolInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationCreateNestedOneWithoutSchoolInput
    schoolVerification?: SchoolVerificationCreateNestedOneWithoutSchoolInput
    schoolPayoutDetail?: SchoolPayoutDetailCreateNestedOneWithoutSchoolInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementCreateNestedOneWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    academicSessions?: AcademicSessionCreateNestedManyWithoutSchoolInput
    terms?: TermCreateNestedManyWithoutSchoolInput
    fees?: FeesCreateNestedManyWithoutSchoolInput
    payouts?: PayoutCreateNestedManyWithoutSchoolInput
    kycverification?: KYCVerificationCreateNestedOneWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolDirectorVerification?: SchoolDirectorVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolVerification?: SchoolVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolPayoutDetail?: SchoolPayoutDetailUncheckedCreateNestedOneWithoutSchoolInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedCreateNestedOneWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    academicSessions?: AcademicSessionUncheckedCreateNestedManyWithoutSchoolInput
    terms?: TermUncheckedCreateNestedManyWithoutSchoolInput
    fees?: FeesUncheckedCreateNestedManyWithoutSchoolInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutSchoolInput
    kycverification?: KYCVerificationUncheckedCreateNestedOneWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutOwnerInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutOwnerInput, SchoolUncheckedCreateWithoutOwnerInput>
  }

  export type SchoolAndPlatformLegalAgreementCreateWithoutSignedByInput = {
    id?: string
    signature: string
    signedAt: Date | string
    legalDocumentRef: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutSchoolAndPlatformLegalAgreementInput
  }

  export type SchoolAndPlatformLegalAgreementUncheckedCreateWithoutSignedByInput = {
    id?: string
    schoolId: string
    signature: string
    signedAt: Date | string
    legalDocumentRef: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolAndPlatformLegalAgreementCreateOrConnectWithoutSignedByInput = {
    where: SchoolAndPlatformLegalAgreementWhereUniqueInput
    create: XOR<SchoolAndPlatformLegalAgreementCreateWithoutSignedByInput, SchoolAndPlatformLegalAgreementUncheckedCreateWithoutSignedByInput>
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    status?: $Enums.NotificationStatus
    sentAt: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    status?: $Enums.NotificationStatus
    sentAt: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CredentialCreateWithoutUserInput = {
    id?: string
    password?: string | null
    pinCode?: string | null
    lastResetAt?: Date | string | null
    lastUsedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CredentialUncheckedCreateWithoutUserInput = {
    id?: string
    password?: string | null
    pinCode?: string | null
    lastResetAt?: Date | string | null
    lastUsedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CredentialCreateOrConnectWithoutUserInput = {
    where: CredentialWhereUniqueInput
    create: XOR<CredentialCreateWithoutUserInput, CredentialUncheckedCreateWithoutUserInput>
  }

  export type WalletCreateWithoutUserInput = {
    id?: string
    address: string
    name: string
    tag: string
    routingNumber: string
    balance: string
    status?: $Enums.WalletStatus
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
    Ledger?: LedgerCreateNestedManyWithoutWalletInput
    Transaction?: WalletTransactionCreateNestedManyWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutUserInput = {
    id?: string
    address: string
    name: string
    tag: string
    routingNumber: string
    balance: string
    status?: $Enums.WalletStatus
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
    Ledger?: LedgerUncheckedCreateNestedManyWithoutWalletInput
    Transaction?: WalletTransactionUncheckedCreateNestedManyWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutUserInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    revoked?: boolean
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    revoked?: boolean
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FirebaseTokenCreateWithoutUserInput = {
    id?: string
    token?: string | null
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type FirebaseTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token?: string | null
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type FirebaseTokenCreateOrConnectWithoutUserInput = {
    where: FirebaseTokenWhereUniqueInput
    create: XOR<FirebaseTokenCreateWithoutUserInput, FirebaseTokenUncheckedCreateWithoutUserInput>
  }

  export type KYCVerificationCreateWithoutUserInput = {
    id?: string
    status?: $Enums.KYCVerificationStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutKycverificationInput
  }

  export type KYCVerificationUncheckedCreateWithoutUserInput = {
    id?: string
    schoolId: string
    status?: $Enums.KYCVerificationStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KYCVerificationCreateOrConnectWithoutUserInput = {
    where: KYCVerificationWhereUniqueInput
    create: XOR<KYCVerificationCreateWithoutUserInput, KYCVerificationUncheckedCreateWithoutUserInput>
  }

  export type AdministratorUpsertWithoutUserInput = {
    update: XOR<AdministratorUpdateWithoutUserInput, AdministratorUncheckedUpdateWithoutUserInput>
    create: XOR<AdministratorCreateWithoutUserInput, AdministratorUncheckedCreateWithoutUserInput>
    where?: AdministratorWhereInput
  }

  export type AdministratorUpdateToOneWithWhereWithoutUserInput = {
    where?: AdministratorWhereInput
    data: XOR<AdministratorUpdateWithoutUserInput, AdministratorUncheckedUpdateWithoutUserInput>
  }

  export type AdministratorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdministratorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuardianUpsertWithoutUserInput = {
    update: XOR<GuardianUpdateWithoutUserInput, GuardianUncheckedUpdateWithoutUserInput>
    create: XOR<GuardianCreateWithoutUserInput, GuardianUncheckedCreateWithoutUserInput>
    where?: GuardianWhereInput
  }

  export type GuardianUpdateToOneWithWhereWithoutUserInput = {
    where?: GuardianWhereInput
    data: XOR<GuardianUpdateWithoutUserInput, GuardianUncheckedUpdateWithoutUserInput>
  }

  export type GuardianUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutGuardianNestedInput
    students?: StudentUpdateManyWithoutGuardianNestedInput
    linkedStudentProfiles?: LinkedStudentProfileUpdateManyWithoutGuardianNestedInput
    transactions?: TransactionUpdateManyWithoutGuardianNestedInput
  }

  export type GuardianUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutGuardianNestedInput
    students?: StudentUncheckedUpdateManyWithoutGuardianNestedInput
    linkedStudentProfiles?: LinkedStudentProfileUncheckedUpdateManyWithoutGuardianNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutGuardianNestedInput
  }

  export type VerificationUpsertWithWhereUniqueWithoutUserInput = {
    where: VerificationWhereUniqueInput
    update: XOR<VerificationUpdateWithoutUserInput, VerificationUncheckedUpdateWithoutUserInput>
    create: XOR<VerificationCreateWithoutUserInput, VerificationUncheckedCreateWithoutUserInput>
  }

  export type VerificationUpdateWithWhereUniqueWithoutUserInput = {
    where: VerificationWhereUniqueInput
    data: XOR<VerificationUpdateWithoutUserInput, VerificationUncheckedUpdateWithoutUserInput>
  }

  export type VerificationUpdateManyWithWhereWithoutUserInput = {
    where: VerificationScalarWhereInput
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyWithoutUserInput>
  }

  export type VerificationScalarWhereInput = {
    AND?: VerificationScalarWhereInput | VerificationScalarWhereInput[]
    OR?: VerificationScalarWhereInput[]
    NOT?: VerificationScalarWhereInput | VerificationScalarWhereInput[]
    id?: StringFilter<"Verification"> | string
    userId?: StringFilter<"Verification"> | string
    type?: EnumVerificationTypeFilter<"Verification"> | $Enums.VerificationType
    code?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    resendCount?: IntFilter<"Verification"> | number
    used?: BoolFilter<"Verification"> | boolean
    isDeleted?: BoolFilter<"Verification"> | boolean
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }

  export type SchoolUpsertWithoutOwnerInput = {
    update: XOR<SchoolUpdateWithoutOwnerInput, SchoolUncheckedUpdateWithoutOwnerInput>
    create: XOR<SchoolCreateWithoutOwnerInput, SchoolUncheckedCreateWithoutOwnerInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutOwnerInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutOwnerInput, SchoolUncheckedUpdateWithoutOwnerInput>
  }

  export type SchoolUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolDirectorVerification?: SchoolDirectorVerificationUpdateOneWithoutSchoolNestedInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUpdateOneWithoutSchoolNestedInput
    schoolVerification?: SchoolVerificationUpdateOneWithoutSchoolNestedInput
    schoolPayoutDetail?: SchoolPayoutDetailUpdateOneWithoutSchoolNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUpdateOneWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    academicSessions?: AcademicSessionUpdateManyWithoutSchoolNestedInput
    terms?: TermUpdateManyWithoutSchoolNestedInput
    fees?: FeesUpdateManyWithoutSchoolNestedInput
    payouts?: PayoutUpdateManyWithoutSchoolNestedInput
    kycverification?: KYCVerificationUpdateOneWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolDirectorVerification?: SchoolDirectorVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolVerification?: SchoolVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolPayoutDetail?: SchoolPayoutDetailUncheckedUpdateOneWithoutSchoolNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedUpdateOneWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    academicSessions?: AcademicSessionUncheckedUpdateManyWithoutSchoolNestedInput
    terms?: TermUncheckedUpdateManyWithoutSchoolNestedInput
    fees?: FeesUncheckedUpdateManyWithoutSchoolNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutSchoolNestedInput
    kycverification?: KYCVerificationUncheckedUpdateOneWithoutSchoolNestedInput
  }

  export type SchoolAndPlatformLegalAgreementUpsertWithoutSignedByInput = {
    update: XOR<SchoolAndPlatformLegalAgreementUpdateWithoutSignedByInput, SchoolAndPlatformLegalAgreementUncheckedUpdateWithoutSignedByInput>
    create: XOR<SchoolAndPlatformLegalAgreementCreateWithoutSignedByInput, SchoolAndPlatformLegalAgreementUncheckedCreateWithoutSignedByInput>
    where?: SchoolAndPlatformLegalAgreementWhereInput
  }

  export type SchoolAndPlatformLegalAgreementUpdateToOneWithWhereWithoutSignedByInput = {
    where?: SchoolAndPlatformLegalAgreementWhereInput
    data: XOR<SchoolAndPlatformLegalAgreementUpdateWithoutSignedByInput, SchoolAndPlatformLegalAgreementUncheckedUpdateWithoutSignedByInput>
  }

  export type SchoolAndPlatformLegalAgreementUpdateWithoutSignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    legalDocumentRef?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutSchoolAndPlatformLegalAgreementNestedInput
  }

  export type SchoolAndPlatformLegalAgreementUncheckedUpdateWithoutSignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    legalDocumentRef?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    sentAt?: DateTimeFilter<"Notification"> | Date | string
    isDeleted?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type CredentialUpsertWithoutUserInput = {
    update: XOR<CredentialUpdateWithoutUserInput, CredentialUncheckedUpdateWithoutUserInput>
    create: XOR<CredentialCreateWithoutUserInput, CredentialUncheckedCreateWithoutUserInput>
    where?: CredentialWhereInput
  }

  export type CredentialUpdateToOneWithWhereWithoutUserInput = {
    where?: CredentialWhereInput
    data: XOR<CredentialUpdateWithoutUserInput, CredentialUncheckedUpdateWithoutUserInput>
  }

  export type CredentialUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pinCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CredentialUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pinCode?: NullableStringFieldUpdateOperationsInput | string | null
    lastResetAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUpsertWithoutUserInput = {
    update: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
    create: XOR<WalletCreateWithoutUserInput, WalletUncheckedCreateWithoutUserInput>
    where?: WalletWhereInput
  }

  export type WalletUpdateToOneWithWhereWithoutUserInput = {
    where?: WalletWhereInput
    data: XOR<WalletUpdateWithoutUserInput, WalletUncheckedUpdateWithoutUserInput>
  }

  export type WalletUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    routingNumber?: StringFieldUpdateOperationsInput | string
    balance?: StringFieldUpdateOperationsInput | string
    status?: EnumWalletStatusFieldUpdateOperationsInput | $Enums.WalletStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ledger?: LedgerUpdateManyWithoutWalletNestedInput
    Transaction?: WalletTransactionUpdateManyWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    routingNumber?: StringFieldUpdateOperationsInput | string
    balance?: StringFieldUpdateOperationsInput | string
    status?: EnumWalletStatusFieldUpdateOperationsInput | $Enums.WalletStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ledger?: LedgerUncheckedUpdateManyWithoutWalletNestedInput
    Transaction?: WalletTransactionUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revoked?: BoolFilter<"RefreshToken"> | boolean
    isDeleted?: BoolFilter<"RefreshToken"> | boolean
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type FirebaseTokenUpsertWithoutUserInput = {
    update: XOR<FirebaseTokenUpdateWithoutUserInput, FirebaseTokenUncheckedUpdateWithoutUserInput>
    create: XOR<FirebaseTokenCreateWithoutUserInput, FirebaseTokenUncheckedCreateWithoutUserInput>
    where?: FirebaseTokenWhereInput
  }

  export type FirebaseTokenUpdateToOneWithWhereWithoutUserInput = {
    where?: FirebaseTokenWhereInput
    data: XOR<FirebaseTokenUpdateWithoutUserInput, FirebaseTokenUncheckedUpdateWithoutUserInput>
  }

  export type FirebaseTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FirebaseTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KYCVerificationUpsertWithoutUserInput = {
    update: XOR<KYCVerificationUpdateWithoutUserInput, KYCVerificationUncheckedUpdateWithoutUserInput>
    create: XOR<KYCVerificationCreateWithoutUserInput, KYCVerificationUncheckedCreateWithoutUserInput>
    where?: KYCVerificationWhereInput
  }

  export type KYCVerificationUpdateToOneWithWhereWithoutUserInput = {
    where?: KYCVerificationWhereInput
    data: XOR<KYCVerificationUpdateWithoutUserInput, KYCVerificationUncheckedUpdateWithoutUserInput>
  }

  export type KYCVerificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumKYCVerificationStatusFieldUpdateOperationsInput | $Enums.KYCVerificationStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutKycverificationNestedInput
  }

  export type KYCVerificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    status?: EnumKYCVerificationStatusFieldUpdateOperationsInput | $Enums.KYCVerificationStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutCredentialInput = {
    id?: string
    firstName: string
    lastName: string
    profileImage?: string | null
    email: string
    type: $Enums.UserType
    phone?: string | null
    accountStatus?: $Enums.AccountStatus
    verifiedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    administrator?: AdministratorCreateNestedOneWithoutUserInput
    guardian?: GuardianCreateNestedOneWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    school?: SchoolCreateNestedOneWithoutOwnerInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementCreateNestedOneWithoutSignedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    firebaseToken?: FirebaseTokenCreateNestedOneWithoutUserInput
    kycverification?: KYCVerificationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCredentialInput = {
    id?: string
    firstName: string
    lastName: string
    profileImage?: string | null
    email: string
    type: $Enums.UserType
    phone?: string | null
    accountStatus?: $Enums.AccountStatus
    verifiedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    administrator?: AdministratorUncheckedCreateNestedOneWithoutUserInput
    guardian?: GuardianUncheckedCreateNestedOneWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    school?: SchoolUncheckedCreateNestedOneWithoutOwnerInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedCreateNestedOneWithoutSignedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    firebaseToken?: FirebaseTokenUncheckedCreateNestedOneWithoutUserInput
    kycverification?: KYCVerificationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCredentialInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCredentialInput, UserUncheckedCreateWithoutCredentialInput>
  }

  export type UserUpsertWithoutCredentialInput = {
    update: XOR<UserUpdateWithoutCredentialInput, UserUncheckedUpdateWithoutCredentialInput>
    create: XOR<UserCreateWithoutCredentialInput, UserUncheckedCreateWithoutCredentialInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCredentialInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCredentialInput, UserUncheckedUpdateWithoutCredentialInput>
  }

  export type UserUpdateWithoutCredentialInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTermsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isPrivacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    administrator?: AdministratorUpdateOneWithoutUserNestedInput
    guardian?: GuardianUpdateOneWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    school?: SchoolUpdateOneWithoutOwnerNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUpdateOneWithoutSignedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    firebaseToken?: FirebaseTokenUpdateOneWithoutUserNestedInput
    kycverification?: KYCVerificationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCredentialInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTermsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isPrivacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    administrator?: AdministratorUncheckedUpdateOneWithoutUserNestedInput
    guardian?: GuardianUncheckedUpdateOneWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    school?: SchoolUncheckedUpdateOneWithoutOwnerNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedUpdateOneWithoutSignedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    firebaseToken?: FirebaseTokenUncheckedUpdateOneWithoutUserNestedInput
    kycverification?: KYCVerificationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    firstName: string
    lastName: string
    profileImage?: string | null
    email: string
    type: $Enums.UserType
    phone?: string | null
    accountStatus?: $Enums.AccountStatus
    verifiedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    administrator?: AdministratorCreateNestedOneWithoutUserInput
    guardian?: GuardianCreateNestedOneWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    school?: SchoolCreateNestedOneWithoutOwnerInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementCreateNestedOneWithoutSignedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    credential?: CredentialCreateNestedOneWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    firebaseToken?: FirebaseTokenCreateNestedOneWithoutUserInput
    kycverification?: KYCVerificationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    firstName: string
    lastName: string
    profileImage?: string | null
    email: string
    type: $Enums.UserType
    phone?: string | null
    accountStatus?: $Enums.AccountStatus
    verifiedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    administrator?: AdministratorUncheckedCreateNestedOneWithoutUserInput
    guardian?: GuardianUncheckedCreateNestedOneWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    school?: SchoolUncheckedCreateNestedOneWithoutOwnerInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedCreateNestedOneWithoutSignedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    credential?: CredentialUncheckedCreateNestedOneWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    firebaseToken?: FirebaseTokenUncheckedCreateNestedOneWithoutUserInput
    kycverification?: KYCVerificationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTermsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isPrivacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    administrator?: AdministratorUpdateOneWithoutUserNestedInput
    guardian?: GuardianUpdateOneWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    school?: SchoolUpdateOneWithoutOwnerNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUpdateOneWithoutSignedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    credential?: CredentialUpdateOneWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    firebaseToken?: FirebaseTokenUpdateOneWithoutUserNestedInput
    kycverification?: KYCVerificationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTermsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isPrivacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    administrator?: AdministratorUncheckedUpdateOneWithoutUserNestedInput
    guardian?: GuardianUncheckedUpdateOneWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    school?: SchoolUncheckedUpdateOneWithoutOwnerNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedUpdateOneWithoutSignedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    credential?: CredentialUncheckedUpdateOneWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    firebaseToken?: FirebaseTokenUncheckedUpdateOneWithoutUserNestedInput
    kycverification?: KYCVerificationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutAdministratorInput = {
    id?: string
    firstName: string
    lastName: string
    profileImage?: string | null
    email: string
    type: $Enums.UserType
    phone?: string | null
    accountStatus?: $Enums.AccountStatus
    verifiedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    guardian?: GuardianCreateNestedOneWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    school?: SchoolCreateNestedOneWithoutOwnerInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementCreateNestedOneWithoutSignedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    credential?: CredentialCreateNestedOneWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    firebaseToken?: FirebaseTokenCreateNestedOneWithoutUserInput
    kycverification?: KYCVerificationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdministratorInput = {
    id?: string
    firstName: string
    lastName: string
    profileImage?: string | null
    email: string
    type: $Enums.UserType
    phone?: string | null
    accountStatus?: $Enums.AccountStatus
    verifiedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    guardian?: GuardianUncheckedCreateNestedOneWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    school?: SchoolUncheckedCreateNestedOneWithoutOwnerInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedCreateNestedOneWithoutSignedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    credential?: CredentialUncheckedCreateNestedOneWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    firebaseToken?: FirebaseTokenUncheckedCreateNestedOneWithoutUserInput
    kycverification?: KYCVerificationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdministratorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdministratorInput, UserUncheckedCreateWithoutAdministratorInput>
  }

  export type UserUpsertWithoutAdministratorInput = {
    update: XOR<UserUpdateWithoutAdministratorInput, UserUncheckedUpdateWithoutAdministratorInput>
    create: XOR<UserCreateWithoutAdministratorInput, UserUncheckedCreateWithoutAdministratorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdministratorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdministratorInput, UserUncheckedUpdateWithoutAdministratorInput>
  }

  export type UserUpdateWithoutAdministratorInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTermsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isPrivacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guardian?: GuardianUpdateOneWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    school?: SchoolUpdateOneWithoutOwnerNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUpdateOneWithoutSignedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    credential?: CredentialUpdateOneWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    firebaseToken?: FirebaseTokenUpdateOneWithoutUserNestedInput
    kycverification?: KYCVerificationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdministratorInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTermsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isPrivacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guardian?: GuardianUncheckedUpdateOneWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    school?: SchoolUncheckedUpdateOneWithoutOwnerNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedUpdateOneWithoutSignedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    credential?: CredentialUncheckedUpdateOneWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    firebaseToken?: FirebaseTokenUncheckedUpdateOneWithoutUserNestedInput
    kycverification?: KYCVerificationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutGuardianInput = {
    id?: string
    firstName: string
    lastName: string
    profileImage?: string | null
    email: string
    type: $Enums.UserType
    phone?: string | null
    accountStatus?: $Enums.AccountStatus
    verifiedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    administrator?: AdministratorCreateNestedOneWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    school?: SchoolCreateNestedOneWithoutOwnerInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementCreateNestedOneWithoutSignedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    credential?: CredentialCreateNestedOneWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    firebaseToken?: FirebaseTokenCreateNestedOneWithoutUserInput
    kycverification?: KYCVerificationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGuardianInput = {
    id?: string
    firstName: string
    lastName: string
    profileImage?: string | null
    email: string
    type: $Enums.UserType
    phone?: string | null
    accountStatus?: $Enums.AccountStatus
    verifiedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    administrator?: AdministratorUncheckedCreateNestedOneWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    school?: SchoolUncheckedCreateNestedOneWithoutOwnerInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedCreateNestedOneWithoutSignedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    credential?: CredentialUncheckedCreateNestedOneWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    firebaseToken?: FirebaseTokenUncheckedCreateNestedOneWithoutUserInput
    kycverification?: KYCVerificationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGuardianInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGuardianInput, UserUncheckedCreateWithoutGuardianInput>
  }

  export type InvoiceCreateWithoutGuardianInput = {
    id?: string
    invoiceNo: string
    feeId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueAt: Date | string
    paidAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutInvoicesInput
    academicSession: AcademicSessionCreateNestedOneWithoutInvoicesInput
    term: TermCreateNestedOneWithoutInvoicesInput
    transactions?: TransactionCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutGuardianInput = {
    id?: string
    invoiceNo: string
    feeId: string
    classId: string
    sessionId: string
    termId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueAt: Date | string
    paidAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutGuardianInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutGuardianInput, InvoiceUncheckedCreateWithoutGuardianInput>
  }

  export type InvoiceCreateManyGuardianInputEnvelope = {
    data: InvoiceCreateManyGuardianInput | InvoiceCreateManyGuardianInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutGuardianInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    registrationNumber: string
    status?: $Enums.StudentStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutStudentsInput
    linkedStudentProfile?: LinkedStudentProfileCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutGuardianInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    classId: string
    registrationNumber: string
    status?: $Enums.StudentStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    linkedStudentProfile?: LinkedStudentProfileUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutGuardianInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutGuardianInput, StudentUncheckedCreateWithoutGuardianInput>
  }

  export type StudentCreateManyGuardianInputEnvelope = {
    data: StudentCreateManyGuardianInput | StudentCreateManyGuardianInput[]
    skipDuplicates?: boolean
  }

  export type LinkedStudentProfileCreateWithoutGuardianInput = {
    id?: string
    lastGuardiantChanged: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutLinkedStudentProfileInput
  }

  export type LinkedStudentProfileUncheckedCreateWithoutGuardianInput = {
    id?: string
    studentId: string
    lastGuardiantChanged: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LinkedStudentProfileCreateOrConnectWithoutGuardianInput = {
    where: LinkedStudentProfileWhereUniqueInput
    create: XOR<LinkedStudentProfileCreateWithoutGuardianInput, LinkedStudentProfileUncheckedCreateWithoutGuardianInput>
  }

  export type LinkedStudentProfileCreateManyGuardianInputEnvelope = {
    data: LinkedStudentProfileCreateManyGuardianInput | LinkedStudentProfileCreateManyGuardianInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutGuardianInput = {
    id?: string
    reference: string
    amount?: Decimal | DecimalJsLike | number | string
    fees?: Decimal | DecimalJsLike | number | string
    status?: $Enums.TransactionStatus
    transactionAt?: Date | string | null
    processedAt?: Date | string | null
    description?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutTransactionsInput
    transactionFee?: TransactionFeeCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutGuardianInput = {
    id?: string
    invoiceId: string
    reference: string
    amount?: Decimal | DecimalJsLike | number | string
    fees?: Decimal | DecimalJsLike | number | string
    status?: $Enums.TransactionStatus
    transactionAt?: Date | string | null
    processedAt?: Date | string | null
    description?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionFee?: TransactionFeeUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutGuardianInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutGuardianInput, TransactionUncheckedCreateWithoutGuardianInput>
  }

  export type TransactionCreateManyGuardianInputEnvelope = {
    data: TransactionCreateManyGuardianInput | TransactionCreateManyGuardianInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutGuardianInput = {
    update: XOR<UserUpdateWithoutGuardianInput, UserUncheckedUpdateWithoutGuardianInput>
    create: XOR<UserCreateWithoutGuardianInput, UserUncheckedCreateWithoutGuardianInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGuardianInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGuardianInput, UserUncheckedUpdateWithoutGuardianInput>
  }

  export type UserUpdateWithoutGuardianInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTermsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isPrivacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    administrator?: AdministratorUpdateOneWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    school?: SchoolUpdateOneWithoutOwnerNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUpdateOneWithoutSignedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    credential?: CredentialUpdateOneWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    firebaseToken?: FirebaseTokenUpdateOneWithoutUserNestedInput
    kycverification?: KYCVerificationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGuardianInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTermsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isPrivacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    administrator?: AdministratorUncheckedUpdateOneWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    school?: SchoolUncheckedUpdateOneWithoutOwnerNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedUpdateOneWithoutSignedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    credential?: CredentialUncheckedUpdateOneWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    firebaseToken?: FirebaseTokenUncheckedUpdateOneWithoutUserNestedInput
    kycverification?: KYCVerificationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type InvoiceUpsertWithWhereUniqueWithoutGuardianInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutGuardianInput, InvoiceUncheckedUpdateWithoutGuardianInput>
    create: XOR<InvoiceCreateWithoutGuardianInput, InvoiceUncheckedCreateWithoutGuardianInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutGuardianInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutGuardianInput, InvoiceUncheckedUpdateWithoutGuardianInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutGuardianInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutGuardianInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    invoiceNo?: StringFilter<"Invoice"> | string
    feeId?: StringFilter<"Invoice"> | string
    guardianId?: StringFilter<"Invoice"> | string
    classId?: StringFilter<"Invoice"> | string
    sessionId?: StringFilter<"Invoice"> | string
    termId?: StringFilter<"Invoice"> | string
    totalAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    dueAt?: DateTimeFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    isDeleted?: BoolFilter<"Invoice"> | boolean
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type StudentUpsertWithWhereUniqueWithoutGuardianInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutGuardianInput, StudentUncheckedUpdateWithoutGuardianInput>
    create: XOR<StudentCreateWithoutGuardianInput, StudentUncheckedCreateWithoutGuardianInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutGuardianInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutGuardianInput, StudentUncheckedUpdateWithoutGuardianInput>
  }

  export type StudentUpdateManyWithWhereWithoutGuardianInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutGuardianInput>
  }

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[]
    OR?: StudentScalarWhereInput[]
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[]
    id?: StringFilter<"Student"> | string
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    image?: StringNullableFilter<"Student"> | string | null
    classId?: StringFilter<"Student"> | string
    guardianId?: StringNullableFilter<"Student"> | string | null
    registrationNumber?: StringFilter<"Student"> | string
    status?: EnumStudentStatusFilter<"Student"> | $Enums.StudentStatus
    isDeleted?: BoolFilter<"Student"> | boolean
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
  }

  export type LinkedStudentProfileUpsertWithWhereUniqueWithoutGuardianInput = {
    where: LinkedStudentProfileWhereUniqueInput
    update: XOR<LinkedStudentProfileUpdateWithoutGuardianInput, LinkedStudentProfileUncheckedUpdateWithoutGuardianInput>
    create: XOR<LinkedStudentProfileCreateWithoutGuardianInput, LinkedStudentProfileUncheckedCreateWithoutGuardianInput>
  }

  export type LinkedStudentProfileUpdateWithWhereUniqueWithoutGuardianInput = {
    where: LinkedStudentProfileWhereUniqueInput
    data: XOR<LinkedStudentProfileUpdateWithoutGuardianInput, LinkedStudentProfileUncheckedUpdateWithoutGuardianInput>
  }

  export type LinkedStudentProfileUpdateManyWithWhereWithoutGuardianInput = {
    where: LinkedStudentProfileScalarWhereInput
    data: XOR<LinkedStudentProfileUpdateManyMutationInput, LinkedStudentProfileUncheckedUpdateManyWithoutGuardianInput>
  }

  export type LinkedStudentProfileScalarWhereInput = {
    AND?: LinkedStudentProfileScalarWhereInput | LinkedStudentProfileScalarWhereInput[]
    OR?: LinkedStudentProfileScalarWhereInput[]
    NOT?: LinkedStudentProfileScalarWhereInput | LinkedStudentProfileScalarWhereInput[]
    id?: StringFilter<"LinkedStudentProfile"> | string
    studentId?: StringFilter<"LinkedStudentProfile"> | string
    guardianId?: StringFilter<"LinkedStudentProfile"> | string
    lastGuardiantChanged?: DateTimeFilter<"LinkedStudentProfile"> | Date | string
    isDeleted?: BoolFilter<"LinkedStudentProfile"> | boolean
    createdAt?: DateTimeFilter<"LinkedStudentProfile"> | Date | string
    updatedAt?: DateTimeFilter<"LinkedStudentProfile"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutGuardianInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutGuardianInput, TransactionUncheckedUpdateWithoutGuardianInput>
    create: XOR<TransactionCreateWithoutGuardianInput, TransactionUncheckedCreateWithoutGuardianInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutGuardianInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutGuardianInput, TransactionUncheckedUpdateWithoutGuardianInput>
  }

  export type TransactionUpdateManyWithWhereWithoutGuardianInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutGuardianInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    guardianId?: StringFilter<"Transaction"> | string
    invoiceId?: StringFilter<"Transaction"> | string
    reference?: StringFilter<"Transaction"> | string
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    fees?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    transactionAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    processedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    description?: StringNullableFilter<"Transaction"> | string | null
    isDeleted?: BoolFilter<"Transaction"> | boolean
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type UserCreateWithoutVerificationsInput = {
    id?: string
    firstName: string
    lastName: string
    profileImage?: string | null
    email: string
    type: $Enums.UserType
    phone?: string | null
    accountStatus?: $Enums.AccountStatus
    verifiedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    administrator?: AdministratorCreateNestedOneWithoutUserInput
    guardian?: GuardianCreateNestedOneWithoutUserInput
    school?: SchoolCreateNestedOneWithoutOwnerInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementCreateNestedOneWithoutSignedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    credential?: CredentialCreateNestedOneWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    firebaseToken?: FirebaseTokenCreateNestedOneWithoutUserInput
    kycverification?: KYCVerificationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVerificationsInput = {
    id?: string
    firstName: string
    lastName: string
    profileImage?: string | null
    email: string
    type: $Enums.UserType
    phone?: string | null
    accountStatus?: $Enums.AccountStatus
    verifiedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    administrator?: AdministratorUncheckedCreateNestedOneWithoutUserInput
    guardian?: GuardianUncheckedCreateNestedOneWithoutUserInput
    school?: SchoolUncheckedCreateNestedOneWithoutOwnerInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedCreateNestedOneWithoutSignedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    credential?: CredentialUncheckedCreateNestedOneWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    firebaseToken?: FirebaseTokenUncheckedCreateNestedOneWithoutUserInput
    kycverification?: KYCVerificationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVerificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVerificationsInput, UserUncheckedCreateWithoutVerificationsInput>
  }

  export type UserUpsertWithoutVerificationsInput = {
    update: XOR<UserUpdateWithoutVerificationsInput, UserUncheckedUpdateWithoutVerificationsInput>
    create: XOR<UserCreateWithoutVerificationsInput, UserUncheckedCreateWithoutVerificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVerificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVerificationsInput, UserUncheckedUpdateWithoutVerificationsInput>
  }

  export type UserUpdateWithoutVerificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTermsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isPrivacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    administrator?: AdministratorUpdateOneWithoutUserNestedInput
    guardian?: GuardianUpdateOneWithoutUserNestedInput
    school?: SchoolUpdateOneWithoutOwnerNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUpdateOneWithoutSignedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    credential?: CredentialUpdateOneWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    firebaseToken?: FirebaseTokenUpdateOneWithoutUserNestedInput
    kycverification?: KYCVerificationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVerificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTermsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isPrivacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    administrator?: AdministratorUncheckedUpdateOneWithoutUserNestedInput
    guardian?: GuardianUncheckedUpdateOneWithoutUserNestedInput
    school?: SchoolUncheckedUpdateOneWithoutOwnerNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedUpdateOneWithoutSignedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    credential?: CredentialUncheckedUpdateOneWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    firebaseToken?: FirebaseTokenUncheckedUpdateOneWithoutUserNestedInput
    kycverification?: KYCVerificationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutSchoolInput = {
    id?: string
    firstName: string
    lastName: string
    profileImage?: string | null
    email: string
    type: $Enums.UserType
    phone?: string | null
    accountStatus?: $Enums.AccountStatus
    verifiedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    administrator?: AdministratorCreateNestedOneWithoutUserInput
    guardian?: GuardianCreateNestedOneWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementCreateNestedOneWithoutSignedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    credential?: CredentialCreateNestedOneWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    firebaseToken?: FirebaseTokenCreateNestedOneWithoutUserInput
    kycverification?: KYCVerificationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSchoolInput = {
    id?: string
    firstName: string
    lastName: string
    profileImage?: string | null
    email: string
    type: $Enums.UserType
    phone?: string | null
    accountStatus?: $Enums.AccountStatus
    verifiedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    administrator?: AdministratorUncheckedCreateNestedOneWithoutUserInput
    guardian?: GuardianUncheckedCreateNestedOneWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedCreateNestedOneWithoutSignedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    credential?: CredentialUncheckedCreateNestedOneWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    firebaseToken?: FirebaseTokenUncheckedCreateNestedOneWithoutUserInput
    kycverification?: KYCVerificationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSchoolInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput>
  }

  export type SchoolDirectorVerificationCreateWithoutSchoolInput = {
    id?: string
    directorFullName: string
    directorIDType: $Enums.DirectorIDType
    directorIDNumber: string
    document: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolDirectorVerificationUncheckedCreateWithoutSchoolInput = {
    id?: string
    directorFullName: string
    directorIDType: $Enums.DirectorIDType
    directorIDNumber: string
    document: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolDirectorVerificationCreateOrConnectWithoutSchoolInput = {
    where: SchoolDirectorVerificationWhereUniqueInput
    create: XOR<SchoolDirectorVerificationCreateWithoutSchoolInput, SchoolDirectorVerificationUncheckedCreateWithoutSchoolInput>
  }

  export type SchoolOwnershipVerificationCreateWithoutSchoolInput = {
    id?: string
    cacform7: string
    cacShareAllotmentForm: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolOwnershipVerificationUncheckedCreateWithoutSchoolInput = {
    id?: string
    cacform7: string
    cacShareAllotmentForm: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolOwnershipVerificationCreateOrConnectWithoutSchoolInput = {
    where: SchoolOwnershipVerificationWhereUniqueInput
    create: XOR<SchoolOwnershipVerificationCreateWithoutSchoolInput, SchoolOwnershipVerificationUncheckedCreateWithoutSchoolInput>
  }

  export type SchoolVerificationCreateWithoutSchoolInput = {
    id?: string
    cacCertificate: string
    accreditationDocument: string
    taxIdentificationNumber: string
    licenseDocument: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolVerificationUncheckedCreateWithoutSchoolInput = {
    id?: string
    cacCertificate: string
    accreditationDocument: string
    taxIdentificationNumber: string
    licenseDocument: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolVerificationCreateOrConnectWithoutSchoolInput = {
    where: SchoolVerificationWhereUniqueInput
    create: XOR<SchoolVerificationCreateWithoutSchoolInput, SchoolVerificationUncheckedCreateWithoutSchoolInput>
  }

  export type SchoolPayoutDetailCreateWithoutSchoolInput = {
    id?: string
    bankName: string
    bankCode: string
    accountNumber: string
    accountName: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolPayoutDetailUncheckedCreateWithoutSchoolInput = {
    id?: string
    bankName: string
    bankCode: string
    accountNumber: string
    accountName: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolPayoutDetailCreateOrConnectWithoutSchoolInput = {
    where: SchoolPayoutDetailWhereUniqueInput
    create: XOR<SchoolPayoutDetailCreateWithoutSchoolInput, SchoolPayoutDetailUncheckedCreateWithoutSchoolInput>
  }

  export type SchoolAndPlatformLegalAgreementCreateWithoutSchoolInput = {
    id?: string
    signature: string
    signedAt: Date | string
    legalDocumentRef: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    signedBy: UserCreateNestedOneWithoutSchoolAndPlatformLegalAgreementInput
  }

  export type SchoolAndPlatformLegalAgreementUncheckedCreateWithoutSchoolInput = {
    id?: string
    signedById: string
    signature: string
    signedAt: Date | string
    legalDocumentRef: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolAndPlatformLegalAgreementCreateOrConnectWithoutSchoolInput = {
    where: SchoolAndPlatformLegalAgreementWhereUniqueInput
    create: XOR<SchoolAndPlatformLegalAgreementCreateWithoutSchoolInput, SchoolAndPlatformLegalAgreementUncheckedCreateWithoutSchoolInput>
  }

  export type ClassCreateWithoutSchoolInput = {
    id?: string
    name: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fees?: FeesCreateNestedManyWithoutClassInput
    invoices?: InvoiceCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fees?: FeesUncheckedCreateNestedManyWithoutClassInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutSchoolInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput>
  }

  export type ClassCreateManySchoolInputEnvelope = {
    data: ClassCreateManySchoolInput | ClassCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type AcademicSessionCreateWithoutSchoolInput = {
    id?: string
    name: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fees?: FeesCreateNestedManyWithoutAcademicSessionInput
    invoices?: InvoiceCreateNestedManyWithoutAcademicSessionInput
  }

  export type AcademicSessionUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fees?: FeesUncheckedCreateNestedManyWithoutAcademicSessionInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAcademicSessionInput
  }

  export type AcademicSessionCreateOrConnectWithoutSchoolInput = {
    where: AcademicSessionWhereUniqueInput
    create: XOR<AcademicSessionCreateWithoutSchoolInput, AcademicSessionUncheckedCreateWithoutSchoolInput>
  }

  export type AcademicSessionCreateManySchoolInputEnvelope = {
    data: AcademicSessionCreateManySchoolInput | AcademicSessionCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type TermCreateWithoutSchoolInput = {
    id?: string
    name: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fees?: FeesCreateNestedManyWithoutTermInput
    invoices?: InvoiceCreateNestedManyWithoutTermInput
  }

  export type TermUncheckedCreateWithoutSchoolInput = {
    id?: string
    name: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fees?: FeesUncheckedCreateNestedManyWithoutTermInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTermInput
  }

  export type TermCreateOrConnectWithoutSchoolInput = {
    where: TermWhereUniqueInput
    create: XOR<TermCreateWithoutSchoolInput, TermUncheckedCreateWithoutSchoolInput>
  }

  export type TermCreateManySchoolInputEnvelope = {
    data: TermCreateManySchoolInput | TermCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type FeesCreateWithoutSchoolInput = {
    id?: string
    dueAt: Date | string
    latePaymentFee?: Decimal | DecimalJsLike | number | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutFeesInput
    academicSession: AcademicSessionCreateNestedOneWithoutFeesInput
    term: TermCreateNestedOneWithoutFeesInput
    feeBreakdowns?: FeeBreakdownCreateNestedManyWithoutFeeInput
  }

  export type FeesUncheckedCreateWithoutSchoolInput = {
    id?: string
    dueAt: Date | string
    latePaymentFee?: Decimal | DecimalJsLike | number | string
    classId: string
    sessionId: string
    termId: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    feeBreakdowns?: FeeBreakdownUncheckedCreateNestedManyWithoutFeeInput
  }

  export type FeesCreateOrConnectWithoutSchoolInput = {
    where: FeesWhereUniqueInput
    create: XOR<FeesCreateWithoutSchoolInput, FeesUncheckedCreateWithoutSchoolInput>
  }

  export type FeesCreateManySchoolInputEnvelope = {
    data: FeesCreateManySchoolInput | FeesCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type PayoutCreateWithoutSchoolInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string
    processingFee?: Decimal | DecimalJsLike | number | string
    status?: $Enums.PayoutStatus
    initiatedAt: Date | string
    completedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayoutUncheckedCreateWithoutSchoolInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string
    processingFee?: Decimal | DecimalJsLike | number | string
    status?: $Enums.PayoutStatus
    initiatedAt: Date | string
    completedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayoutCreateOrConnectWithoutSchoolInput = {
    where: PayoutWhereUniqueInput
    create: XOR<PayoutCreateWithoutSchoolInput, PayoutUncheckedCreateWithoutSchoolInput>
  }

  export type PayoutCreateManySchoolInputEnvelope = {
    data: PayoutCreateManySchoolInput | PayoutCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type KYCVerificationCreateWithoutSchoolInput = {
    id?: string
    status?: $Enums.KYCVerificationStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutKycverificationInput
  }

  export type KYCVerificationUncheckedCreateWithoutSchoolInput = {
    id?: string
    userId: string
    status?: $Enums.KYCVerificationStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KYCVerificationCreateOrConnectWithoutSchoolInput = {
    where: KYCVerificationWhereUniqueInput
    create: XOR<KYCVerificationCreateWithoutSchoolInput, KYCVerificationUncheckedCreateWithoutSchoolInput>
  }

  export type UserUpsertWithoutSchoolInput = {
    update: XOR<UserUpdateWithoutSchoolInput, UserUncheckedUpdateWithoutSchoolInput>
    create: XOR<UserCreateWithoutSchoolInput, UserUncheckedCreateWithoutSchoolInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSchoolInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSchoolInput, UserUncheckedUpdateWithoutSchoolInput>
  }

  export type UserUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTermsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isPrivacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    administrator?: AdministratorUpdateOneWithoutUserNestedInput
    guardian?: GuardianUpdateOneWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUpdateOneWithoutSignedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    credential?: CredentialUpdateOneWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    firebaseToken?: FirebaseTokenUpdateOneWithoutUserNestedInput
    kycverification?: KYCVerificationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTermsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isPrivacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    administrator?: AdministratorUncheckedUpdateOneWithoutUserNestedInput
    guardian?: GuardianUncheckedUpdateOneWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedUpdateOneWithoutSignedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    credential?: CredentialUncheckedUpdateOneWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    firebaseToken?: FirebaseTokenUncheckedUpdateOneWithoutUserNestedInput
    kycverification?: KYCVerificationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type SchoolDirectorVerificationUpsertWithoutSchoolInput = {
    update: XOR<SchoolDirectorVerificationUpdateWithoutSchoolInput, SchoolDirectorVerificationUncheckedUpdateWithoutSchoolInput>
    create: XOR<SchoolDirectorVerificationCreateWithoutSchoolInput, SchoolDirectorVerificationUncheckedCreateWithoutSchoolInput>
    where?: SchoolDirectorVerificationWhereInput
  }

  export type SchoolDirectorVerificationUpdateToOneWithWhereWithoutSchoolInput = {
    where?: SchoolDirectorVerificationWhereInput
    data: XOR<SchoolDirectorVerificationUpdateWithoutSchoolInput, SchoolDirectorVerificationUncheckedUpdateWithoutSchoolInput>
  }

  export type SchoolDirectorVerificationUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    directorFullName?: StringFieldUpdateOperationsInput | string
    directorIDType?: EnumDirectorIDTypeFieldUpdateOperationsInput | $Enums.DirectorIDType
    directorIDNumber?: StringFieldUpdateOperationsInput | string
    document?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolDirectorVerificationUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    directorFullName?: StringFieldUpdateOperationsInput | string
    directorIDType?: EnumDirectorIDTypeFieldUpdateOperationsInput | $Enums.DirectorIDType
    directorIDNumber?: StringFieldUpdateOperationsInput | string
    document?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolOwnershipVerificationUpsertWithoutSchoolInput = {
    update: XOR<SchoolOwnershipVerificationUpdateWithoutSchoolInput, SchoolOwnershipVerificationUncheckedUpdateWithoutSchoolInput>
    create: XOR<SchoolOwnershipVerificationCreateWithoutSchoolInput, SchoolOwnershipVerificationUncheckedCreateWithoutSchoolInput>
    where?: SchoolOwnershipVerificationWhereInput
  }

  export type SchoolOwnershipVerificationUpdateToOneWithWhereWithoutSchoolInput = {
    where?: SchoolOwnershipVerificationWhereInput
    data: XOR<SchoolOwnershipVerificationUpdateWithoutSchoolInput, SchoolOwnershipVerificationUncheckedUpdateWithoutSchoolInput>
  }

  export type SchoolOwnershipVerificationUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    cacform7?: StringFieldUpdateOperationsInput | string
    cacShareAllotmentForm?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolOwnershipVerificationUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    cacform7?: StringFieldUpdateOperationsInput | string
    cacShareAllotmentForm?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolVerificationUpsertWithoutSchoolInput = {
    update: XOR<SchoolVerificationUpdateWithoutSchoolInput, SchoolVerificationUncheckedUpdateWithoutSchoolInput>
    create: XOR<SchoolVerificationCreateWithoutSchoolInput, SchoolVerificationUncheckedCreateWithoutSchoolInput>
    where?: SchoolVerificationWhereInput
  }

  export type SchoolVerificationUpdateToOneWithWhereWithoutSchoolInput = {
    where?: SchoolVerificationWhereInput
    data: XOR<SchoolVerificationUpdateWithoutSchoolInput, SchoolVerificationUncheckedUpdateWithoutSchoolInput>
  }

  export type SchoolVerificationUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    cacCertificate?: StringFieldUpdateOperationsInput | string
    accreditationDocument?: StringFieldUpdateOperationsInput | string
    taxIdentificationNumber?: StringFieldUpdateOperationsInput | string
    licenseDocument?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolVerificationUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    cacCertificate?: StringFieldUpdateOperationsInput | string
    accreditationDocument?: StringFieldUpdateOperationsInput | string
    taxIdentificationNumber?: StringFieldUpdateOperationsInput | string
    licenseDocument?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolPayoutDetailUpsertWithoutSchoolInput = {
    update: XOR<SchoolPayoutDetailUpdateWithoutSchoolInput, SchoolPayoutDetailUncheckedUpdateWithoutSchoolInput>
    create: XOR<SchoolPayoutDetailCreateWithoutSchoolInput, SchoolPayoutDetailUncheckedCreateWithoutSchoolInput>
    where?: SchoolPayoutDetailWhereInput
  }

  export type SchoolPayoutDetailUpdateToOneWithWhereWithoutSchoolInput = {
    where?: SchoolPayoutDetailWhereInput
    data: XOR<SchoolPayoutDetailUpdateWithoutSchoolInput, SchoolPayoutDetailUncheckedUpdateWithoutSchoolInput>
  }

  export type SchoolPayoutDetailUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolPayoutDetailUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    bankCode?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolAndPlatformLegalAgreementUpsertWithoutSchoolInput = {
    update: XOR<SchoolAndPlatformLegalAgreementUpdateWithoutSchoolInput, SchoolAndPlatformLegalAgreementUncheckedUpdateWithoutSchoolInput>
    create: XOR<SchoolAndPlatformLegalAgreementCreateWithoutSchoolInput, SchoolAndPlatformLegalAgreementUncheckedCreateWithoutSchoolInput>
    where?: SchoolAndPlatformLegalAgreementWhereInput
  }

  export type SchoolAndPlatformLegalAgreementUpdateToOneWithWhereWithoutSchoolInput = {
    where?: SchoolAndPlatformLegalAgreementWhereInput
    data: XOR<SchoolAndPlatformLegalAgreementUpdateWithoutSchoolInput, SchoolAndPlatformLegalAgreementUncheckedUpdateWithoutSchoolInput>
  }

  export type SchoolAndPlatformLegalAgreementUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    legalDocumentRef?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signedBy?: UserUpdateOneRequiredWithoutSchoolAndPlatformLegalAgreementNestedInput
  }

  export type SchoolAndPlatformLegalAgreementUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedById?: StringFieldUpdateOperationsInput | string
    signature?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    legalDocumentRef?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUpsertWithWhereUniqueWithoutSchoolInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutSchoolInput, ClassUncheckedUpdateWithoutSchoolInput>
    create: XOR<ClassCreateWithoutSchoolInput, ClassUncheckedCreateWithoutSchoolInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutSchoolInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutSchoolInput, ClassUncheckedUpdateWithoutSchoolInput>
  }

  export type ClassUpdateManyWithWhereWithoutSchoolInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutSchoolInput>
  }

  export type ClassScalarWhereInput = {
    AND?: ClassScalarWhereInput | ClassScalarWhereInput[]
    OR?: ClassScalarWhereInput[]
    NOT?: ClassScalarWhereInput | ClassScalarWhereInput[]
    id?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    schoolId?: StringFilter<"Class"> | string
    isDeleted?: BoolFilter<"Class"> | boolean
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
  }

  export type AcademicSessionUpsertWithWhereUniqueWithoutSchoolInput = {
    where: AcademicSessionWhereUniqueInput
    update: XOR<AcademicSessionUpdateWithoutSchoolInput, AcademicSessionUncheckedUpdateWithoutSchoolInput>
    create: XOR<AcademicSessionCreateWithoutSchoolInput, AcademicSessionUncheckedCreateWithoutSchoolInput>
  }

  export type AcademicSessionUpdateWithWhereUniqueWithoutSchoolInput = {
    where: AcademicSessionWhereUniqueInput
    data: XOR<AcademicSessionUpdateWithoutSchoolInput, AcademicSessionUncheckedUpdateWithoutSchoolInput>
  }

  export type AcademicSessionUpdateManyWithWhereWithoutSchoolInput = {
    where: AcademicSessionScalarWhereInput
    data: XOR<AcademicSessionUpdateManyMutationInput, AcademicSessionUncheckedUpdateManyWithoutSchoolInput>
  }

  export type AcademicSessionScalarWhereInput = {
    AND?: AcademicSessionScalarWhereInput | AcademicSessionScalarWhereInput[]
    OR?: AcademicSessionScalarWhereInput[]
    NOT?: AcademicSessionScalarWhereInput | AcademicSessionScalarWhereInput[]
    id?: StringFilter<"AcademicSession"> | string
    name?: StringFilter<"AcademicSession"> | string
    schoolId?: StringFilter<"AcademicSession"> | string
    isDeleted?: BoolFilter<"AcademicSession"> | boolean
    createdAt?: DateTimeFilter<"AcademicSession"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicSession"> | Date | string
  }

  export type TermUpsertWithWhereUniqueWithoutSchoolInput = {
    where: TermWhereUniqueInput
    update: XOR<TermUpdateWithoutSchoolInput, TermUncheckedUpdateWithoutSchoolInput>
    create: XOR<TermCreateWithoutSchoolInput, TermUncheckedCreateWithoutSchoolInput>
  }

  export type TermUpdateWithWhereUniqueWithoutSchoolInput = {
    where: TermWhereUniqueInput
    data: XOR<TermUpdateWithoutSchoolInput, TermUncheckedUpdateWithoutSchoolInput>
  }

  export type TermUpdateManyWithWhereWithoutSchoolInput = {
    where: TermScalarWhereInput
    data: XOR<TermUpdateManyMutationInput, TermUncheckedUpdateManyWithoutSchoolInput>
  }

  export type TermScalarWhereInput = {
    AND?: TermScalarWhereInput | TermScalarWhereInput[]
    OR?: TermScalarWhereInput[]
    NOT?: TermScalarWhereInput | TermScalarWhereInput[]
    id?: StringFilter<"Term"> | string
    name?: StringFilter<"Term"> | string
    schoolId?: StringFilter<"Term"> | string
    isDeleted?: BoolFilter<"Term"> | boolean
    createdAt?: DateTimeFilter<"Term"> | Date | string
    updatedAt?: DateTimeFilter<"Term"> | Date | string
  }

  export type FeesUpsertWithWhereUniqueWithoutSchoolInput = {
    where: FeesWhereUniqueInput
    update: XOR<FeesUpdateWithoutSchoolInput, FeesUncheckedUpdateWithoutSchoolInput>
    create: XOR<FeesCreateWithoutSchoolInput, FeesUncheckedCreateWithoutSchoolInput>
  }

  export type FeesUpdateWithWhereUniqueWithoutSchoolInput = {
    where: FeesWhereUniqueInput
    data: XOR<FeesUpdateWithoutSchoolInput, FeesUncheckedUpdateWithoutSchoolInput>
  }

  export type FeesUpdateManyWithWhereWithoutSchoolInput = {
    where: FeesScalarWhereInput
    data: XOR<FeesUpdateManyMutationInput, FeesUncheckedUpdateManyWithoutSchoolInput>
  }

  export type FeesScalarWhereInput = {
    AND?: FeesScalarWhereInput | FeesScalarWhereInput[]
    OR?: FeesScalarWhereInput[]
    NOT?: FeesScalarWhereInput | FeesScalarWhereInput[]
    id?: StringFilter<"Fees"> | string
    dueAt?: DateTimeFilter<"Fees"> | Date | string
    latePaymentFee?: DecimalFilter<"Fees"> | Decimal | DecimalJsLike | number | string
    schoolId?: StringFilter<"Fees"> | string
    classId?: StringFilter<"Fees"> | string
    sessionId?: StringFilter<"Fees"> | string
    termId?: StringFilter<"Fees"> | string
    isDeleted?: BoolFilter<"Fees"> | boolean
    createdAt?: DateTimeFilter<"Fees"> | Date | string
    updatedAt?: DateTimeFilter<"Fees"> | Date | string
  }

  export type PayoutUpsertWithWhereUniqueWithoutSchoolInput = {
    where: PayoutWhereUniqueInput
    update: XOR<PayoutUpdateWithoutSchoolInput, PayoutUncheckedUpdateWithoutSchoolInput>
    create: XOR<PayoutCreateWithoutSchoolInput, PayoutUncheckedCreateWithoutSchoolInput>
  }

  export type PayoutUpdateWithWhereUniqueWithoutSchoolInput = {
    where: PayoutWhereUniqueInput
    data: XOR<PayoutUpdateWithoutSchoolInput, PayoutUncheckedUpdateWithoutSchoolInput>
  }

  export type PayoutUpdateManyWithWhereWithoutSchoolInput = {
    where: PayoutScalarWhereInput
    data: XOR<PayoutUpdateManyMutationInput, PayoutUncheckedUpdateManyWithoutSchoolInput>
  }

  export type PayoutScalarWhereInput = {
    AND?: PayoutScalarWhereInput | PayoutScalarWhereInput[]
    OR?: PayoutScalarWhereInput[]
    NOT?: PayoutScalarWhereInput | PayoutScalarWhereInput[]
    id?: StringFilter<"Payout"> | string
    schoolId?: StringFilter<"Payout"> | string
    amount?: DecimalFilter<"Payout"> | Decimal | DecimalJsLike | number | string
    processingFee?: DecimalFilter<"Payout"> | Decimal | DecimalJsLike | number | string
    status?: EnumPayoutStatusFilter<"Payout"> | $Enums.PayoutStatus
    initiatedAt?: DateTimeFilter<"Payout"> | Date | string
    completedAt?: DateTimeNullableFilter<"Payout"> | Date | string | null
    isDeleted?: BoolFilter<"Payout"> | boolean
    createdAt?: DateTimeFilter<"Payout"> | Date | string
    updatedAt?: DateTimeFilter<"Payout"> | Date | string
  }

  export type KYCVerificationUpsertWithoutSchoolInput = {
    update: XOR<KYCVerificationUpdateWithoutSchoolInput, KYCVerificationUncheckedUpdateWithoutSchoolInput>
    create: XOR<KYCVerificationCreateWithoutSchoolInput, KYCVerificationUncheckedCreateWithoutSchoolInput>
    where?: KYCVerificationWhereInput
  }

  export type KYCVerificationUpdateToOneWithWhereWithoutSchoolInput = {
    where?: KYCVerificationWhereInput
    data: XOR<KYCVerificationUpdateWithoutSchoolInput, KYCVerificationUncheckedUpdateWithoutSchoolInput>
  }

  export type KYCVerificationUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumKYCVerificationStatusFieldUpdateOperationsInput | $Enums.KYCVerificationStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutKycverificationNestedInput
  }

  export type KYCVerificationUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumKYCVerificationStatusFieldUpdateOperationsInput | $Enums.KYCVerificationStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolCreateWithoutSchoolDirectorVerificationInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutSchoolInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationCreateNestedOneWithoutSchoolInput
    schoolVerification?: SchoolVerificationCreateNestedOneWithoutSchoolInput
    schoolPayoutDetail?: SchoolPayoutDetailCreateNestedOneWithoutSchoolInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementCreateNestedOneWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    academicSessions?: AcademicSessionCreateNestedManyWithoutSchoolInput
    terms?: TermCreateNestedManyWithoutSchoolInput
    fees?: FeesCreateNestedManyWithoutSchoolInput
    payouts?: PayoutCreateNestedManyWithoutSchoolInput
    kycverification?: KYCVerificationCreateNestedOneWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutSchoolDirectorVerificationInput = {
    id?: string
    ownerId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolOwnershipVerification?: SchoolOwnershipVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolVerification?: SchoolVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolPayoutDetail?: SchoolPayoutDetailUncheckedCreateNestedOneWithoutSchoolInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedCreateNestedOneWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    academicSessions?: AcademicSessionUncheckedCreateNestedManyWithoutSchoolInput
    terms?: TermUncheckedCreateNestedManyWithoutSchoolInput
    fees?: FeesUncheckedCreateNestedManyWithoutSchoolInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutSchoolInput
    kycverification?: KYCVerificationUncheckedCreateNestedOneWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutSchoolDirectorVerificationInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutSchoolDirectorVerificationInput, SchoolUncheckedCreateWithoutSchoolDirectorVerificationInput>
  }

  export type SchoolUpsertWithoutSchoolDirectorVerificationInput = {
    update: XOR<SchoolUpdateWithoutSchoolDirectorVerificationInput, SchoolUncheckedUpdateWithoutSchoolDirectorVerificationInput>
    create: XOR<SchoolCreateWithoutSchoolDirectorVerificationInput, SchoolUncheckedCreateWithoutSchoolDirectorVerificationInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutSchoolDirectorVerificationInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutSchoolDirectorVerificationInput, SchoolUncheckedUpdateWithoutSchoolDirectorVerificationInput>
  }

  export type SchoolUpdateWithoutSchoolDirectorVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutSchoolNestedInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUpdateOneWithoutSchoolNestedInput
    schoolVerification?: SchoolVerificationUpdateOneWithoutSchoolNestedInput
    schoolPayoutDetail?: SchoolPayoutDetailUpdateOneWithoutSchoolNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUpdateOneWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    academicSessions?: AcademicSessionUpdateManyWithoutSchoolNestedInput
    terms?: TermUpdateManyWithoutSchoolNestedInput
    fees?: FeesUpdateManyWithoutSchoolNestedInput
    payouts?: PayoutUpdateManyWithoutSchoolNestedInput
    kycverification?: KYCVerificationUpdateOneWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutSchoolDirectorVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolOwnershipVerification?: SchoolOwnershipVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolVerification?: SchoolVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolPayoutDetail?: SchoolPayoutDetailUncheckedUpdateOneWithoutSchoolNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedUpdateOneWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    academicSessions?: AcademicSessionUncheckedUpdateManyWithoutSchoolNestedInput
    terms?: TermUncheckedUpdateManyWithoutSchoolNestedInput
    fees?: FeesUncheckedUpdateManyWithoutSchoolNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutSchoolNestedInput
    kycverification?: KYCVerificationUncheckedUpdateOneWithoutSchoolNestedInput
  }

  export type SchoolCreateWithoutSchoolOwnershipVerificationInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutSchoolInput
    schoolDirectorVerification?: SchoolDirectorVerificationCreateNestedOneWithoutSchoolInput
    schoolVerification?: SchoolVerificationCreateNestedOneWithoutSchoolInput
    schoolPayoutDetail?: SchoolPayoutDetailCreateNestedOneWithoutSchoolInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementCreateNestedOneWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    academicSessions?: AcademicSessionCreateNestedManyWithoutSchoolInput
    terms?: TermCreateNestedManyWithoutSchoolInput
    fees?: FeesCreateNestedManyWithoutSchoolInput
    payouts?: PayoutCreateNestedManyWithoutSchoolInput
    kycverification?: KYCVerificationCreateNestedOneWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutSchoolOwnershipVerificationInput = {
    id?: string
    ownerId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolDirectorVerification?: SchoolDirectorVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolVerification?: SchoolVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolPayoutDetail?: SchoolPayoutDetailUncheckedCreateNestedOneWithoutSchoolInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedCreateNestedOneWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    academicSessions?: AcademicSessionUncheckedCreateNestedManyWithoutSchoolInput
    terms?: TermUncheckedCreateNestedManyWithoutSchoolInput
    fees?: FeesUncheckedCreateNestedManyWithoutSchoolInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutSchoolInput
    kycverification?: KYCVerificationUncheckedCreateNestedOneWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutSchoolOwnershipVerificationInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutSchoolOwnershipVerificationInput, SchoolUncheckedCreateWithoutSchoolOwnershipVerificationInput>
  }

  export type SchoolUpsertWithoutSchoolOwnershipVerificationInput = {
    update: XOR<SchoolUpdateWithoutSchoolOwnershipVerificationInput, SchoolUncheckedUpdateWithoutSchoolOwnershipVerificationInput>
    create: XOR<SchoolCreateWithoutSchoolOwnershipVerificationInput, SchoolUncheckedCreateWithoutSchoolOwnershipVerificationInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutSchoolOwnershipVerificationInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutSchoolOwnershipVerificationInput, SchoolUncheckedUpdateWithoutSchoolOwnershipVerificationInput>
  }

  export type SchoolUpdateWithoutSchoolOwnershipVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutSchoolNestedInput
    schoolDirectorVerification?: SchoolDirectorVerificationUpdateOneWithoutSchoolNestedInput
    schoolVerification?: SchoolVerificationUpdateOneWithoutSchoolNestedInput
    schoolPayoutDetail?: SchoolPayoutDetailUpdateOneWithoutSchoolNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUpdateOneWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    academicSessions?: AcademicSessionUpdateManyWithoutSchoolNestedInput
    terms?: TermUpdateManyWithoutSchoolNestedInput
    fees?: FeesUpdateManyWithoutSchoolNestedInput
    payouts?: PayoutUpdateManyWithoutSchoolNestedInput
    kycverification?: KYCVerificationUpdateOneWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutSchoolOwnershipVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolDirectorVerification?: SchoolDirectorVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolVerification?: SchoolVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolPayoutDetail?: SchoolPayoutDetailUncheckedUpdateOneWithoutSchoolNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedUpdateOneWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    academicSessions?: AcademicSessionUncheckedUpdateManyWithoutSchoolNestedInput
    terms?: TermUncheckedUpdateManyWithoutSchoolNestedInput
    fees?: FeesUncheckedUpdateManyWithoutSchoolNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutSchoolNestedInput
    kycverification?: KYCVerificationUncheckedUpdateOneWithoutSchoolNestedInput
  }

  export type SchoolCreateWithoutSchoolVerificationInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutSchoolInput
    schoolDirectorVerification?: SchoolDirectorVerificationCreateNestedOneWithoutSchoolInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationCreateNestedOneWithoutSchoolInput
    schoolPayoutDetail?: SchoolPayoutDetailCreateNestedOneWithoutSchoolInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementCreateNestedOneWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    academicSessions?: AcademicSessionCreateNestedManyWithoutSchoolInput
    terms?: TermCreateNestedManyWithoutSchoolInput
    fees?: FeesCreateNestedManyWithoutSchoolInput
    payouts?: PayoutCreateNestedManyWithoutSchoolInput
    kycverification?: KYCVerificationCreateNestedOneWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutSchoolVerificationInput = {
    id?: string
    ownerId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolDirectorVerification?: SchoolDirectorVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolPayoutDetail?: SchoolPayoutDetailUncheckedCreateNestedOneWithoutSchoolInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedCreateNestedOneWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    academicSessions?: AcademicSessionUncheckedCreateNestedManyWithoutSchoolInput
    terms?: TermUncheckedCreateNestedManyWithoutSchoolInput
    fees?: FeesUncheckedCreateNestedManyWithoutSchoolInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutSchoolInput
    kycverification?: KYCVerificationUncheckedCreateNestedOneWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutSchoolVerificationInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutSchoolVerificationInput, SchoolUncheckedCreateWithoutSchoolVerificationInput>
  }

  export type SchoolUpsertWithoutSchoolVerificationInput = {
    update: XOR<SchoolUpdateWithoutSchoolVerificationInput, SchoolUncheckedUpdateWithoutSchoolVerificationInput>
    create: XOR<SchoolCreateWithoutSchoolVerificationInput, SchoolUncheckedCreateWithoutSchoolVerificationInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutSchoolVerificationInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutSchoolVerificationInput, SchoolUncheckedUpdateWithoutSchoolVerificationInput>
  }

  export type SchoolUpdateWithoutSchoolVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutSchoolNestedInput
    schoolDirectorVerification?: SchoolDirectorVerificationUpdateOneWithoutSchoolNestedInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUpdateOneWithoutSchoolNestedInput
    schoolPayoutDetail?: SchoolPayoutDetailUpdateOneWithoutSchoolNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUpdateOneWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    academicSessions?: AcademicSessionUpdateManyWithoutSchoolNestedInput
    terms?: TermUpdateManyWithoutSchoolNestedInput
    fees?: FeesUpdateManyWithoutSchoolNestedInput
    payouts?: PayoutUpdateManyWithoutSchoolNestedInput
    kycverification?: KYCVerificationUpdateOneWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutSchoolVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolDirectorVerification?: SchoolDirectorVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolPayoutDetail?: SchoolPayoutDetailUncheckedUpdateOneWithoutSchoolNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedUpdateOneWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    academicSessions?: AcademicSessionUncheckedUpdateManyWithoutSchoolNestedInput
    terms?: TermUncheckedUpdateManyWithoutSchoolNestedInput
    fees?: FeesUncheckedUpdateManyWithoutSchoolNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutSchoolNestedInput
    kycverification?: KYCVerificationUncheckedUpdateOneWithoutSchoolNestedInput
  }

  export type SchoolCreateWithoutSchoolPayoutDetailInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutSchoolInput
    schoolDirectorVerification?: SchoolDirectorVerificationCreateNestedOneWithoutSchoolInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationCreateNestedOneWithoutSchoolInput
    schoolVerification?: SchoolVerificationCreateNestedOneWithoutSchoolInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementCreateNestedOneWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    academicSessions?: AcademicSessionCreateNestedManyWithoutSchoolInput
    terms?: TermCreateNestedManyWithoutSchoolInput
    fees?: FeesCreateNestedManyWithoutSchoolInput
    payouts?: PayoutCreateNestedManyWithoutSchoolInput
    kycverification?: KYCVerificationCreateNestedOneWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutSchoolPayoutDetailInput = {
    id?: string
    ownerId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolDirectorVerification?: SchoolDirectorVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolVerification?: SchoolVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedCreateNestedOneWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    academicSessions?: AcademicSessionUncheckedCreateNestedManyWithoutSchoolInput
    terms?: TermUncheckedCreateNestedManyWithoutSchoolInput
    fees?: FeesUncheckedCreateNestedManyWithoutSchoolInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutSchoolInput
    kycverification?: KYCVerificationUncheckedCreateNestedOneWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutSchoolPayoutDetailInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutSchoolPayoutDetailInput, SchoolUncheckedCreateWithoutSchoolPayoutDetailInput>
  }

  export type SchoolUpsertWithoutSchoolPayoutDetailInput = {
    update: XOR<SchoolUpdateWithoutSchoolPayoutDetailInput, SchoolUncheckedUpdateWithoutSchoolPayoutDetailInput>
    create: XOR<SchoolCreateWithoutSchoolPayoutDetailInput, SchoolUncheckedCreateWithoutSchoolPayoutDetailInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutSchoolPayoutDetailInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutSchoolPayoutDetailInput, SchoolUncheckedUpdateWithoutSchoolPayoutDetailInput>
  }

  export type SchoolUpdateWithoutSchoolPayoutDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutSchoolNestedInput
    schoolDirectorVerification?: SchoolDirectorVerificationUpdateOneWithoutSchoolNestedInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUpdateOneWithoutSchoolNestedInput
    schoolVerification?: SchoolVerificationUpdateOneWithoutSchoolNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUpdateOneWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    academicSessions?: AcademicSessionUpdateManyWithoutSchoolNestedInput
    terms?: TermUpdateManyWithoutSchoolNestedInput
    fees?: FeesUpdateManyWithoutSchoolNestedInput
    payouts?: PayoutUpdateManyWithoutSchoolNestedInput
    kycverification?: KYCVerificationUpdateOneWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutSchoolPayoutDetailInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolDirectorVerification?: SchoolDirectorVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolVerification?: SchoolVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedUpdateOneWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    academicSessions?: AcademicSessionUncheckedUpdateManyWithoutSchoolNestedInput
    terms?: TermUncheckedUpdateManyWithoutSchoolNestedInput
    fees?: FeesUncheckedUpdateManyWithoutSchoolNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutSchoolNestedInput
    kycverification?: KYCVerificationUncheckedUpdateOneWithoutSchoolNestedInput
  }

  export type SchoolCreateWithoutSchoolAndPlatformLegalAgreementInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutSchoolInput
    schoolDirectorVerification?: SchoolDirectorVerificationCreateNestedOneWithoutSchoolInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationCreateNestedOneWithoutSchoolInput
    schoolVerification?: SchoolVerificationCreateNestedOneWithoutSchoolInput
    schoolPayoutDetail?: SchoolPayoutDetailCreateNestedOneWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    academicSessions?: AcademicSessionCreateNestedManyWithoutSchoolInput
    terms?: TermCreateNestedManyWithoutSchoolInput
    fees?: FeesCreateNestedManyWithoutSchoolInput
    payouts?: PayoutCreateNestedManyWithoutSchoolInput
    kycverification?: KYCVerificationCreateNestedOneWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutSchoolAndPlatformLegalAgreementInput = {
    id?: string
    ownerId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolDirectorVerification?: SchoolDirectorVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolVerification?: SchoolVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolPayoutDetail?: SchoolPayoutDetailUncheckedCreateNestedOneWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    academicSessions?: AcademicSessionUncheckedCreateNestedManyWithoutSchoolInput
    terms?: TermUncheckedCreateNestedManyWithoutSchoolInput
    fees?: FeesUncheckedCreateNestedManyWithoutSchoolInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutSchoolInput
    kycverification?: KYCVerificationUncheckedCreateNestedOneWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutSchoolAndPlatformLegalAgreementInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutSchoolAndPlatformLegalAgreementInput, SchoolUncheckedCreateWithoutSchoolAndPlatformLegalAgreementInput>
  }

  export type UserCreateWithoutSchoolAndPlatformLegalAgreementInput = {
    id?: string
    firstName: string
    lastName: string
    profileImage?: string | null
    email: string
    type: $Enums.UserType
    phone?: string | null
    accountStatus?: $Enums.AccountStatus
    verifiedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    administrator?: AdministratorCreateNestedOneWithoutUserInput
    guardian?: GuardianCreateNestedOneWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    school?: SchoolCreateNestedOneWithoutOwnerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    credential?: CredentialCreateNestedOneWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    firebaseToken?: FirebaseTokenCreateNestedOneWithoutUserInput
    kycverification?: KYCVerificationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSchoolAndPlatformLegalAgreementInput = {
    id?: string
    firstName: string
    lastName: string
    profileImage?: string | null
    email: string
    type: $Enums.UserType
    phone?: string | null
    accountStatus?: $Enums.AccountStatus
    verifiedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    administrator?: AdministratorUncheckedCreateNestedOneWithoutUserInput
    guardian?: GuardianUncheckedCreateNestedOneWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    school?: SchoolUncheckedCreateNestedOneWithoutOwnerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    credential?: CredentialUncheckedCreateNestedOneWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    firebaseToken?: FirebaseTokenUncheckedCreateNestedOneWithoutUserInput
    kycverification?: KYCVerificationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSchoolAndPlatformLegalAgreementInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSchoolAndPlatformLegalAgreementInput, UserUncheckedCreateWithoutSchoolAndPlatformLegalAgreementInput>
  }

  export type SchoolUpsertWithoutSchoolAndPlatformLegalAgreementInput = {
    update: XOR<SchoolUpdateWithoutSchoolAndPlatformLegalAgreementInput, SchoolUncheckedUpdateWithoutSchoolAndPlatformLegalAgreementInput>
    create: XOR<SchoolCreateWithoutSchoolAndPlatformLegalAgreementInput, SchoolUncheckedCreateWithoutSchoolAndPlatformLegalAgreementInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutSchoolAndPlatformLegalAgreementInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutSchoolAndPlatformLegalAgreementInput, SchoolUncheckedUpdateWithoutSchoolAndPlatformLegalAgreementInput>
  }

  export type SchoolUpdateWithoutSchoolAndPlatformLegalAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutSchoolNestedInput
    schoolDirectorVerification?: SchoolDirectorVerificationUpdateOneWithoutSchoolNestedInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUpdateOneWithoutSchoolNestedInput
    schoolVerification?: SchoolVerificationUpdateOneWithoutSchoolNestedInput
    schoolPayoutDetail?: SchoolPayoutDetailUpdateOneWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    academicSessions?: AcademicSessionUpdateManyWithoutSchoolNestedInput
    terms?: TermUpdateManyWithoutSchoolNestedInput
    fees?: FeesUpdateManyWithoutSchoolNestedInput
    payouts?: PayoutUpdateManyWithoutSchoolNestedInput
    kycverification?: KYCVerificationUpdateOneWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutSchoolAndPlatformLegalAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolDirectorVerification?: SchoolDirectorVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolVerification?: SchoolVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolPayoutDetail?: SchoolPayoutDetailUncheckedUpdateOneWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    academicSessions?: AcademicSessionUncheckedUpdateManyWithoutSchoolNestedInput
    terms?: TermUncheckedUpdateManyWithoutSchoolNestedInput
    fees?: FeesUncheckedUpdateManyWithoutSchoolNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutSchoolNestedInput
    kycverification?: KYCVerificationUncheckedUpdateOneWithoutSchoolNestedInput
  }

  export type UserUpsertWithoutSchoolAndPlatformLegalAgreementInput = {
    update: XOR<UserUpdateWithoutSchoolAndPlatformLegalAgreementInput, UserUncheckedUpdateWithoutSchoolAndPlatformLegalAgreementInput>
    create: XOR<UserCreateWithoutSchoolAndPlatformLegalAgreementInput, UserUncheckedCreateWithoutSchoolAndPlatformLegalAgreementInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSchoolAndPlatformLegalAgreementInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSchoolAndPlatformLegalAgreementInput, UserUncheckedUpdateWithoutSchoolAndPlatformLegalAgreementInput>
  }

  export type UserUpdateWithoutSchoolAndPlatformLegalAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTermsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isPrivacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    administrator?: AdministratorUpdateOneWithoutUserNestedInput
    guardian?: GuardianUpdateOneWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    school?: SchoolUpdateOneWithoutOwnerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    credential?: CredentialUpdateOneWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    firebaseToken?: FirebaseTokenUpdateOneWithoutUserNestedInput
    kycverification?: KYCVerificationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSchoolAndPlatformLegalAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTermsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isPrivacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    administrator?: AdministratorUncheckedUpdateOneWithoutUserNestedInput
    guardian?: GuardianUncheckedUpdateOneWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    school?: SchoolUncheckedUpdateOneWithoutOwnerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    credential?: CredentialUncheckedUpdateOneWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    firebaseToken?: FirebaseTokenUncheckedUpdateOneWithoutUserNestedInput
    kycverification?: KYCVerificationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutKycverificationInput = {
    id?: string
    firstName: string
    lastName: string
    profileImage?: string | null
    email: string
    type: $Enums.UserType
    phone?: string | null
    accountStatus?: $Enums.AccountStatus
    verifiedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    administrator?: AdministratorCreateNestedOneWithoutUserInput
    guardian?: GuardianCreateNestedOneWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    school?: SchoolCreateNestedOneWithoutOwnerInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementCreateNestedOneWithoutSignedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    credential?: CredentialCreateNestedOneWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    firebaseToken?: FirebaseTokenCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutKycverificationInput = {
    id?: string
    firstName: string
    lastName: string
    profileImage?: string | null
    email: string
    type: $Enums.UserType
    phone?: string | null
    accountStatus?: $Enums.AccountStatus
    verifiedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    administrator?: AdministratorUncheckedCreateNestedOneWithoutUserInput
    guardian?: GuardianUncheckedCreateNestedOneWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    school?: SchoolUncheckedCreateNestedOneWithoutOwnerInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedCreateNestedOneWithoutSignedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    credential?: CredentialUncheckedCreateNestedOneWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    firebaseToken?: FirebaseTokenUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutKycverificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutKycverificationInput, UserUncheckedCreateWithoutKycverificationInput>
  }

  export type SchoolCreateWithoutKycverificationInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutSchoolInput
    schoolDirectorVerification?: SchoolDirectorVerificationCreateNestedOneWithoutSchoolInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationCreateNestedOneWithoutSchoolInput
    schoolVerification?: SchoolVerificationCreateNestedOneWithoutSchoolInput
    schoolPayoutDetail?: SchoolPayoutDetailCreateNestedOneWithoutSchoolInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementCreateNestedOneWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    academicSessions?: AcademicSessionCreateNestedManyWithoutSchoolInput
    terms?: TermCreateNestedManyWithoutSchoolInput
    fees?: FeesCreateNestedManyWithoutSchoolInput
    payouts?: PayoutCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutKycverificationInput = {
    id?: string
    ownerId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolDirectorVerification?: SchoolDirectorVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolVerification?: SchoolVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolPayoutDetail?: SchoolPayoutDetailUncheckedCreateNestedOneWithoutSchoolInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedCreateNestedOneWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    academicSessions?: AcademicSessionUncheckedCreateNestedManyWithoutSchoolInput
    terms?: TermUncheckedCreateNestedManyWithoutSchoolInput
    fees?: FeesUncheckedCreateNestedManyWithoutSchoolInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutKycverificationInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutKycverificationInput, SchoolUncheckedCreateWithoutKycverificationInput>
  }

  export type UserUpsertWithoutKycverificationInput = {
    update: XOR<UserUpdateWithoutKycverificationInput, UserUncheckedUpdateWithoutKycverificationInput>
    create: XOR<UserCreateWithoutKycverificationInput, UserUncheckedCreateWithoutKycverificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutKycverificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutKycverificationInput, UserUncheckedUpdateWithoutKycverificationInput>
  }

  export type UserUpdateWithoutKycverificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTermsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isPrivacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    administrator?: AdministratorUpdateOneWithoutUserNestedInput
    guardian?: GuardianUpdateOneWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    school?: SchoolUpdateOneWithoutOwnerNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUpdateOneWithoutSignedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    credential?: CredentialUpdateOneWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    firebaseToken?: FirebaseTokenUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutKycverificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTermsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isPrivacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    administrator?: AdministratorUncheckedUpdateOneWithoutUserNestedInput
    guardian?: GuardianUncheckedUpdateOneWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    school?: SchoolUncheckedUpdateOneWithoutOwnerNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedUpdateOneWithoutSignedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    credential?: CredentialUncheckedUpdateOneWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    firebaseToken?: FirebaseTokenUncheckedUpdateOneWithoutUserNestedInput
  }

  export type SchoolUpsertWithoutKycverificationInput = {
    update: XOR<SchoolUpdateWithoutKycverificationInput, SchoolUncheckedUpdateWithoutKycverificationInput>
    create: XOR<SchoolCreateWithoutKycverificationInput, SchoolUncheckedCreateWithoutKycverificationInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutKycverificationInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutKycverificationInput, SchoolUncheckedUpdateWithoutKycverificationInput>
  }

  export type SchoolUpdateWithoutKycverificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutSchoolNestedInput
    schoolDirectorVerification?: SchoolDirectorVerificationUpdateOneWithoutSchoolNestedInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUpdateOneWithoutSchoolNestedInput
    schoolVerification?: SchoolVerificationUpdateOneWithoutSchoolNestedInput
    schoolPayoutDetail?: SchoolPayoutDetailUpdateOneWithoutSchoolNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUpdateOneWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    academicSessions?: AcademicSessionUpdateManyWithoutSchoolNestedInput
    terms?: TermUpdateManyWithoutSchoolNestedInput
    fees?: FeesUpdateManyWithoutSchoolNestedInput
    payouts?: PayoutUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutKycverificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolDirectorVerification?: SchoolDirectorVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolVerification?: SchoolVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolPayoutDetail?: SchoolPayoutDetailUncheckedUpdateOneWithoutSchoolNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedUpdateOneWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    academicSessions?: AcademicSessionUncheckedUpdateManyWithoutSchoolNestedInput
    terms?: TermUncheckedUpdateManyWithoutSchoolNestedInput
    fees?: FeesUncheckedUpdateManyWithoutSchoolNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateWithoutClassesInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutSchoolInput
    schoolDirectorVerification?: SchoolDirectorVerificationCreateNestedOneWithoutSchoolInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationCreateNestedOneWithoutSchoolInput
    schoolVerification?: SchoolVerificationCreateNestedOneWithoutSchoolInput
    schoolPayoutDetail?: SchoolPayoutDetailCreateNestedOneWithoutSchoolInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementCreateNestedOneWithoutSchoolInput
    academicSessions?: AcademicSessionCreateNestedManyWithoutSchoolInput
    terms?: TermCreateNestedManyWithoutSchoolInput
    fees?: FeesCreateNestedManyWithoutSchoolInput
    payouts?: PayoutCreateNestedManyWithoutSchoolInput
    kycverification?: KYCVerificationCreateNestedOneWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutClassesInput = {
    id?: string
    ownerId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolDirectorVerification?: SchoolDirectorVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolVerification?: SchoolVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolPayoutDetail?: SchoolPayoutDetailUncheckedCreateNestedOneWithoutSchoolInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedCreateNestedOneWithoutSchoolInput
    academicSessions?: AcademicSessionUncheckedCreateNestedManyWithoutSchoolInput
    terms?: TermUncheckedCreateNestedManyWithoutSchoolInput
    fees?: FeesUncheckedCreateNestedManyWithoutSchoolInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutSchoolInput
    kycverification?: KYCVerificationUncheckedCreateNestedOneWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutClassesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
  }

  export type FeesCreateWithoutClassInput = {
    id?: string
    dueAt: Date | string
    latePaymentFee?: Decimal | DecimalJsLike | number | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    academicSession: AcademicSessionCreateNestedOneWithoutFeesInput
    term: TermCreateNestedOneWithoutFeesInput
    school: SchoolCreateNestedOneWithoutFeesInput
    feeBreakdowns?: FeeBreakdownCreateNestedManyWithoutFeeInput
  }

  export type FeesUncheckedCreateWithoutClassInput = {
    id?: string
    dueAt: Date | string
    latePaymentFee?: Decimal | DecimalJsLike | number | string
    schoolId: string
    sessionId: string
    termId: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    feeBreakdowns?: FeeBreakdownUncheckedCreateNestedManyWithoutFeeInput
  }

  export type FeesCreateOrConnectWithoutClassInput = {
    where: FeesWhereUniqueInput
    create: XOR<FeesCreateWithoutClassInput, FeesUncheckedCreateWithoutClassInput>
  }

  export type FeesCreateManyClassInputEnvelope = {
    data: FeesCreateManyClassInput | FeesCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutClassInput = {
    id?: string
    invoiceNo: string
    feeId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueAt: Date | string
    paidAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    guardian: GuardianCreateNestedOneWithoutInvoicesInput
    academicSession: AcademicSessionCreateNestedOneWithoutInvoicesInput
    term: TermCreateNestedOneWithoutInvoicesInput
    transactions?: TransactionCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutClassInput = {
    id?: string
    invoiceNo: string
    feeId: string
    guardianId: string
    sessionId: string
    termId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueAt: Date | string
    paidAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutClassInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutClassInput, InvoiceUncheckedCreateWithoutClassInput>
  }

  export type InvoiceCreateManyClassInputEnvelope = {
    data: InvoiceCreateManyClassInput | InvoiceCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutClassInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    registrationNumber: string
    status?: $Enums.StudentStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    guardian?: GuardianCreateNestedOneWithoutStudentsInput
    linkedStudentProfile?: LinkedStudentProfileCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutClassInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    guardianId?: string | null
    registrationNumber: string
    status?: $Enums.StudentStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    linkedStudentProfile?: LinkedStudentProfileUncheckedCreateNestedOneWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutClassInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput>
  }

  export type StudentCreateManyClassInputEnvelope = {
    data: StudentCreateManyClassInput | StudentCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutClassesInput = {
    update: XOR<SchoolUpdateWithoutClassesInput, SchoolUncheckedUpdateWithoutClassesInput>
    create: XOR<SchoolCreateWithoutClassesInput, SchoolUncheckedCreateWithoutClassesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutClassesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutClassesInput, SchoolUncheckedUpdateWithoutClassesInput>
  }

  export type SchoolUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutSchoolNestedInput
    schoolDirectorVerification?: SchoolDirectorVerificationUpdateOneWithoutSchoolNestedInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUpdateOneWithoutSchoolNestedInput
    schoolVerification?: SchoolVerificationUpdateOneWithoutSchoolNestedInput
    schoolPayoutDetail?: SchoolPayoutDetailUpdateOneWithoutSchoolNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUpdateOneWithoutSchoolNestedInput
    academicSessions?: AcademicSessionUpdateManyWithoutSchoolNestedInput
    terms?: TermUpdateManyWithoutSchoolNestedInput
    fees?: FeesUpdateManyWithoutSchoolNestedInput
    payouts?: PayoutUpdateManyWithoutSchoolNestedInput
    kycverification?: KYCVerificationUpdateOneWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolDirectorVerification?: SchoolDirectorVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolVerification?: SchoolVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolPayoutDetail?: SchoolPayoutDetailUncheckedUpdateOneWithoutSchoolNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedUpdateOneWithoutSchoolNestedInput
    academicSessions?: AcademicSessionUncheckedUpdateManyWithoutSchoolNestedInput
    terms?: TermUncheckedUpdateManyWithoutSchoolNestedInput
    fees?: FeesUncheckedUpdateManyWithoutSchoolNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutSchoolNestedInput
    kycverification?: KYCVerificationUncheckedUpdateOneWithoutSchoolNestedInput
  }

  export type FeesUpsertWithWhereUniqueWithoutClassInput = {
    where: FeesWhereUniqueInput
    update: XOR<FeesUpdateWithoutClassInput, FeesUncheckedUpdateWithoutClassInput>
    create: XOR<FeesCreateWithoutClassInput, FeesUncheckedCreateWithoutClassInput>
  }

  export type FeesUpdateWithWhereUniqueWithoutClassInput = {
    where: FeesWhereUniqueInput
    data: XOR<FeesUpdateWithoutClassInput, FeesUncheckedUpdateWithoutClassInput>
  }

  export type FeesUpdateManyWithWhereWithoutClassInput = {
    where: FeesScalarWhereInput
    data: XOR<FeesUpdateManyMutationInput, FeesUncheckedUpdateManyWithoutClassInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutClassInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutClassInput, InvoiceUncheckedUpdateWithoutClassInput>
    create: XOR<InvoiceCreateWithoutClassInput, InvoiceUncheckedCreateWithoutClassInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutClassInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutClassInput, InvoiceUncheckedUpdateWithoutClassInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutClassInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutClassInput>
  }

  export type StudentUpsertWithWhereUniqueWithoutClassInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutClassInput, StudentUncheckedUpdateWithoutClassInput>
    create: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutClassInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutClassInput, StudentUncheckedUpdateWithoutClassInput>
  }

  export type StudentUpdateManyWithWhereWithoutClassInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutClassInput>
  }

  export type SchoolCreateWithoutAcademicSessionsInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutSchoolInput
    schoolDirectorVerification?: SchoolDirectorVerificationCreateNestedOneWithoutSchoolInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationCreateNestedOneWithoutSchoolInput
    schoolVerification?: SchoolVerificationCreateNestedOneWithoutSchoolInput
    schoolPayoutDetail?: SchoolPayoutDetailCreateNestedOneWithoutSchoolInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementCreateNestedOneWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    terms?: TermCreateNestedManyWithoutSchoolInput
    fees?: FeesCreateNestedManyWithoutSchoolInput
    payouts?: PayoutCreateNestedManyWithoutSchoolInput
    kycverification?: KYCVerificationCreateNestedOneWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutAcademicSessionsInput = {
    id?: string
    ownerId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolDirectorVerification?: SchoolDirectorVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolVerification?: SchoolVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolPayoutDetail?: SchoolPayoutDetailUncheckedCreateNestedOneWithoutSchoolInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedCreateNestedOneWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    terms?: TermUncheckedCreateNestedManyWithoutSchoolInput
    fees?: FeesUncheckedCreateNestedManyWithoutSchoolInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutSchoolInput
    kycverification?: KYCVerificationUncheckedCreateNestedOneWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutAcademicSessionsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutAcademicSessionsInput, SchoolUncheckedCreateWithoutAcademicSessionsInput>
  }

  export type FeesCreateWithoutAcademicSessionInput = {
    id?: string
    dueAt: Date | string
    latePaymentFee?: Decimal | DecimalJsLike | number | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutFeesInput
    term: TermCreateNestedOneWithoutFeesInput
    school: SchoolCreateNestedOneWithoutFeesInput
    feeBreakdowns?: FeeBreakdownCreateNestedManyWithoutFeeInput
  }

  export type FeesUncheckedCreateWithoutAcademicSessionInput = {
    id?: string
    dueAt: Date | string
    latePaymentFee?: Decimal | DecimalJsLike | number | string
    schoolId: string
    classId: string
    termId: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    feeBreakdowns?: FeeBreakdownUncheckedCreateNestedManyWithoutFeeInput
  }

  export type FeesCreateOrConnectWithoutAcademicSessionInput = {
    where: FeesWhereUniqueInput
    create: XOR<FeesCreateWithoutAcademicSessionInput, FeesUncheckedCreateWithoutAcademicSessionInput>
  }

  export type FeesCreateManyAcademicSessionInputEnvelope = {
    data: FeesCreateManyAcademicSessionInput | FeesCreateManyAcademicSessionInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutAcademicSessionInput = {
    id?: string
    invoiceNo: string
    feeId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueAt: Date | string
    paidAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    guardian: GuardianCreateNestedOneWithoutInvoicesInput
    class: ClassCreateNestedOneWithoutInvoicesInput
    term: TermCreateNestedOneWithoutInvoicesInput
    transactions?: TransactionCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutAcademicSessionInput = {
    id?: string
    invoiceNo: string
    feeId: string
    guardianId: string
    classId: string
    termId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueAt: Date | string
    paidAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutAcademicSessionInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutAcademicSessionInput, InvoiceUncheckedCreateWithoutAcademicSessionInput>
  }

  export type InvoiceCreateManyAcademicSessionInputEnvelope = {
    data: InvoiceCreateManyAcademicSessionInput | InvoiceCreateManyAcademicSessionInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutAcademicSessionsInput = {
    update: XOR<SchoolUpdateWithoutAcademicSessionsInput, SchoolUncheckedUpdateWithoutAcademicSessionsInput>
    create: XOR<SchoolCreateWithoutAcademicSessionsInput, SchoolUncheckedCreateWithoutAcademicSessionsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutAcademicSessionsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutAcademicSessionsInput, SchoolUncheckedUpdateWithoutAcademicSessionsInput>
  }

  export type SchoolUpdateWithoutAcademicSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutSchoolNestedInput
    schoolDirectorVerification?: SchoolDirectorVerificationUpdateOneWithoutSchoolNestedInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUpdateOneWithoutSchoolNestedInput
    schoolVerification?: SchoolVerificationUpdateOneWithoutSchoolNestedInput
    schoolPayoutDetail?: SchoolPayoutDetailUpdateOneWithoutSchoolNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUpdateOneWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    terms?: TermUpdateManyWithoutSchoolNestedInput
    fees?: FeesUpdateManyWithoutSchoolNestedInput
    payouts?: PayoutUpdateManyWithoutSchoolNestedInput
    kycverification?: KYCVerificationUpdateOneWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutAcademicSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolDirectorVerification?: SchoolDirectorVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolVerification?: SchoolVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolPayoutDetail?: SchoolPayoutDetailUncheckedUpdateOneWithoutSchoolNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedUpdateOneWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    terms?: TermUncheckedUpdateManyWithoutSchoolNestedInput
    fees?: FeesUncheckedUpdateManyWithoutSchoolNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutSchoolNestedInput
    kycverification?: KYCVerificationUncheckedUpdateOneWithoutSchoolNestedInput
  }

  export type FeesUpsertWithWhereUniqueWithoutAcademicSessionInput = {
    where: FeesWhereUniqueInput
    update: XOR<FeesUpdateWithoutAcademicSessionInput, FeesUncheckedUpdateWithoutAcademicSessionInput>
    create: XOR<FeesCreateWithoutAcademicSessionInput, FeesUncheckedCreateWithoutAcademicSessionInput>
  }

  export type FeesUpdateWithWhereUniqueWithoutAcademicSessionInput = {
    where: FeesWhereUniqueInput
    data: XOR<FeesUpdateWithoutAcademicSessionInput, FeesUncheckedUpdateWithoutAcademicSessionInput>
  }

  export type FeesUpdateManyWithWhereWithoutAcademicSessionInput = {
    where: FeesScalarWhereInput
    data: XOR<FeesUpdateManyMutationInput, FeesUncheckedUpdateManyWithoutAcademicSessionInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutAcademicSessionInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutAcademicSessionInput, InvoiceUncheckedUpdateWithoutAcademicSessionInput>
    create: XOR<InvoiceCreateWithoutAcademicSessionInput, InvoiceUncheckedCreateWithoutAcademicSessionInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutAcademicSessionInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutAcademicSessionInput, InvoiceUncheckedUpdateWithoutAcademicSessionInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutAcademicSessionInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutAcademicSessionInput>
  }

  export type SchoolCreateWithoutTermsInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutSchoolInput
    schoolDirectorVerification?: SchoolDirectorVerificationCreateNestedOneWithoutSchoolInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationCreateNestedOneWithoutSchoolInput
    schoolVerification?: SchoolVerificationCreateNestedOneWithoutSchoolInput
    schoolPayoutDetail?: SchoolPayoutDetailCreateNestedOneWithoutSchoolInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementCreateNestedOneWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    academicSessions?: AcademicSessionCreateNestedManyWithoutSchoolInput
    fees?: FeesCreateNestedManyWithoutSchoolInput
    payouts?: PayoutCreateNestedManyWithoutSchoolInput
    kycverification?: KYCVerificationCreateNestedOneWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutTermsInput = {
    id?: string
    ownerId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolDirectorVerification?: SchoolDirectorVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolVerification?: SchoolVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolPayoutDetail?: SchoolPayoutDetailUncheckedCreateNestedOneWithoutSchoolInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedCreateNestedOneWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    academicSessions?: AcademicSessionUncheckedCreateNestedManyWithoutSchoolInput
    fees?: FeesUncheckedCreateNestedManyWithoutSchoolInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutSchoolInput
    kycverification?: KYCVerificationUncheckedCreateNestedOneWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutTermsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutTermsInput, SchoolUncheckedCreateWithoutTermsInput>
  }

  export type FeesCreateWithoutTermInput = {
    id?: string
    dueAt: Date | string
    latePaymentFee?: Decimal | DecimalJsLike | number | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutFeesInput
    academicSession: AcademicSessionCreateNestedOneWithoutFeesInput
    school: SchoolCreateNestedOneWithoutFeesInput
    feeBreakdowns?: FeeBreakdownCreateNestedManyWithoutFeeInput
  }

  export type FeesUncheckedCreateWithoutTermInput = {
    id?: string
    dueAt: Date | string
    latePaymentFee?: Decimal | DecimalJsLike | number | string
    schoolId: string
    classId: string
    sessionId: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    feeBreakdowns?: FeeBreakdownUncheckedCreateNestedManyWithoutFeeInput
  }

  export type FeesCreateOrConnectWithoutTermInput = {
    where: FeesWhereUniqueInput
    create: XOR<FeesCreateWithoutTermInput, FeesUncheckedCreateWithoutTermInput>
  }

  export type FeesCreateManyTermInputEnvelope = {
    data: FeesCreateManyTermInput | FeesCreateManyTermInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutTermInput = {
    id?: string
    invoiceNo: string
    feeId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueAt: Date | string
    paidAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    guardian: GuardianCreateNestedOneWithoutInvoicesInput
    class: ClassCreateNestedOneWithoutInvoicesInput
    academicSession: AcademicSessionCreateNestedOneWithoutInvoicesInput
    transactions?: TransactionCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutTermInput = {
    id?: string
    invoiceNo: string
    feeId: string
    guardianId: string
    classId: string
    sessionId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueAt: Date | string
    paidAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutTermInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutTermInput, InvoiceUncheckedCreateWithoutTermInput>
  }

  export type InvoiceCreateManyTermInputEnvelope = {
    data: InvoiceCreateManyTermInput | InvoiceCreateManyTermInput[]
    skipDuplicates?: boolean
  }

  export type SchoolUpsertWithoutTermsInput = {
    update: XOR<SchoolUpdateWithoutTermsInput, SchoolUncheckedUpdateWithoutTermsInput>
    create: XOR<SchoolCreateWithoutTermsInput, SchoolUncheckedCreateWithoutTermsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutTermsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutTermsInput, SchoolUncheckedUpdateWithoutTermsInput>
  }

  export type SchoolUpdateWithoutTermsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutSchoolNestedInput
    schoolDirectorVerification?: SchoolDirectorVerificationUpdateOneWithoutSchoolNestedInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUpdateOneWithoutSchoolNestedInput
    schoolVerification?: SchoolVerificationUpdateOneWithoutSchoolNestedInput
    schoolPayoutDetail?: SchoolPayoutDetailUpdateOneWithoutSchoolNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUpdateOneWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    academicSessions?: AcademicSessionUpdateManyWithoutSchoolNestedInput
    fees?: FeesUpdateManyWithoutSchoolNestedInput
    payouts?: PayoutUpdateManyWithoutSchoolNestedInput
    kycverification?: KYCVerificationUpdateOneWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutTermsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolDirectorVerification?: SchoolDirectorVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolVerification?: SchoolVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolPayoutDetail?: SchoolPayoutDetailUncheckedUpdateOneWithoutSchoolNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedUpdateOneWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    academicSessions?: AcademicSessionUncheckedUpdateManyWithoutSchoolNestedInput
    fees?: FeesUncheckedUpdateManyWithoutSchoolNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutSchoolNestedInput
    kycverification?: KYCVerificationUncheckedUpdateOneWithoutSchoolNestedInput
  }

  export type FeesUpsertWithWhereUniqueWithoutTermInput = {
    where: FeesWhereUniqueInput
    update: XOR<FeesUpdateWithoutTermInput, FeesUncheckedUpdateWithoutTermInput>
    create: XOR<FeesCreateWithoutTermInput, FeesUncheckedCreateWithoutTermInput>
  }

  export type FeesUpdateWithWhereUniqueWithoutTermInput = {
    where: FeesWhereUniqueInput
    data: XOR<FeesUpdateWithoutTermInput, FeesUncheckedUpdateWithoutTermInput>
  }

  export type FeesUpdateManyWithWhereWithoutTermInput = {
    where: FeesScalarWhereInput
    data: XOR<FeesUpdateManyMutationInput, FeesUncheckedUpdateManyWithoutTermInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutTermInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutTermInput, InvoiceUncheckedUpdateWithoutTermInput>
    create: XOR<InvoiceCreateWithoutTermInput, InvoiceUncheckedCreateWithoutTermInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutTermInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutTermInput, InvoiceUncheckedUpdateWithoutTermInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutTermInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutTermInput>
  }

  export type ClassCreateWithoutFeesInput = {
    id?: string
    name: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassesInput
    invoices?: InvoiceCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutFeesInput = {
    id?: string
    name: string
    schoolId: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutFeesInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutFeesInput, ClassUncheckedCreateWithoutFeesInput>
  }

  export type AcademicSessionCreateWithoutFeesInput = {
    id?: string
    name: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutAcademicSessionsInput
    invoices?: InvoiceCreateNestedManyWithoutAcademicSessionInput
  }

  export type AcademicSessionUncheckedCreateWithoutFeesInput = {
    id?: string
    name: string
    schoolId: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAcademicSessionInput
  }

  export type AcademicSessionCreateOrConnectWithoutFeesInput = {
    where: AcademicSessionWhereUniqueInput
    create: XOR<AcademicSessionCreateWithoutFeesInput, AcademicSessionUncheckedCreateWithoutFeesInput>
  }

  export type TermCreateWithoutFeesInput = {
    id?: string
    name: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutTermsInput
    invoices?: InvoiceCreateNestedManyWithoutTermInput
  }

  export type TermUncheckedCreateWithoutFeesInput = {
    id?: string
    name: string
    schoolId: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTermInput
  }

  export type TermCreateOrConnectWithoutFeesInput = {
    where: TermWhereUniqueInput
    create: XOR<TermCreateWithoutFeesInput, TermUncheckedCreateWithoutFeesInput>
  }

  export type SchoolCreateWithoutFeesInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutSchoolInput
    schoolDirectorVerification?: SchoolDirectorVerificationCreateNestedOneWithoutSchoolInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationCreateNestedOneWithoutSchoolInput
    schoolVerification?: SchoolVerificationCreateNestedOneWithoutSchoolInput
    schoolPayoutDetail?: SchoolPayoutDetailCreateNestedOneWithoutSchoolInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementCreateNestedOneWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    academicSessions?: AcademicSessionCreateNestedManyWithoutSchoolInput
    terms?: TermCreateNestedManyWithoutSchoolInput
    payouts?: PayoutCreateNestedManyWithoutSchoolInput
    kycverification?: KYCVerificationCreateNestedOneWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutFeesInput = {
    id?: string
    ownerId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolDirectorVerification?: SchoolDirectorVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolVerification?: SchoolVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolPayoutDetail?: SchoolPayoutDetailUncheckedCreateNestedOneWithoutSchoolInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedCreateNestedOneWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    academicSessions?: AcademicSessionUncheckedCreateNestedManyWithoutSchoolInput
    terms?: TermUncheckedCreateNestedManyWithoutSchoolInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutSchoolInput
    kycverification?: KYCVerificationUncheckedCreateNestedOneWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutFeesInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutFeesInput, SchoolUncheckedCreateWithoutFeesInput>
  }

  export type FeeBreakdownCreateWithoutFeeInput = {
    id?: string
    title: string
    amount?: Decimal | DecimalJsLike | number | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeeBreakdownUncheckedCreateWithoutFeeInput = {
    id?: string
    title: string
    amount?: Decimal | DecimalJsLike | number | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeeBreakdownCreateOrConnectWithoutFeeInput = {
    where: FeeBreakdownWhereUniqueInput
    create: XOR<FeeBreakdownCreateWithoutFeeInput, FeeBreakdownUncheckedCreateWithoutFeeInput>
  }

  export type FeeBreakdownCreateManyFeeInputEnvelope = {
    data: FeeBreakdownCreateManyFeeInput | FeeBreakdownCreateManyFeeInput[]
    skipDuplicates?: boolean
  }

  export type ClassUpsertWithoutFeesInput = {
    update: XOR<ClassUpdateWithoutFeesInput, ClassUncheckedUpdateWithoutFeesInput>
    create: XOR<ClassCreateWithoutFeesInput, ClassUncheckedCreateWithoutFeesInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutFeesInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutFeesInput, ClassUncheckedUpdateWithoutFeesInput>
  }

  export type ClassUpdateWithoutFeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    invoices?: InvoiceUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutFeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
  }

  export type AcademicSessionUpsertWithoutFeesInput = {
    update: XOR<AcademicSessionUpdateWithoutFeesInput, AcademicSessionUncheckedUpdateWithoutFeesInput>
    create: XOR<AcademicSessionCreateWithoutFeesInput, AcademicSessionUncheckedCreateWithoutFeesInput>
    where?: AcademicSessionWhereInput
  }

  export type AcademicSessionUpdateToOneWithWhereWithoutFeesInput = {
    where?: AcademicSessionWhereInput
    data: XOR<AcademicSessionUpdateWithoutFeesInput, AcademicSessionUncheckedUpdateWithoutFeesInput>
  }

  export type AcademicSessionUpdateWithoutFeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutAcademicSessionsNestedInput
    invoices?: InvoiceUpdateManyWithoutAcademicSessionNestedInput
  }

  export type AcademicSessionUncheckedUpdateWithoutFeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutAcademicSessionNestedInput
  }

  export type TermUpsertWithoutFeesInput = {
    update: XOR<TermUpdateWithoutFeesInput, TermUncheckedUpdateWithoutFeesInput>
    create: XOR<TermCreateWithoutFeesInput, TermUncheckedCreateWithoutFeesInput>
    where?: TermWhereInput
  }

  export type TermUpdateToOneWithWhereWithoutFeesInput = {
    where?: TermWhereInput
    data: XOR<TermUpdateWithoutFeesInput, TermUncheckedUpdateWithoutFeesInput>
  }

  export type TermUpdateWithoutFeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutTermsNestedInput
    invoices?: InvoiceUpdateManyWithoutTermNestedInput
  }

  export type TermUncheckedUpdateWithoutFeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutTermNestedInput
  }

  export type SchoolUpsertWithoutFeesInput = {
    update: XOR<SchoolUpdateWithoutFeesInput, SchoolUncheckedUpdateWithoutFeesInput>
    create: XOR<SchoolCreateWithoutFeesInput, SchoolUncheckedCreateWithoutFeesInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutFeesInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutFeesInput, SchoolUncheckedUpdateWithoutFeesInput>
  }

  export type SchoolUpdateWithoutFeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutSchoolNestedInput
    schoolDirectorVerification?: SchoolDirectorVerificationUpdateOneWithoutSchoolNestedInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUpdateOneWithoutSchoolNestedInput
    schoolVerification?: SchoolVerificationUpdateOneWithoutSchoolNestedInput
    schoolPayoutDetail?: SchoolPayoutDetailUpdateOneWithoutSchoolNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUpdateOneWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    academicSessions?: AcademicSessionUpdateManyWithoutSchoolNestedInput
    terms?: TermUpdateManyWithoutSchoolNestedInput
    payouts?: PayoutUpdateManyWithoutSchoolNestedInput
    kycverification?: KYCVerificationUpdateOneWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutFeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolDirectorVerification?: SchoolDirectorVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolVerification?: SchoolVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolPayoutDetail?: SchoolPayoutDetailUncheckedUpdateOneWithoutSchoolNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedUpdateOneWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    academicSessions?: AcademicSessionUncheckedUpdateManyWithoutSchoolNestedInput
    terms?: TermUncheckedUpdateManyWithoutSchoolNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutSchoolNestedInput
    kycverification?: KYCVerificationUncheckedUpdateOneWithoutSchoolNestedInput
  }

  export type FeeBreakdownUpsertWithWhereUniqueWithoutFeeInput = {
    where: FeeBreakdownWhereUniqueInput
    update: XOR<FeeBreakdownUpdateWithoutFeeInput, FeeBreakdownUncheckedUpdateWithoutFeeInput>
    create: XOR<FeeBreakdownCreateWithoutFeeInput, FeeBreakdownUncheckedCreateWithoutFeeInput>
  }

  export type FeeBreakdownUpdateWithWhereUniqueWithoutFeeInput = {
    where: FeeBreakdownWhereUniqueInput
    data: XOR<FeeBreakdownUpdateWithoutFeeInput, FeeBreakdownUncheckedUpdateWithoutFeeInput>
  }

  export type FeeBreakdownUpdateManyWithWhereWithoutFeeInput = {
    where: FeeBreakdownScalarWhereInput
    data: XOR<FeeBreakdownUpdateManyMutationInput, FeeBreakdownUncheckedUpdateManyWithoutFeeInput>
  }

  export type FeeBreakdownScalarWhereInput = {
    AND?: FeeBreakdownScalarWhereInput | FeeBreakdownScalarWhereInput[]
    OR?: FeeBreakdownScalarWhereInput[]
    NOT?: FeeBreakdownScalarWhereInput | FeeBreakdownScalarWhereInput[]
    id?: StringFilter<"FeeBreakdown"> | string
    feeId?: StringFilter<"FeeBreakdown"> | string
    title?: StringFilter<"FeeBreakdown"> | string
    amount?: DecimalFilter<"FeeBreakdown"> | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolFilter<"FeeBreakdown"> | boolean
    createdAt?: DateTimeFilter<"FeeBreakdown"> | Date | string
    updatedAt?: DateTimeFilter<"FeeBreakdown"> | Date | string
  }

  export type FeesCreateWithoutFeeBreakdownsInput = {
    id?: string
    dueAt: Date | string
    latePaymentFee?: Decimal | DecimalJsLike | number | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutFeesInput
    academicSession: AcademicSessionCreateNestedOneWithoutFeesInput
    term: TermCreateNestedOneWithoutFeesInput
    school: SchoolCreateNestedOneWithoutFeesInput
  }

  export type FeesUncheckedCreateWithoutFeeBreakdownsInput = {
    id?: string
    dueAt: Date | string
    latePaymentFee?: Decimal | DecimalJsLike | number | string
    schoolId: string
    classId: string
    sessionId: string
    termId: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeesCreateOrConnectWithoutFeeBreakdownsInput = {
    where: FeesWhereUniqueInput
    create: XOR<FeesCreateWithoutFeeBreakdownsInput, FeesUncheckedCreateWithoutFeeBreakdownsInput>
  }

  export type FeesUpsertWithoutFeeBreakdownsInput = {
    update: XOR<FeesUpdateWithoutFeeBreakdownsInput, FeesUncheckedUpdateWithoutFeeBreakdownsInput>
    create: XOR<FeesCreateWithoutFeeBreakdownsInput, FeesUncheckedCreateWithoutFeeBreakdownsInput>
    where?: FeesWhereInput
  }

  export type FeesUpdateToOneWithWhereWithoutFeeBreakdownsInput = {
    where?: FeesWhereInput
    data: XOR<FeesUpdateWithoutFeeBreakdownsInput, FeesUncheckedUpdateWithoutFeeBreakdownsInput>
  }

  export type FeesUpdateWithoutFeeBreakdownsInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latePaymentFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutFeesNestedInput
    academicSession?: AcademicSessionUpdateOneRequiredWithoutFeesNestedInput
    term?: TermUpdateOneRequiredWithoutFeesNestedInput
    school?: SchoolUpdateOneRequiredWithoutFeesNestedInput
  }

  export type FeesUncheckedUpdateWithoutFeeBreakdownsInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latePaymentFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuardianCreateWithoutInvoicesInput = {
    id?: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGuardianInput
    students?: StudentCreateNestedManyWithoutGuardianInput
    linkedStudentProfiles?: LinkedStudentProfileCreateNestedManyWithoutGuardianInput
    transactions?: TransactionCreateNestedManyWithoutGuardianInput
  }

  export type GuardianUncheckedCreateWithoutInvoicesInput = {
    id?: string
    userId: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutGuardianInput
    linkedStudentProfiles?: LinkedStudentProfileUncheckedCreateNestedManyWithoutGuardianInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutGuardianInput
  }

  export type GuardianCreateOrConnectWithoutInvoicesInput = {
    where: GuardianWhereUniqueInput
    create: XOR<GuardianCreateWithoutInvoicesInput, GuardianUncheckedCreateWithoutInvoicesInput>
  }

  export type ClassCreateWithoutInvoicesInput = {
    id?: string
    name: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassesInput
    fees?: FeesCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutInvoicesInput = {
    id?: string
    name: string
    schoolId: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fees?: FeesUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutInvoicesInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutInvoicesInput, ClassUncheckedCreateWithoutInvoicesInput>
  }

  export type AcademicSessionCreateWithoutInvoicesInput = {
    id?: string
    name: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutAcademicSessionsInput
    fees?: FeesCreateNestedManyWithoutAcademicSessionInput
  }

  export type AcademicSessionUncheckedCreateWithoutInvoicesInput = {
    id?: string
    name: string
    schoolId: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fees?: FeesUncheckedCreateNestedManyWithoutAcademicSessionInput
  }

  export type AcademicSessionCreateOrConnectWithoutInvoicesInput = {
    where: AcademicSessionWhereUniqueInput
    create: XOR<AcademicSessionCreateWithoutInvoicesInput, AcademicSessionUncheckedCreateWithoutInvoicesInput>
  }

  export type TermCreateWithoutInvoicesInput = {
    id?: string
    name: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutTermsInput
    fees?: FeesCreateNestedManyWithoutTermInput
  }

  export type TermUncheckedCreateWithoutInvoicesInput = {
    id?: string
    name: string
    schoolId: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fees?: FeesUncheckedCreateNestedManyWithoutTermInput
  }

  export type TermCreateOrConnectWithoutInvoicesInput = {
    where: TermWhereUniqueInput
    create: XOR<TermCreateWithoutInvoicesInput, TermUncheckedCreateWithoutInvoicesInput>
  }

  export type TransactionCreateWithoutInvoiceInput = {
    id?: string
    reference: string
    amount?: Decimal | DecimalJsLike | number | string
    fees?: Decimal | DecimalJsLike | number | string
    status?: $Enums.TransactionStatus
    transactionAt?: Date | string | null
    processedAt?: Date | string | null
    description?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    guardian: GuardianCreateNestedOneWithoutTransactionsInput
    transactionFee?: TransactionFeeCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutInvoiceInput = {
    id?: string
    guardianId: string
    reference: string
    amount?: Decimal | DecimalJsLike | number | string
    fees?: Decimal | DecimalJsLike | number | string
    status?: $Enums.TransactionStatus
    transactionAt?: Date | string | null
    processedAt?: Date | string | null
    description?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    transactionFee?: TransactionFeeUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutInvoiceInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput>
  }

  export type TransactionCreateManyInvoiceInputEnvelope = {
    data: TransactionCreateManyInvoiceInput | TransactionCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type GuardianUpsertWithoutInvoicesInput = {
    update: XOR<GuardianUpdateWithoutInvoicesInput, GuardianUncheckedUpdateWithoutInvoicesInput>
    create: XOR<GuardianCreateWithoutInvoicesInput, GuardianUncheckedCreateWithoutInvoicesInput>
    where?: GuardianWhereInput
  }

  export type GuardianUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: GuardianWhereInput
    data: XOR<GuardianUpdateWithoutInvoicesInput, GuardianUncheckedUpdateWithoutInvoicesInput>
  }

  export type GuardianUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGuardianNestedInput
    students?: StudentUpdateManyWithoutGuardianNestedInput
    linkedStudentProfiles?: LinkedStudentProfileUpdateManyWithoutGuardianNestedInput
    transactions?: TransactionUpdateManyWithoutGuardianNestedInput
  }

  export type GuardianUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutGuardianNestedInput
    linkedStudentProfiles?: LinkedStudentProfileUncheckedUpdateManyWithoutGuardianNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutGuardianNestedInput
  }

  export type ClassUpsertWithoutInvoicesInput = {
    update: XOR<ClassUpdateWithoutInvoicesInput, ClassUncheckedUpdateWithoutInvoicesInput>
    create: XOR<ClassCreateWithoutInvoicesInput, ClassUncheckedCreateWithoutInvoicesInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutInvoicesInput, ClassUncheckedUpdateWithoutInvoicesInput>
  }

  export type ClassUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    fees?: FeesUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fees?: FeesUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
  }

  export type AcademicSessionUpsertWithoutInvoicesInput = {
    update: XOR<AcademicSessionUpdateWithoutInvoicesInput, AcademicSessionUncheckedUpdateWithoutInvoicesInput>
    create: XOR<AcademicSessionCreateWithoutInvoicesInput, AcademicSessionUncheckedCreateWithoutInvoicesInput>
    where?: AcademicSessionWhereInput
  }

  export type AcademicSessionUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: AcademicSessionWhereInput
    data: XOR<AcademicSessionUpdateWithoutInvoicesInput, AcademicSessionUncheckedUpdateWithoutInvoicesInput>
  }

  export type AcademicSessionUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutAcademicSessionsNestedInput
    fees?: FeesUpdateManyWithoutAcademicSessionNestedInput
  }

  export type AcademicSessionUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fees?: FeesUncheckedUpdateManyWithoutAcademicSessionNestedInput
  }

  export type TermUpsertWithoutInvoicesInput = {
    update: XOR<TermUpdateWithoutInvoicesInput, TermUncheckedUpdateWithoutInvoicesInput>
    create: XOR<TermCreateWithoutInvoicesInput, TermUncheckedCreateWithoutInvoicesInput>
    where?: TermWhereInput
  }

  export type TermUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: TermWhereInput
    data: XOR<TermUpdateWithoutInvoicesInput, TermUncheckedUpdateWithoutInvoicesInput>
  }

  export type TermUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutTermsNestedInput
    fees?: FeesUpdateManyWithoutTermNestedInput
  }

  export type TermUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fees?: FeesUncheckedUpdateManyWithoutTermNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutInvoiceInput, TransactionUncheckedUpdateWithoutInvoiceInput>
    create: XOR<TransactionCreateWithoutInvoiceInput, TransactionUncheckedCreateWithoutInvoiceInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutInvoiceInput, TransactionUncheckedUpdateWithoutInvoiceInput>
  }

  export type TransactionUpdateManyWithWhereWithoutInvoiceInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type ClassCreateWithoutStudentsInput = {
    id?: string
    name: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    school: SchoolCreateNestedOneWithoutClassesInput
    fees?: FeesCreateNestedManyWithoutClassInput
    invoices?: InvoiceCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    schoolId: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fees?: FeesUncheckedCreateNestedManyWithoutClassInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutStudentsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
  }

  export type GuardianCreateWithoutStudentsInput = {
    id?: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGuardianInput
    invoices?: InvoiceCreateNestedManyWithoutGuardianInput
    linkedStudentProfiles?: LinkedStudentProfileCreateNestedManyWithoutGuardianInput
    transactions?: TransactionCreateNestedManyWithoutGuardianInput
  }

  export type GuardianUncheckedCreateWithoutStudentsInput = {
    id?: string
    userId: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutGuardianInput
    linkedStudentProfiles?: LinkedStudentProfileUncheckedCreateNestedManyWithoutGuardianInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutGuardianInput
  }

  export type GuardianCreateOrConnectWithoutStudentsInput = {
    where: GuardianWhereUniqueInput
    create: XOR<GuardianCreateWithoutStudentsInput, GuardianUncheckedCreateWithoutStudentsInput>
  }

  export type LinkedStudentProfileCreateWithoutStudentInput = {
    id?: string
    lastGuardiantChanged: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    guardian: GuardianCreateNestedOneWithoutLinkedStudentProfilesInput
  }

  export type LinkedStudentProfileUncheckedCreateWithoutStudentInput = {
    id?: string
    guardianId: string
    lastGuardiantChanged: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LinkedStudentProfileCreateOrConnectWithoutStudentInput = {
    where: LinkedStudentProfileWhereUniqueInput
    create: XOR<LinkedStudentProfileCreateWithoutStudentInput, LinkedStudentProfileUncheckedCreateWithoutStudentInput>
  }

  export type ClassUpsertWithoutStudentsInput = {
    update: XOR<ClassUpdateWithoutStudentsInput, ClassUncheckedUpdateWithoutStudentsInput>
    create: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutStudentsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutStudentsInput, ClassUncheckedUpdateWithoutStudentsInput>
  }

  export type ClassUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    school?: SchoolUpdateOneRequiredWithoutClassesNestedInput
    fees?: FeesUpdateManyWithoutClassNestedInput
    invoices?: InvoiceUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fees?: FeesUncheckedUpdateManyWithoutClassNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClassNestedInput
  }

  export type GuardianUpsertWithoutStudentsInput = {
    update: XOR<GuardianUpdateWithoutStudentsInput, GuardianUncheckedUpdateWithoutStudentsInput>
    create: XOR<GuardianCreateWithoutStudentsInput, GuardianUncheckedCreateWithoutStudentsInput>
    where?: GuardianWhereInput
  }

  export type GuardianUpdateToOneWithWhereWithoutStudentsInput = {
    where?: GuardianWhereInput
    data: XOR<GuardianUpdateWithoutStudentsInput, GuardianUncheckedUpdateWithoutStudentsInput>
  }

  export type GuardianUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGuardianNestedInput
    invoices?: InvoiceUpdateManyWithoutGuardianNestedInput
    linkedStudentProfiles?: LinkedStudentProfileUpdateManyWithoutGuardianNestedInput
    transactions?: TransactionUpdateManyWithoutGuardianNestedInput
  }

  export type GuardianUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutGuardianNestedInput
    linkedStudentProfiles?: LinkedStudentProfileUncheckedUpdateManyWithoutGuardianNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutGuardianNestedInput
  }

  export type LinkedStudentProfileUpsertWithoutStudentInput = {
    update: XOR<LinkedStudentProfileUpdateWithoutStudentInput, LinkedStudentProfileUncheckedUpdateWithoutStudentInput>
    create: XOR<LinkedStudentProfileCreateWithoutStudentInput, LinkedStudentProfileUncheckedCreateWithoutStudentInput>
    where?: LinkedStudentProfileWhereInput
  }

  export type LinkedStudentProfileUpdateToOneWithWhereWithoutStudentInput = {
    where?: LinkedStudentProfileWhereInput
    data: XOR<LinkedStudentProfileUpdateWithoutStudentInput, LinkedStudentProfileUncheckedUpdateWithoutStudentInput>
  }

  export type LinkedStudentProfileUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastGuardiantChanged?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guardian?: GuardianUpdateOneRequiredWithoutLinkedStudentProfilesNestedInput
  }

  export type LinkedStudentProfileUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    guardianId?: StringFieldUpdateOperationsInput | string
    lastGuardiantChanged?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateWithoutLinkedStudentProfileInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    registrationNumber: string
    status?: $Enums.StudentStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutStudentsInput
    guardian?: GuardianCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutLinkedStudentProfileInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    classId: string
    guardianId?: string | null
    registrationNumber: string
    status?: $Enums.StudentStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentCreateOrConnectWithoutLinkedStudentProfileInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutLinkedStudentProfileInput, StudentUncheckedCreateWithoutLinkedStudentProfileInput>
  }

  export type GuardianCreateWithoutLinkedStudentProfilesInput = {
    id?: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGuardianInput
    invoices?: InvoiceCreateNestedManyWithoutGuardianInput
    students?: StudentCreateNestedManyWithoutGuardianInput
    transactions?: TransactionCreateNestedManyWithoutGuardianInput
  }

  export type GuardianUncheckedCreateWithoutLinkedStudentProfilesInput = {
    id?: string
    userId: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutGuardianInput
    students?: StudentUncheckedCreateNestedManyWithoutGuardianInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutGuardianInput
  }

  export type GuardianCreateOrConnectWithoutLinkedStudentProfilesInput = {
    where: GuardianWhereUniqueInput
    create: XOR<GuardianCreateWithoutLinkedStudentProfilesInput, GuardianUncheckedCreateWithoutLinkedStudentProfilesInput>
  }

  export type StudentUpsertWithoutLinkedStudentProfileInput = {
    update: XOR<StudentUpdateWithoutLinkedStudentProfileInput, StudentUncheckedUpdateWithoutLinkedStudentProfileInput>
    create: XOR<StudentCreateWithoutLinkedStudentProfileInput, StudentUncheckedCreateWithoutLinkedStudentProfileInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutLinkedStudentProfileInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutLinkedStudentProfileInput, StudentUncheckedUpdateWithoutLinkedStudentProfileInput>
  }

  export type StudentUpdateWithoutLinkedStudentProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutStudentsNestedInput
    guardian?: GuardianUpdateOneWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutLinkedStudentProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: StringFieldUpdateOperationsInput | string
    guardianId?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuardianUpsertWithoutLinkedStudentProfilesInput = {
    update: XOR<GuardianUpdateWithoutLinkedStudentProfilesInput, GuardianUncheckedUpdateWithoutLinkedStudentProfilesInput>
    create: XOR<GuardianCreateWithoutLinkedStudentProfilesInput, GuardianUncheckedCreateWithoutLinkedStudentProfilesInput>
    where?: GuardianWhereInput
  }

  export type GuardianUpdateToOneWithWhereWithoutLinkedStudentProfilesInput = {
    where?: GuardianWhereInput
    data: XOR<GuardianUpdateWithoutLinkedStudentProfilesInput, GuardianUncheckedUpdateWithoutLinkedStudentProfilesInput>
  }

  export type GuardianUpdateWithoutLinkedStudentProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGuardianNestedInput
    invoices?: InvoiceUpdateManyWithoutGuardianNestedInput
    students?: StudentUpdateManyWithoutGuardianNestedInput
    transactions?: TransactionUpdateManyWithoutGuardianNestedInput
  }

  export type GuardianUncheckedUpdateWithoutLinkedStudentProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutGuardianNestedInput
    students?: StudentUncheckedUpdateManyWithoutGuardianNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutGuardianNestedInput
  }

  export type InvoiceCreateWithoutTransactionsInput = {
    id?: string
    invoiceNo: string
    feeId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueAt: Date | string
    paidAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    guardian: GuardianCreateNestedOneWithoutInvoicesInput
    class: ClassCreateNestedOneWithoutInvoicesInput
    academicSession: AcademicSessionCreateNestedOneWithoutInvoicesInput
    term: TermCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutTransactionsInput = {
    id?: string
    invoiceNo: string
    feeId: string
    guardianId: string
    classId: string
    sessionId: string
    termId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueAt: Date | string
    paidAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutTransactionsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
  }

  export type GuardianCreateWithoutTransactionsInput = {
    id?: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGuardianInput
    invoices?: InvoiceCreateNestedManyWithoutGuardianInput
    students?: StudentCreateNestedManyWithoutGuardianInput
    linkedStudentProfiles?: LinkedStudentProfileCreateNestedManyWithoutGuardianInput
  }

  export type GuardianUncheckedCreateWithoutTransactionsInput = {
    id?: string
    userId: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutGuardianInput
    students?: StudentUncheckedCreateNestedManyWithoutGuardianInput
    linkedStudentProfiles?: LinkedStudentProfileUncheckedCreateNestedManyWithoutGuardianInput
  }

  export type GuardianCreateOrConnectWithoutTransactionsInput = {
    where: GuardianWhereUniqueInput
    create: XOR<GuardianCreateWithoutTransactionsInput, GuardianUncheckedCreateWithoutTransactionsInput>
  }

  export type TransactionFeeCreateWithoutTransactionInput = {
    id?: string
    platformFee?: Decimal | DecimalJsLike | number | string
    latePaymentFee?: Decimal | DecimalJsLike | number | string
    processingFee?: Decimal | DecimalJsLike | number | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionFeeUncheckedCreateWithoutTransactionInput = {
    id?: string
    platformFee?: Decimal | DecimalJsLike | number | string
    latePaymentFee?: Decimal | DecimalJsLike | number | string
    processingFee?: Decimal | DecimalJsLike | number | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionFeeCreateOrConnectWithoutTransactionInput = {
    where: TransactionFeeWhereUniqueInput
    create: XOR<TransactionFeeCreateWithoutTransactionInput, TransactionFeeUncheckedCreateWithoutTransactionInput>
  }

  export type InvoiceUpsertWithoutTransactionsInput = {
    update: XOR<InvoiceUpdateWithoutTransactionsInput, InvoiceUncheckedUpdateWithoutTransactionsInput>
    create: XOR<InvoiceCreateWithoutTransactionsInput, InvoiceUncheckedCreateWithoutTransactionsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutTransactionsInput, InvoiceUncheckedUpdateWithoutTransactionsInput>
  }

  export type InvoiceUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    feeId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guardian?: GuardianUpdateOneRequiredWithoutInvoicesNestedInput
    class?: ClassUpdateOneRequiredWithoutInvoicesNestedInput
    academicSession?: AcademicSessionUpdateOneRequiredWithoutInvoicesNestedInput
    term?: TermUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    feeId?: StringFieldUpdateOperationsInput | string
    guardianId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuardianUpsertWithoutTransactionsInput = {
    update: XOR<GuardianUpdateWithoutTransactionsInput, GuardianUncheckedUpdateWithoutTransactionsInput>
    create: XOR<GuardianCreateWithoutTransactionsInput, GuardianUncheckedCreateWithoutTransactionsInput>
    where?: GuardianWhereInput
  }

  export type GuardianUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: GuardianWhereInput
    data: XOR<GuardianUpdateWithoutTransactionsInput, GuardianUncheckedUpdateWithoutTransactionsInput>
  }

  export type GuardianUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGuardianNestedInput
    invoices?: InvoiceUpdateManyWithoutGuardianNestedInput
    students?: StudentUpdateManyWithoutGuardianNestedInput
    linkedStudentProfiles?: LinkedStudentProfileUpdateManyWithoutGuardianNestedInput
  }

  export type GuardianUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutGuardianNestedInput
    students?: StudentUncheckedUpdateManyWithoutGuardianNestedInput
    linkedStudentProfiles?: LinkedStudentProfileUncheckedUpdateManyWithoutGuardianNestedInput
  }

  export type TransactionFeeUpsertWithoutTransactionInput = {
    update: XOR<TransactionFeeUpdateWithoutTransactionInput, TransactionFeeUncheckedUpdateWithoutTransactionInput>
    create: XOR<TransactionFeeCreateWithoutTransactionInput, TransactionFeeUncheckedCreateWithoutTransactionInput>
    where?: TransactionFeeWhereInput
  }

  export type TransactionFeeUpdateToOneWithWhereWithoutTransactionInput = {
    where?: TransactionFeeWhereInput
    data: XOR<TransactionFeeUpdateWithoutTransactionInput, TransactionFeeUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionFeeUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    latePaymentFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    processingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionFeeUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    latePaymentFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    processingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateWithoutTransactionFeeInput = {
    id?: string
    reference: string
    amount?: Decimal | DecimalJsLike | number | string
    fees?: Decimal | DecimalJsLike | number | string
    status?: $Enums.TransactionStatus
    transactionAt?: Date | string | null
    processedAt?: Date | string | null
    description?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutTransactionsInput
    guardian: GuardianCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutTransactionFeeInput = {
    id?: string
    guardianId: string
    invoiceId: string
    reference: string
    amount?: Decimal | DecimalJsLike | number | string
    fees?: Decimal | DecimalJsLike | number | string
    status?: $Enums.TransactionStatus
    transactionAt?: Date | string | null
    processedAt?: Date | string | null
    description?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutTransactionFeeInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutTransactionFeeInput, TransactionUncheckedCreateWithoutTransactionFeeInput>
  }

  export type TransactionUpsertWithoutTransactionFeeInput = {
    update: XOR<TransactionUpdateWithoutTransactionFeeInput, TransactionUncheckedUpdateWithoutTransactionFeeInput>
    create: XOR<TransactionCreateWithoutTransactionFeeInput, TransactionUncheckedCreateWithoutTransactionFeeInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutTransactionFeeInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutTransactionFeeInput, TransactionUncheckedUpdateWithoutTransactionFeeInput>
  }

  export type TransactionUpdateWithoutTransactionFeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    transactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutTransactionsNestedInput
    guardian?: GuardianUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutTransactionFeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    guardianId?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    transactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolCreateWithoutPayoutsInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutSchoolInput
    schoolDirectorVerification?: SchoolDirectorVerificationCreateNestedOneWithoutSchoolInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationCreateNestedOneWithoutSchoolInput
    schoolVerification?: SchoolVerificationCreateNestedOneWithoutSchoolInput
    schoolPayoutDetail?: SchoolPayoutDetailCreateNestedOneWithoutSchoolInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementCreateNestedOneWithoutSchoolInput
    classes?: ClassCreateNestedManyWithoutSchoolInput
    academicSessions?: AcademicSessionCreateNestedManyWithoutSchoolInput
    terms?: TermCreateNestedManyWithoutSchoolInput
    fees?: FeesCreateNestedManyWithoutSchoolInput
    kycverification?: KYCVerificationCreateNestedOneWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutPayoutsInput = {
    id?: string
    ownerId: string
    name: string
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    lga?: string | null
    postalCode?: string | null
    email: string
    phoneNumber?: string | null
    establishedYear?: number | null
    website?: string | null
    logo?: string | null
    schoolType: $Enums.SchoolType
    ownership: $Enums.SchoolOwnership
    status?: $Enums.SchoolStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    schoolDirectorVerification?: SchoolDirectorVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolVerification?: SchoolVerificationUncheckedCreateNestedOneWithoutSchoolInput
    schoolPayoutDetail?: SchoolPayoutDetailUncheckedCreateNestedOneWithoutSchoolInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedCreateNestedOneWithoutSchoolInput
    classes?: ClassUncheckedCreateNestedManyWithoutSchoolInput
    academicSessions?: AcademicSessionUncheckedCreateNestedManyWithoutSchoolInput
    terms?: TermUncheckedCreateNestedManyWithoutSchoolInput
    fees?: FeesUncheckedCreateNestedManyWithoutSchoolInput
    kycverification?: KYCVerificationUncheckedCreateNestedOneWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutPayoutsInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutPayoutsInput, SchoolUncheckedCreateWithoutPayoutsInput>
  }

  export type SchoolUpsertWithoutPayoutsInput = {
    update: XOR<SchoolUpdateWithoutPayoutsInput, SchoolUncheckedUpdateWithoutPayoutsInput>
    create: XOR<SchoolCreateWithoutPayoutsInput, SchoolUncheckedCreateWithoutPayoutsInput>
    where?: SchoolWhereInput
  }

  export type SchoolUpdateToOneWithWhereWithoutPayoutsInput = {
    where?: SchoolWhereInput
    data: XOR<SchoolUpdateWithoutPayoutsInput, SchoolUncheckedUpdateWithoutPayoutsInput>
  }

  export type SchoolUpdateWithoutPayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutSchoolNestedInput
    schoolDirectorVerification?: SchoolDirectorVerificationUpdateOneWithoutSchoolNestedInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUpdateOneWithoutSchoolNestedInput
    schoolVerification?: SchoolVerificationUpdateOneWithoutSchoolNestedInput
    schoolPayoutDetail?: SchoolPayoutDetailUpdateOneWithoutSchoolNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUpdateOneWithoutSchoolNestedInput
    classes?: ClassUpdateManyWithoutSchoolNestedInput
    academicSessions?: AcademicSessionUpdateManyWithoutSchoolNestedInput
    terms?: TermUpdateManyWithoutSchoolNestedInput
    fees?: FeesUpdateManyWithoutSchoolNestedInput
    kycverification?: KYCVerificationUpdateOneWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutPayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lga?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    establishedYear?: NullableIntFieldUpdateOperationsInput | number | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    schoolType?: EnumSchoolTypeFieldUpdateOperationsInput | $Enums.SchoolType
    ownership?: EnumSchoolOwnershipFieldUpdateOperationsInput | $Enums.SchoolOwnership
    status?: EnumSchoolStatusFieldUpdateOperationsInput | $Enums.SchoolStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolDirectorVerification?: SchoolDirectorVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolOwnershipVerification?: SchoolOwnershipVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolVerification?: SchoolVerificationUncheckedUpdateOneWithoutSchoolNestedInput
    schoolPayoutDetail?: SchoolPayoutDetailUncheckedUpdateOneWithoutSchoolNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedUpdateOneWithoutSchoolNestedInput
    classes?: ClassUncheckedUpdateManyWithoutSchoolNestedInput
    academicSessions?: AcademicSessionUncheckedUpdateManyWithoutSchoolNestedInput
    terms?: TermUncheckedUpdateManyWithoutSchoolNestedInput
    fees?: FeesUncheckedUpdateManyWithoutSchoolNestedInput
    kycverification?: KYCVerificationUncheckedUpdateOneWithoutSchoolNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    firstName: string
    lastName: string
    profileImage?: string | null
    email: string
    type: $Enums.UserType
    phone?: string | null
    accountStatus?: $Enums.AccountStatus
    verifiedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    administrator?: AdministratorCreateNestedOneWithoutUserInput
    guardian?: GuardianCreateNestedOneWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    school?: SchoolCreateNestedOneWithoutOwnerInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementCreateNestedOneWithoutSignedByInput
    credential?: CredentialCreateNestedOneWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    firebaseToken?: FirebaseTokenCreateNestedOneWithoutUserInput
    kycverification?: KYCVerificationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    firstName: string
    lastName: string
    profileImage?: string | null
    email: string
    type: $Enums.UserType
    phone?: string | null
    accountStatus?: $Enums.AccountStatus
    verifiedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    administrator?: AdministratorUncheckedCreateNestedOneWithoutUserInput
    guardian?: GuardianUncheckedCreateNestedOneWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    school?: SchoolUncheckedCreateNestedOneWithoutOwnerInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedCreateNestedOneWithoutSignedByInput
    credential?: CredentialUncheckedCreateNestedOneWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    firebaseToken?: FirebaseTokenUncheckedCreateNestedOneWithoutUserInput
    kycverification?: KYCVerificationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTermsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isPrivacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    administrator?: AdministratorUpdateOneWithoutUserNestedInput
    guardian?: GuardianUpdateOneWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    school?: SchoolUpdateOneWithoutOwnerNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUpdateOneWithoutSignedByNestedInput
    credential?: CredentialUpdateOneWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    firebaseToken?: FirebaseTokenUpdateOneWithoutUserNestedInput
    kycverification?: KYCVerificationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTermsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isPrivacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    administrator?: AdministratorUncheckedUpdateOneWithoutUserNestedInput
    guardian?: GuardianUncheckedUpdateOneWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    school?: SchoolUncheckedUpdateOneWithoutOwnerNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedUpdateOneWithoutSignedByNestedInput
    credential?: CredentialUncheckedUpdateOneWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    firebaseToken?: FirebaseTokenUncheckedUpdateOneWithoutUserNestedInput
    kycverification?: KYCVerificationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutWalletInput = {
    id?: string
    firstName: string
    lastName: string
    profileImage?: string | null
    email: string
    type: $Enums.UserType
    phone?: string | null
    accountStatus?: $Enums.AccountStatus
    verifiedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    administrator?: AdministratorCreateNestedOneWithoutUserInput
    guardian?: GuardianCreateNestedOneWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    school?: SchoolCreateNestedOneWithoutOwnerInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementCreateNestedOneWithoutSignedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    credential?: CredentialCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    firebaseToken?: FirebaseTokenCreateNestedOneWithoutUserInput
    kycverification?: KYCVerificationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWalletInput = {
    id?: string
    firstName: string
    lastName: string
    profileImage?: string | null
    email: string
    type: $Enums.UserType
    phone?: string | null
    accountStatus?: $Enums.AccountStatus
    verifiedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    administrator?: AdministratorUncheckedCreateNestedOneWithoutUserInput
    guardian?: GuardianUncheckedCreateNestedOneWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    school?: SchoolUncheckedCreateNestedOneWithoutOwnerInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedCreateNestedOneWithoutSignedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    credential?: CredentialUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    firebaseToken?: FirebaseTokenUncheckedCreateNestedOneWithoutUserInput
    kycverification?: KYCVerificationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWalletInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
  }

  export type LedgerCreateWithoutWalletInput = {
    id?: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    balanceBefore?: Decimal | DecimalJsLike | number | string
    balanceAfter?: Decimal | DecimalJsLike | number | string
    description?: string | null
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
    transaction: WalletTransactionCreateNestedOneWithoutLedgerInput
  }

  export type LedgerUncheckedCreateWithoutWalletInput = {
    id?: string
    transactionId: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    balanceBefore?: Decimal | DecimalJsLike | number | string
    balanceAfter?: Decimal | DecimalJsLike | number | string
    description?: string | null
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type LedgerCreateOrConnectWithoutWalletInput = {
    where: LedgerWhereUniqueInput
    create: XOR<LedgerCreateWithoutWalletInput, LedgerUncheckedCreateWithoutWalletInput>
  }

  export type LedgerCreateManyWalletInputEnvelope = {
    data: LedgerCreateManyWalletInput | LedgerCreateManyWalletInput[]
    skipDuplicates?: boolean
  }

  export type WalletTransactionCreateWithoutWalletInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string
    fees?: Decimal | DecimalJsLike | number | string
    netAmount?: Decimal | DecimalJsLike | number | string
    reference: string
    type: $Enums.TransactionType
    flow: $Enums.TransactionFlow
    transactionAt?: Date | string | null
    processedAt?: Date | string | null
    desc?: string | null
    status?: $Enums.TransactionStatus
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
    ledger?: LedgerCreateNestedOneWithoutTransactionInput
  }

  export type WalletTransactionUncheckedCreateWithoutWalletInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string
    fees?: Decimal | DecimalJsLike | number | string
    netAmount?: Decimal | DecimalJsLike | number | string
    reference: string
    type: $Enums.TransactionType
    flow: $Enums.TransactionFlow
    transactionAt?: Date | string | null
    processedAt?: Date | string | null
    desc?: string | null
    status?: $Enums.TransactionStatus
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
    ledger?: LedgerUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type WalletTransactionCreateOrConnectWithoutWalletInput = {
    where: WalletTransactionWhereUniqueInput
    create: XOR<WalletTransactionCreateWithoutWalletInput, WalletTransactionUncheckedCreateWithoutWalletInput>
  }

  export type WalletTransactionCreateManyWalletInputEnvelope = {
    data: WalletTransactionCreateManyWalletInput | WalletTransactionCreateManyWalletInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWalletInput = {
    update: XOR<UserUpdateWithoutWalletInput, UserUncheckedUpdateWithoutWalletInput>
    create: XOR<UserCreateWithoutWalletInput, UserUncheckedCreateWithoutWalletInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWalletInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWalletInput, UserUncheckedUpdateWithoutWalletInput>
  }

  export type UserUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTermsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isPrivacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    administrator?: AdministratorUpdateOneWithoutUserNestedInput
    guardian?: GuardianUpdateOneWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    school?: SchoolUpdateOneWithoutOwnerNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUpdateOneWithoutSignedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    credential?: CredentialUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    firebaseToken?: FirebaseTokenUpdateOneWithoutUserNestedInput
    kycverification?: KYCVerificationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTermsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isPrivacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    administrator?: AdministratorUncheckedUpdateOneWithoutUserNestedInput
    guardian?: GuardianUncheckedUpdateOneWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    school?: SchoolUncheckedUpdateOneWithoutOwnerNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedUpdateOneWithoutSignedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    credential?: CredentialUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    firebaseToken?: FirebaseTokenUncheckedUpdateOneWithoutUserNestedInput
    kycverification?: KYCVerificationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type LedgerUpsertWithWhereUniqueWithoutWalletInput = {
    where: LedgerWhereUniqueInput
    update: XOR<LedgerUpdateWithoutWalletInput, LedgerUncheckedUpdateWithoutWalletInput>
    create: XOR<LedgerCreateWithoutWalletInput, LedgerUncheckedCreateWithoutWalletInput>
  }

  export type LedgerUpdateWithWhereUniqueWithoutWalletInput = {
    where: LedgerWhereUniqueInput
    data: XOR<LedgerUpdateWithoutWalletInput, LedgerUncheckedUpdateWithoutWalletInput>
  }

  export type LedgerUpdateManyWithWhereWithoutWalletInput = {
    where: LedgerScalarWhereInput
    data: XOR<LedgerUpdateManyMutationInput, LedgerUncheckedUpdateManyWithoutWalletInput>
  }

  export type LedgerScalarWhereInput = {
    AND?: LedgerScalarWhereInput | LedgerScalarWhereInput[]
    OR?: LedgerScalarWhereInput[]
    NOT?: LedgerScalarWhereInput | LedgerScalarWhereInput[]
    id?: StringFilter<"Ledger"> | string
    walletId?: StringFilter<"Ledger"> | string
    transactionId?: StringFilter<"Ledger"> | string
    debit?: DecimalFilter<"Ledger"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalFilter<"Ledger"> | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFilter<"Ledger"> | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFilter<"Ledger"> | Decimal | DecimalJsLike | number | string
    description?: StringNullableFilter<"Ledger"> | string | null
    isDeleted?: BoolFilter<"Ledger"> | boolean
    updatedAt?: DateTimeFilter<"Ledger"> | Date | string
    createdAt?: DateTimeFilter<"Ledger"> | Date | string
  }

  export type WalletTransactionUpsertWithWhereUniqueWithoutWalletInput = {
    where: WalletTransactionWhereUniqueInput
    update: XOR<WalletTransactionUpdateWithoutWalletInput, WalletTransactionUncheckedUpdateWithoutWalletInput>
    create: XOR<WalletTransactionCreateWithoutWalletInput, WalletTransactionUncheckedCreateWithoutWalletInput>
  }

  export type WalletTransactionUpdateWithWhereUniqueWithoutWalletInput = {
    where: WalletTransactionWhereUniqueInput
    data: XOR<WalletTransactionUpdateWithoutWalletInput, WalletTransactionUncheckedUpdateWithoutWalletInput>
  }

  export type WalletTransactionUpdateManyWithWhereWithoutWalletInput = {
    where: WalletTransactionScalarWhereInput
    data: XOR<WalletTransactionUpdateManyMutationInput, WalletTransactionUncheckedUpdateManyWithoutWalletInput>
  }

  export type WalletTransactionScalarWhereInput = {
    AND?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
    OR?: WalletTransactionScalarWhereInput[]
    NOT?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
    id?: StringFilter<"WalletTransaction"> | string
    walletId?: StringFilter<"WalletTransaction"> | string
    amount?: DecimalFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    fees?: DecimalFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"WalletTransaction"> | Decimal | DecimalJsLike | number | string
    reference?: StringFilter<"WalletTransaction"> | string
    type?: EnumTransactionTypeFilter<"WalletTransaction"> | $Enums.TransactionType
    flow?: EnumTransactionFlowFilter<"WalletTransaction"> | $Enums.TransactionFlow
    transactionAt?: DateTimeNullableFilter<"WalletTransaction"> | Date | string | null
    processedAt?: DateTimeNullableFilter<"WalletTransaction"> | Date | string | null
    desc?: StringNullableFilter<"WalletTransaction"> | string | null
    status?: EnumTransactionStatusFilter<"WalletTransaction"> | $Enums.TransactionStatus
    isDeleted?: BoolFilter<"WalletTransaction"> | boolean
    updatedAt?: DateTimeFilter<"WalletTransaction"> | Date | string
    createdAt?: DateTimeFilter<"WalletTransaction"> | Date | string
  }

  export type WalletCreateWithoutTransactionInput = {
    id?: string
    address: string
    name: string
    tag: string
    routingNumber: string
    balance: string
    status?: $Enums.WalletStatus
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWalletInput
    Ledger?: LedgerCreateNestedManyWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutTransactionInput = {
    id?: string
    userId: string
    address: string
    name: string
    tag: string
    routingNumber: string
    balance: string
    status?: $Enums.WalletStatus
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
    Ledger?: LedgerUncheckedCreateNestedManyWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutTransactionInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutTransactionInput, WalletUncheckedCreateWithoutTransactionInput>
  }

  export type LedgerCreateWithoutTransactionInput = {
    id?: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    balanceBefore?: Decimal | DecimalJsLike | number | string
    balanceAfter?: Decimal | DecimalJsLike | number | string
    description?: string | null
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
    wallet: WalletCreateNestedOneWithoutLedgerInput
  }

  export type LedgerUncheckedCreateWithoutTransactionInput = {
    id?: string
    walletId: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    balanceBefore?: Decimal | DecimalJsLike | number | string
    balanceAfter?: Decimal | DecimalJsLike | number | string
    description?: string | null
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type LedgerCreateOrConnectWithoutTransactionInput = {
    where: LedgerWhereUniqueInput
    create: XOR<LedgerCreateWithoutTransactionInput, LedgerUncheckedCreateWithoutTransactionInput>
  }

  export type WalletUpsertWithoutTransactionInput = {
    update: XOR<WalletUpdateWithoutTransactionInput, WalletUncheckedUpdateWithoutTransactionInput>
    create: XOR<WalletCreateWithoutTransactionInput, WalletUncheckedCreateWithoutTransactionInput>
    where?: WalletWhereInput
  }

  export type WalletUpdateToOneWithWhereWithoutTransactionInput = {
    where?: WalletWhereInput
    data: XOR<WalletUpdateWithoutTransactionInput, WalletUncheckedUpdateWithoutTransactionInput>
  }

  export type WalletUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    routingNumber?: StringFieldUpdateOperationsInput | string
    balance?: StringFieldUpdateOperationsInput | string
    status?: EnumWalletStatusFieldUpdateOperationsInput | $Enums.WalletStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWalletNestedInput
    Ledger?: LedgerUpdateManyWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    routingNumber?: StringFieldUpdateOperationsInput | string
    balance?: StringFieldUpdateOperationsInput | string
    status?: EnumWalletStatusFieldUpdateOperationsInput | $Enums.WalletStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Ledger?: LedgerUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type LedgerUpsertWithoutTransactionInput = {
    update: XOR<LedgerUpdateWithoutTransactionInput, LedgerUncheckedUpdateWithoutTransactionInput>
    create: XOR<LedgerCreateWithoutTransactionInput, LedgerUncheckedCreateWithoutTransactionInput>
    where?: LedgerWhereInput
  }

  export type LedgerUpdateToOneWithWhereWithoutTransactionInput = {
    where?: LedgerWhereInput
    data: XOR<LedgerUpdateWithoutTransactionInput, LedgerUncheckedUpdateWithoutTransactionInput>
  }

  export type LedgerUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet?: WalletUpdateOneRequiredWithoutLedgerNestedInput
  }

  export type LedgerUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletCreateWithoutLedgerInput = {
    id?: string
    address: string
    name: string
    tag: string
    routingNumber: string
    balance: string
    status?: $Enums.WalletStatus
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWalletInput
    Transaction?: WalletTransactionCreateNestedManyWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutLedgerInput = {
    id?: string
    userId: string
    address: string
    name: string
    tag: string
    routingNumber: string
    balance: string
    status?: $Enums.WalletStatus
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
    Transaction?: WalletTransactionUncheckedCreateNestedManyWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutLedgerInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutLedgerInput, WalletUncheckedCreateWithoutLedgerInput>
  }

  export type WalletTransactionCreateWithoutLedgerInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string
    fees?: Decimal | DecimalJsLike | number | string
    netAmount?: Decimal | DecimalJsLike | number | string
    reference: string
    type: $Enums.TransactionType
    flow: $Enums.TransactionFlow
    transactionAt?: Date | string | null
    processedAt?: Date | string | null
    desc?: string | null
    status?: $Enums.TransactionStatus
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
    wallet: WalletCreateNestedOneWithoutTransactionInput
  }

  export type WalletTransactionUncheckedCreateWithoutLedgerInput = {
    id?: string
    walletId: string
    amount?: Decimal | DecimalJsLike | number | string
    fees?: Decimal | DecimalJsLike | number | string
    netAmount?: Decimal | DecimalJsLike | number | string
    reference: string
    type: $Enums.TransactionType
    flow: $Enums.TransactionFlow
    transactionAt?: Date | string | null
    processedAt?: Date | string | null
    desc?: string | null
    status?: $Enums.TransactionStatus
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type WalletTransactionCreateOrConnectWithoutLedgerInput = {
    where: WalletTransactionWhereUniqueInput
    create: XOR<WalletTransactionCreateWithoutLedgerInput, WalletTransactionUncheckedCreateWithoutLedgerInput>
  }

  export type WalletUpsertWithoutLedgerInput = {
    update: XOR<WalletUpdateWithoutLedgerInput, WalletUncheckedUpdateWithoutLedgerInput>
    create: XOR<WalletCreateWithoutLedgerInput, WalletUncheckedCreateWithoutLedgerInput>
    where?: WalletWhereInput
  }

  export type WalletUpdateToOneWithWhereWithoutLedgerInput = {
    where?: WalletWhereInput
    data: XOR<WalletUpdateWithoutLedgerInput, WalletUncheckedUpdateWithoutLedgerInput>
  }

  export type WalletUpdateWithoutLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    routingNumber?: StringFieldUpdateOperationsInput | string
    balance?: StringFieldUpdateOperationsInput | string
    status?: EnumWalletStatusFieldUpdateOperationsInput | $Enums.WalletStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWalletNestedInput
    Transaction?: WalletTransactionUpdateManyWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateWithoutLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    routingNumber?: StringFieldUpdateOperationsInput | string
    balance?: StringFieldUpdateOperationsInput | string
    status?: EnumWalletStatusFieldUpdateOperationsInput | $Enums.WalletStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Transaction?: WalletTransactionUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type WalletTransactionUpsertWithoutLedgerInput = {
    update: XOR<WalletTransactionUpdateWithoutLedgerInput, WalletTransactionUncheckedUpdateWithoutLedgerInput>
    create: XOR<WalletTransactionCreateWithoutLedgerInput, WalletTransactionUncheckedCreateWithoutLedgerInput>
    where?: WalletTransactionWhereInput
  }

  export type WalletTransactionUpdateToOneWithWhereWithoutLedgerInput = {
    where?: WalletTransactionWhereInput
    data: XOR<WalletTransactionUpdateWithoutLedgerInput, WalletTransactionUncheckedUpdateWithoutLedgerInput>
  }

  export type WalletTransactionUpdateWithoutLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    flow?: EnumTransactionFlowFieldUpdateOperationsInput | $Enums.TransactionFlow
    transactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet?: WalletUpdateOneRequiredWithoutTransactionNestedInput
  }

  export type WalletTransactionUncheckedUpdateWithoutLedgerInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    flow?: EnumTransactionFlowFieldUpdateOperationsInput | $Enums.TransactionFlow
    transactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutFirebaseTokenInput = {
    id?: string
    firstName: string
    lastName: string
    profileImage?: string | null
    email: string
    type: $Enums.UserType
    phone?: string | null
    accountStatus?: $Enums.AccountStatus
    verifiedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    administrator?: AdministratorCreateNestedOneWithoutUserInput
    guardian?: GuardianCreateNestedOneWithoutUserInput
    verifications?: VerificationCreateNestedManyWithoutUserInput
    school?: SchoolCreateNestedOneWithoutOwnerInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementCreateNestedOneWithoutSignedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    credential?: CredentialCreateNestedOneWithoutUserInput
    wallet?: WalletCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    kycverification?: KYCVerificationCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFirebaseTokenInput = {
    id?: string
    firstName: string
    lastName: string
    profileImage?: string | null
    email: string
    type: $Enums.UserType
    phone?: string | null
    accountStatus?: $Enums.AccountStatus
    verifiedAt?: Date | string | null
    lastSeenAt?: Date | string | null
    isTermsAccepted?: boolean
    isPrivacyAccepted?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    administrator?: AdministratorUncheckedCreateNestedOneWithoutUserInput
    guardian?: GuardianUncheckedCreateNestedOneWithoutUserInput
    verifications?: VerificationUncheckedCreateNestedManyWithoutUserInput
    school?: SchoolUncheckedCreateNestedOneWithoutOwnerInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedCreateNestedOneWithoutSignedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    credential?: CredentialUncheckedCreateNestedOneWithoutUserInput
    wallet?: WalletUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    kycverification?: KYCVerificationUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFirebaseTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFirebaseTokenInput, UserUncheckedCreateWithoutFirebaseTokenInput>
  }

  export type UserUpsertWithoutFirebaseTokenInput = {
    update: XOR<UserUpdateWithoutFirebaseTokenInput, UserUncheckedUpdateWithoutFirebaseTokenInput>
    create: XOR<UserCreateWithoutFirebaseTokenInput, UserUncheckedCreateWithoutFirebaseTokenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFirebaseTokenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFirebaseTokenInput, UserUncheckedUpdateWithoutFirebaseTokenInput>
  }

  export type UserUpdateWithoutFirebaseTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTermsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isPrivacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    administrator?: AdministratorUpdateOneWithoutUserNestedInput
    guardian?: GuardianUpdateOneWithoutUserNestedInput
    verifications?: VerificationUpdateManyWithoutUserNestedInput
    school?: SchoolUpdateOneWithoutOwnerNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUpdateOneWithoutSignedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    credential?: CredentialUpdateOneWithoutUserNestedInput
    wallet?: WalletUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    kycverification?: KYCVerificationUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFirebaseTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    accountStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTermsAccepted?: BoolFieldUpdateOperationsInput | boolean
    isPrivacyAccepted?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    administrator?: AdministratorUncheckedUpdateOneWithoutUserNestedInput
    guardian?: GuardianUncheckedUpdateOneWithoutUserNestedInput
    verifications?: VerificationUncheckedUpdateManyWithoutUserNestedInput
    school?: SchoolUncheckedUpdateOneWithoutOwnerNestedInput
    schoolAndPlatformLegalAgreement?: SchoolAndPlatformLegalAgreementUncheckedUpdateOneWithoutSignedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    credential?: CredentialUncheckedUpdateOneWithoutUserNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    kycverification?: KYCVerificationUncheckedUpdateOneWithoutUserNestedInput
  }

  export type VerificationCreateManyUserInput = {
    id?: string
    type: $Enums.VerificationType
    code: string
    expiresAt: Date | string
    resendCount?: number
    used?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    message: string
    status?: $Enums.NotificationStatus
    sentAt: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    revoked?: boolean
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type VerificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumVerificationTypeFieldUpdateOperationsInput | $Enums.VerificationType
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resendCount?: IntFieldUpdateOperationsInput | number
    used?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumVerificationTypeFieldUpdateOperationsInput | $Enums.VerificationType
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resendCount?: IntFieldUpdateOperationsInput | number
    used?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumVerificationTypeFieldUpdateOperationsInput | $Enums.VerificationType
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resendCount?: IntFieldUpdateOperationsInput | number
    used?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyGuardianInput = {
    id?: string
    invoiceNo: string
    feeId: string
    classId: string
    sessionId: string
    termId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueAt: Date | string
    paidAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentCreateManyGuardianInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    classId: string
    registrationNumber: string
    status?: $Enums.StudentStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LinkedStudentProfileCreateManyGuardianInput = {
    id?: string
    studentId: string
    lastGuardiantChanged: Date | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyGuardianInput = {
    id?: string
    invoiceId: string
    reference: string
    amount?: Decimal | DecimalJsLike | number | string
    fees?: Decimal | DecimalJsLike | number | string
    status?: $Enums.TransactionStatus
    transactionAt?: Date | string | null
    processedAt?: Date | string | null
    description?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateWithoutGuardianInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    feeId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutInvoicesNestedInput
    academicSession?: AcademicSessionUpdateOneRequiredWithoutInvoicesNestedInput
    term?: TermUpdateOneRequiredWithoutInvoicesNestedInput
    transactions?: TransactionUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutGuardianInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    feeId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutGuardianInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    feeId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpdateWithoutGuardianInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutStudentsNestedInput
    linkedStudentProfile?: LinkedStudentProfileUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutGuardianInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkedStudentProfile?: LinkedStudentProfileUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutGuardianInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkedStudentProfileUpdateWithoutGuardianInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastGuardiantChanged?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutLinkedStudentProfileNestedInput
  }

  export type LinkedStudentProfileUncheckedUpdateWithoutGuardianInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    lastGuardiantChanged?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkedStudentProfileUncheckedUpdateManyWithoutGuardianInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    lastGuardiantChanged?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutGuardianInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    transactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutTransactionsNestedInput
    transactionFee?: TransactionFeeUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutGuardianInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    transactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionFee?: TransactionFeeUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutGuardianInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    transactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassCreateManySchoolInput = {
    id?: string
    name: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicSessionCreateManySchoolInput = {
    id?: string
    name: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TermCreateManySchoolInput = {
    id?: string
    name: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeesCreateManySchoolInput = {
    id?: string
    dueAt: Date | string
    latePaymentFee?: Decimal | DecimalJsLike | number | string
    classId: string
    sessionId: string
    termId: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayoutCreateManySchoolInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string
    processingFee?: Decimal | DecimalJsLike | number | string
    status?: $Enums.PayoutStatus
    initiatedAt: Date | string
    completedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fees?: FeesUpdateManyWithoutClassNestedInput
    invoices?: InvoiceUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fees?: FeesUncheckedUpdateManyWithoutClassNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicSessionUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fees?: FeesUpdateManyWithoutAcademicSessionNestedInput
    invoices?: InvoiceUpdateManyWithoutAcademicSessionNestedInput
  }

  export type AcademicSessionUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fees?: FeesUncheckedUpdateManyWithoutAcademicSessionNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAcademicSessionNestedInput
  }

  export type AcademicSessionUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fees?: FeesUpdateManyWithoutTermNestedInput
    invoices?: InvoiceUpdateManyWithoutTermNestedInput
  }

  export type TermUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fees?: FeesUncheckedUpdateManyWithoutTermNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTermNestedInput
  }

  export type TermUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeesUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latePaymentFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutFeesNestedInput
    academicSession?: AcademicSessionUpdateOneRequiredWithoutFeesNestedInput
    term?: TermUpdateOneRequiredWithoutFeesNestedInput
    feeBreakdowns?: FeeBreakdownUpdateManyWithoutFeeNestedInput
  }

  export type FeesUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latePaymentFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    classId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feeBreakdowns?: FeeBreakdownUncheckedUpdateManyWithoutFeeNestedInput
  }

  export type FeesUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latePaymentFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    classId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayoutUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    processingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayoutUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    processingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayoutUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    processingFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeesCreateManyClassInput = {
    id?: string
    dueAt: Date | string
    latePaymentFee?: Decimal | DecimalJsLike | number | string
    schoolId: string
    sessionId: string
    termId: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyClassInput = {
    id?: string
    invoiceNo: string
    feeId: string
    guardianId: string
    sessionId: string
    termId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueAt: Date | string
    paidAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentCreateManyClassInput = {
    id?: string
    firstName: string
    lastName: string
    image?: string | null
    guardianId?: string | null
    registrationNumber: string
    status?: $Enums.StudentStatus
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeesUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latePaymentFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicSession?: AcademicSessionUpdateOneRequiredWithoutFeesNestedInput
    term?: TermUpdateOneRequiredWithoutFeesNestedInput
    school?: SchoolUpdateOneRequiredWithoutFeesNestedInput
    feeBreakdowns?: FeeBreakdownUpdateManyWithoutFeeNestedInput
  }

  export type FeesUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latePaymentFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    schoolId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feeBreakdowns?: FeeBreakdownUncheckedUpdateManyWithoutFeeNestedInput
  }

  export type FeesUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latePaymentFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    schoolId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    feeId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guardian?: GuardianUpdateOneRequiredWithoutInvoicesNestedInput
    academicSession?: AcademicSessionUpdateOneRequiredWithoutInvoicesNestedInput
    term?: TermUpdateOneRequiredWithoutInvoicesNestedInput
    transactions?: TransactionUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    feeId?: StringFieldUpdateOperationsInput | string
    guardianId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    feeId?: StringFieldUpdateOperationsInput | string
    guardianId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guardian?: GuardianUpdateOneWithoutStudentsNestedInput
    linkedStudentProfile?: LinkedStudentProfileUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    guardianId?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkedStudentProfile?: LinkedStudentProfileUncheckedUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    guardianId?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumStudentStatusFieldUpdateOperationsInput | $Enums.StudentStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeesCreateManyAcademicSessionInput = {
    id?: string
    dueAt: Date | string
    latePaymentFee?: Decimal | DecimalJsLike | number | string
    schoolId: string
    classId: string
    termId: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyAcademicSessionInput = {
    id?: string
    invoiceNo: string
    feeId: string
    guardianId: string
    classId: string
    termId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueAt: Date | string
    paidAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeesUpdateWithoutAcademicSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latePaymentFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutFeesNestedInput
    term?: TermUpdateOneRequiredWithoutFeesNestedInput
    school?: SchoolUpdateOneRequiredWithoutFeesNestedInput
    feeBreakdowns?: FeeBreakdownUpdateManyWithoutFeeNestedInput
  }

  export type FeesUncheckedUpdateWithoutAcademicSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latePaymentFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feeBreakdowns?: FeeBreakdownUncheckedUpdateManyWithoutFeeNestedInput
  }

  export type FeesUncheckedUpdateManyWithoutAcademicSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latePaymentFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutAcademicSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    feeId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guardian?: GuardianUpdateOneRequiredWithoutInvoicesNestedInput
    class?: ClassUpdateOneRequiredWithoutInvoicesNestedInput
    term?: TermUpdateOneRequiredWithoutInvoicesNestedInput
    transactions?: TransactionUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutAcademicSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    feeId?: StringFieldUpdateOperationsInput | string
    guardianId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutAcademicSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    feeId?: StringFieldUpdateOperationsInput | string
    guardianId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    termId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeesCreateManyTermInput = {
    id?: string
    dueAt: Date | string
    latePaymentFee?: Decimal | DecimalJsLike | number | string
    schoolId: string
    classId: string
    sessionId: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyTermInput = {
    id?: string
    invoiceNo: string
    feeId: string
    guardianId: string
    classId: string
    sessionId: string
    totalAmount?: Decimal | DecimalJsLike | number | string
    status?: $Enums.InvoiceStatus
    dueAt: Date | string
    paidAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeesUpdateWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latePaymentFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutFeesNestedInput
    academicSession?: AcademicSessionUpdateOneRequiredWithoutFeesNestedInput
    school?: SchoolUpdateOneRequiredWithoutFeesNestedInput
    feeBreakdowns?: FeeBreakdownUpdateManyWithoutFeeNestedInput
  }

  export type FeesUncheckedUpdateWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latePaymentFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feeBreakdowns?: FeeBreakdownUncheckedUpdateManyWithoutFeeNestedInput
  }

  export type FeesUncheckedUpdateManyWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    latePaymentFee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    schoolId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    feeId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guardian?: GuardianUpdateOneRequiredWithoutInvoicesNestedInput
    class?: ClassUpdateOneRequiredWithoutInvoicesNestedInput
    academicSession?: AcademicSessionUpdateOneRequiredWithoutInvoicesNestedInput
    transactions?: TransactionUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    feeId?: StringFieldUpdateOperationsInput | string
    guardianId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutTermInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNo?: StringFieldUpdateOperationsInput | string
    feeId?: StringFieldUpdateOperationsInput | string
    guardianId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeBreakdownCreateManyFeeInput = {
    id?: string
    title: string
    amount?: Decimal | DecimalJsLike | number | string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeeBreakdownUpdateWithoutFeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeBreakdownUncheckedUpdateWithoutFeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeBreakdownUncheckedUpdateManyWithoutFeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInvoiceInput = {
    id?: string
    guardianId: string
    reference: string
    amount?: Decimal | DecimalJsLike | number | string
    fees?: Decimal | DecimalJsLike | number | string
    status?: $Enums.TransactionStatus
    transactionAt?: Date | string | null
    processedAt?: Date | string | null
    description?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    transactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guardian?: GuardianUpdateOneRequiredWithoutTransactionsNestedInput
    transactionFee?: TransactionFeeUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    guardianId?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    transactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactionFee?: TransactionFeeUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    guardianId?: StringFieldUpdateOperationsInput | string
    reference?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    transactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerCreateManyWalletInput = {
    id?: string
    transactionId: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    balanceBefore?: Decimal | DecimalJsLike | number | string
    balanceAfter?: Decimal | DecimalJsLike | number | string
    description?: string | null
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type WalletTransactionCreateManyWalletInput = {
    id?: string
    amount?: Decimal | DecimalJsLike | number | string
    fees?: Decimal | DecimalJsLike | number | string
    netAmount?: Decimal | DecimalJsLike | number | string
    reference: string
    type: $Enums.TransactionType
    flow: $Enums.TransactionFlow
    transactionAt?: Date | string | null
    processedAt?: Date | string | null
    desc?: string | null
    status?: $Enums.TransactionStatus
    isDeleted?: boolean
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type LedgerUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: WalletTransactionUpdateOneRequiredWithoutLedgerNestedInput
  }

  export type LedgerUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerUncheckedUpdateManyWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceBefore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balanceAfter?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    flow?: EnumTransactionFlowFieldUpdateOperationsInput | $Enums.TransactionFlow
    transactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledger?: LedgerUpdateOneWithoutTransactionNestedInput
  }

  export type WalletTransactionUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    flow?: EnumTransactionFlowFieldUpdateOperationsInput | $Enums.TransactionFlow
    transactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ledger?: LedgerUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type WalletTransactionUncheckedUpdateManyWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    fees?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    flow?: EnumTransactionFlowFieldUpdateOperationsInput | $Enums.TransactionFlow
    transactionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}